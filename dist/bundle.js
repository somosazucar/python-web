(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
var Vibrant;

Vibrant = require('./vibrant');

Vibrant.DefaultOpts.Image = require('./image/browser');

module.exports = Vibrant;

},{"./image/browser":7,"./vibrant":16}],3:[function(require,module,exports){
module.exports = function(r, g, b, a) {
  return a >= 125 && !(r > 250 && g > 250 && b > 250);
};

},{}],4:[function(require,module,exports){
module.exports.Default = require('./default');

},{"./default":3}],5:[function(require,module,exports){
var DefaultGenerator, DefaultOpts, Generator, Swatch, util,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

Swatch = require('../swatch');

util = require('../util');

Generator = require('./index');

DefaultOpts = {
  targetDarkLuma: 0.26,
  maxDarkLuma: 0.45,
  minLightLuma: 0.55,
  targetLightLuma: 0.74,
  minNormalLuma: 0.3,
  targetNormalLuma: 0.5,
  maxNormalLuma: 0.7,
  targetMutesSaturation: 0.3,
  maxMutesSaturation: 0.4,
  targetVibrantSaturation: 1.0,
  minVibrantSaturation: 0.35,
  weightSaturation: 3,
  weightLuma: 6,
  weightPopulation: 1
};

module.exports = DefaultGenerator = (function(superClass) {
  extend(DefaultGenerator, superClass);

  DefaultGenerator.prototype.HighestPopulation = 0;

  function DefaultGenerator(opts) {
    this.opts = util.defaults(opts, DefaultOpts);
    this.VibrantSwatch = null;
    this.LightVibrantSwatch = null;
    this.DarkVibrantSwatch = null;
    this.MutedSwatch = null;
    this.LightMutedSwatch = null;
    this.DarkMutedSwatch = null;
  }

  DefaultGenerator.prototype.generate = function(swatches) {
    this.swatches = swatches;
    this.maxPopulation = this.findMaxPopulation;
    this.generateVarationColors();
    return this.generateEmptySwatches();
  };

  DefaultGenerator.prototype.getVibrantSwatch = function() {
    return this.VibrantSwatch;
  };

  DefaultGenerator.prototype.getLightVibrantSwatch = function() {
    return this.LightVibrantSwatch;
  };

  DefaultGenerator.prototype.getDarkVibrantSwatch = function() {
    return this.DarkVibrantSwatch;
  };

  DefaultGenerator.prototype.getMutedSwatch = function() {
    return this.MutedSwatch;
  };

  DefaultGenerator.prototype.getLightMutedSwatch = function() {
    return this.LightMutedSwatch;
  };

  DefaultGenerator.prototype.getDarkMutedSwatch = function() {
    return this.DarkMutedSwatch;
  };

  DefaultGenerator.prototype.generateVarationColors = function() {
    this.VibrantSwatch = this.findColorVariation(this.opts.targetNormalLuma, this.opts.minNormalLuma, this.opts.maxNormalLuma, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);
    this.LightVibrantSwatch = this.findColorVariation(this.opts.targetLightLuma, this.opts.minLightLuma, 1, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);
    this.DarkVibrantSwatch = this.findColorVariation(this.opts.targetDarkLuma, 0, this.opts.maxDarkLuma, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);
    this.MutedSwatch = this.findColorVariation(this.opts.targetNormalLuma, this.opts.minNormalLuma, this.opts.maxNormalLuma, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);
    this.LightMutedSwatch = this.findColorVariation(this.opts.targetLightLuma, this.opts.minLightLuma, 1, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);
    return this.DarkMutedSwatch = this.findColorVariation(this.opts.targetDarkLuma, 0, this.opts.maxDarkLuma, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);
  };

  DefaultGenerator.prototype.generateEmptySwatches = function() {
    var hsl;
    if (this.VibrantSwatch === null) {
      if (this.DarkVibrantSwatch !== null) {
        hsl = this.DarkVibrantSwatch.getHsl();
        hsl[2] = this.opts.targetNormalLuma;
        this.VibrantSwatch = new Swatch(util.hslToRgb(hsl[0], hsl[1], hsl[2]), 0);
      }
    }
    if (this.DarkVibrantSwatch === null) {
      if (this.VibrantSwatch !== null) {
        hsl = this.VibrantSwatch.getHsl();
        hsl[2] = this.opts.targetDarkLuma;
        return this.DarkVibrantSwatch = new Swatch(util.hslToRgb(hsl[0], hsl[1], hsl[2]), 0);
      }
    }
  };

  DefaultGenerator.prototype.findMaxPopulation = function() {
    var j, len, population, ref, swatch;
    population = 0;
    ref = this.swatches;
    for (j = 0, len = ref.length; j < len; j++) {
      swatch = ref[j];
      population = Math.max(population, swatch.getPopulation());
    }
    return population;
  };

  DefaultGenerator.prototype.findColorVariation = function(targetLuma, minLuma, maxLuma, targetSaturation, minSaturation, maxSaturation) {
    var j, len, luma, max, maxValue, ref, sat, swatch, value;
    max = null;
    maxValue = 0;
    ref = this.swatches;
    for (j = 0, len = ref.length; j < len; j++) {
      swatch = ref[j];
      sat = swatch.getHsl()[1];
      luma = swatch.getHsl()[2];
      if (sat >= minSaturation && sat <= maxSaturation && luma >= minLuma && luma <= maxLuma && !this.isAlreadySelected(swatch)) {
        value = this.createComparisonValue(sat, targetSaturation, luma, targetLuma, swatch.getPopulation(), this.HighestPopulation);
        if (max === null || value > maxValue) {
          max = swatch;
          maxValue = value;
        }
      }
    }
    return max;
  };

  DefaultGenerator.prototype.createComparisonValue = function(saturation, targetSaturation, luma, targetLuma, population, maxPopulation) {
    return this.weightedMean(this.invertDiff(saturation, targetSaturation), this.opts.weightSaturation, this.invertDiff(luma, targetLuma), this.opts.weightLuma, population / maxPopulation, this.opts.weightPopulation);
  };

  DefaultGenerator.prototype.invertDiff = function(value, targetValue) {
    return 1 - Math.abs(value - targetValue);
  };

  DefaultGenerator.prototype.weightedMean = function() {
    var i, sum, sumWeight, value, values, weight;
    values = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    sum = 0;
    sumWeight = 0;
    i = 0;
    while (i < values.length) {
      value = values[i];
      weight = values[i + 1];
      sum += value * weight;
      sumWeight += weight;
      i += 2;
    }
    return sum / sumWeight;
  };

  DefaultGenerator.prototype.isAlreadySelected = function(swatch) {
    return this.VibrantSwatch === swatch || this.DarkVibrantSwatch === swatch || this.LightVibrantSwatch === swatch || this.MutedSwatch === swatch || this.DarkMutedSwatch === swatch || this.LightMutedSwatch === swatch;
  };

  return DefaultGenerator;

})(Generator);

},{"../swatch":14,"../util":15,"./index":6}],6:[function(require,module,exports){
var Generator;

module.exports = Generator = (function() {
  function Generator() {}

  Generator.prototype.generate = function(swatches) {};

  Generator.prototype.getVibrantSwatch = function() {};

  Generator.prototype.getLightVibrantSwatch = function() {};

  Generator.prototype.getDarkVibrantSwatch = function() {};

  Generator.prototype.getMutedSwatch = function() {};

  Generator.prototype.getLightMutedSwatch = function() {};

  Generator.prototype.getDarkMutedSwatch = function() {};

  return Generator;

})();

module.exports.Default = require('./default');

},{"./default":5}],7:[function(require,module,exports){
var BrowserImage, Image, Url, isRelativeUrl, isSameOrigin,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Image = require('./index');

Url = require('url');

isRelativeUrl = function(url) {
  var u;
  u = Url.parse(url);
  return u.protocol === null && u.host === null && u.port === null;
};

isSameOrigin = function(a, b) {
  var ua, ub;
  ua = Url.parse(a);
  ub = Url.parse(b);
  return ua.protocol === ub.protocol && ua.hostname === ub.hostname && ua.port === ub.port;
};

module.exports = BrowserImage = (function(superClass) {
  extend(BrowserImage, superClass);

  function BrowserImage(path, cb) {
    if (typeof path === 'object' && path instanceof HTMLImageElement) {
      this.img = path;
      path = this.img.src;
    } else {
      this.img = document.createElement('img');
      this.img.src = path;
    }
    if (!isRelativeUrl(path) && !isSameOrigin(window.location.href, path)) {
      this.img.crossOrigin = 'anonymous';
    }
    this.img.onload = (function(_this) {
      return function() {
        _this._initCanvas();
        return typeof cb === "function" ? cb(null, _this) : void 0;
      };
    })(this);
    if (this.img.complete) {
      this.img.onload();
    }
    this.img.onerror = (function(_this) {
      return function(e) {
        var err;
        err = new Error("Fail to load image: " + path);
        err.raw = e;
        return typeof cb === "function" ? cb(err) : void 0;
      };
    })(this);
  }

  BrowserImage.prototype._initCanvas = function() {
    this.canvas = document.createElement('canvas');
    this.context = this.canvas.getContext('2d');
    document.body.appendChild(this.canvas);
    this.width = this.canvas.width = this.img.width;
    this.height = this.canvas.height = this.img.height;
    return this.context.drawImage(this.img, 0, 0, this.width, this.height);
  };

  BrowserImage.prototype.clear = function() {
    return this.context.clearRect(0, 0, this.width, this.height);
  };

  BrowserImage.prototype.getWidth = function() {
    return this.width;
  };

  BrowserImage.prototype.getHeight = function() {
    return this.height;
  };

  BrowserImage.prototype.resize = function(w, h, r) {
    this.width = this.canvas.width = w;
    this.height = this.canvas.height = h;
    this.context.scale(r, r);
    return this.context.drawImage(this.img, 0, 0);
  };

  BrowserImage.prototype.update = function(imageData) {
    return this.context.putImageData(imageData, 0, 0);
  };

  BrowserImage.prototype.getPixelCount = function() {
    return this.width * this.height;
  };

  BrowserImage.prototype.getImageData = function() {
    return this.context.getImageData(0, 0, this.width, this.height);
  };

  BrowserImage.prototype.removeCanvas = function() {
    return this.canvas.parentNode.removeChild(this.canvas);
  };

  return BrowserImage;

})(Image);

},{"./index":8,"url":25}],8:[function(require,module,exports){
var Image;

module.exports = Image = (function() {
  function Image() {}

  Image.prototype.clear = function() {};

  Image.prototype.update = function(imageData) {};

  Image.prototype.getWidth = function() {};

  Image.prototype.getHeight = function() {};

  Image.prototype.scaleDown = function(opts) {
    var height, maxSide, ratio, width;
    width = this.getWidth();
    height = this.getHeight();
    ratio = 1;
    if (opts.maxDimension != null) {
      maxSide = Math.max(width, height);
      if (maxSide > opts.maxDimension) {
        ratio = opts.maxDimension / maxSide;
      }
    } else {
      ratio = 1 / opts.quality;
    }
    if (ratio < 1) {
      return this.resize(width * ratio, height * ratio, ratio);
    }
  };

  Image.prototype.resize = function(w, h, r) {};

  Image.prototype.getPixelCount = function() {};

  Image.prototype.getImageData = function() {};

  Image.prototype.removeCanvas = function() {};

  return Image;

})();

},{}],9:[function(require,module,exports){
var MMCQ, PQueue, RSHIFT, SIGBITS, Swatch, VBox, getColorIndex, ref, util;

ref = util = require('../../util'), getColorIndex = ref.getColorIndex, SIGBITS = ref.SIGBITS, RSHIFT = ref.RSHIFT;

Swatch = require('../../swatch');

VBox = require('./vbox');

PQueue = require('./pqueue');

module.exports = MMCQ = (function() {
  MMCQ.DefaultOpts = {
    maxIterations: 1000,
    fractByPopulations: 0.75
  };

  function MMCQ(opts) {
    this.opts = util.defaults(opts, this.constructor.DefaultOpts);
  }

  MMCQ.prototype.quantize = function(pixels, opts) {
    var color, colorCount, hist, pq, pq2, shouldIgnore, swatches, v, vbox;
    if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {
      throw new Error("Wrong MMCQ parameters");
    }
    shouldIgnore = function() {
      return false;
    };
    if (Array.isArray(opts.filters) && opts.filters.length > 0) {
      shouldIgnore = function(r, g, b, a) {
        var f, i, len, ref1;
        ref1 = opts.filters;
        for (i = 0, len = ref1.length; i < len; i++) {
          f = ref1[i];
          if (!f(r, g, b, a)) {
            return true;
          }
        }
        return false;
      };
    }
    vbox = VBox.build(pixels, shouldIgnore);
    hist = vbox.hist;
    colorCount = Object.keys(hist).length;
    pq = new PQueue(function(a, b) {
      return a.count() - b.count();
    });
    pq.push(vbox);
    this._splitBoxes(pq, this.opts.fractByPopulations * opts.colorCount);
    pq2 = new PQueue(function(a, b) {
      return a.count() * a.volume() - b.count() * b.volume();
    });
    pq2.contents = pq.contents;
    this._splitBoxes(pq2, opts.colorCount - pq2.size());
    swatches = [];
    this.vboxes = [];
    while (pq2.size()) {
      v = pq2.pop();
      color = v.avg();
      if (!(typeof shouldIgnore === "function" ? shouldIgnore(color[0], color[1], color[2], 255) : void 0)) {
        this.vboxes.push(v);
        swatches.push(new Swatch(color, v.count()));
      }
    }
    return swatches;
  };

  MMCQ.prototype._splitBoxes = function(pq, target) {
    var colorCount, iteration, maxIterations, ref1, vbox, vbox1, vbox2;
    colorCount = 1;
    iteration = 0;
    maxIterations = this.opts.maxIterations;
    while (iteration < maxIterations) {
      iteration++;
      vbox = pq.pop();
      if (!vbox.count()) {
        continue;
      }
      ref1 = vbox.split(), vbox1 = ref1[0], vbox2 = ref1[1];
      pq.push(vbox1);
      if (vbox2) {
        pq.push(vbox2);
        colorCount++;
      }
      if (colorCount >= target || iteration > maxIterations) {
        return;
      }
    }
  };

  return MMCQ;

})();

},{"../../swatch":14,"../../util":15,"./pqueue":10,"./vbox":11}],10:[function(require,module,exports){
var PQueue;

module.exports = PQueue = (function() {
  function PQueue(comparator) {
    this.comparator = comparator;
    this.contents = [];
    this.sorted = false;
  }

  PQueue.prototype._sort = function() {
    this.contents.sort(this.comparator);
    return this.sorted = true;
  };

  PQueue.prototype.push = function(o) {
    this.contents.push(o);
    return this.sorted = false;
  };

  PQueue.prototype.peek = function(index) {
    if (!this.sorted) {
      this._sort();
    }
    if (index == null) {
      index = this.contents.length - 1;
    }
    return this.contents[index];
  };

  PQueue.prototype.pop = function() {
    if (!this.sorted) {
      this._sort();
    }
    return this.contents.pop();
  };

  PQueue.prototype.size = function() {
    return this.contents.length;
  };

  PQueue.prototype.map = function(f) {
    if (!this.sorted) {
      this._sort();
    }
    return this.contents.map(f);
  };

  return PQueue;

})();

},{}],11:[function(require,module,exports){
var RSHIFT, SIGBITS, VBox, getColorIndex, ref, util;

ref = util = require('../../util'), getColorIndex = ref.getColorIndex, SIGBITS = ref.SIGBITS, RSHIFT = ref.RSHIFT;

module.exports = VBox = (function() {
  VBox.build = function(pixels, shouldIgnore) {
    var a, b, bmax, bmin, g, gmax, gmin, hist, hn, i, index, n, offset, r, rmax, rmin;
    hn = 1 << (3 * SIGBITS);
    hist = new Uint32Array(hn);
    rmax = gmax = bmax = 0;
    rmin = gmin = bmin = Number.MAX_VALUE;
    n = pixels.length / 4;
    i = 0;
    while (i < n) {
      offset = i * 4;
      i++;
      r = pixels[offset + 0];
      g = pixels[offset + 1];
      b = pixels[offset + 2];
      a = pixels[offset + 3];
      if (shouldIgnore(r, g, b, a)) {
        continue;
      }
      r = r >> RSHIFT;
      g = g >> RSHIFT;
      b = b >> RSHIFT;
      index = getColorIndex(r, g, b);
      hist[index] += 1;
      if (r > rmax) {
        rmax = r;
      }
      if (r < rmin) {
        rmin = r;
      }
      if (g > gmax) {
        gmax = g;
      }
      if (g < gmin) {
        gmin = g;
      }
      if (b > bmax) {
        bmax = b;
      }
      if (b < bmin) {
        bmin = b;
      }
    }
    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, hist);
  };

  function VBox(r1, r2, g1, g2, b1, b2, hist1) {
    this.r1 = r1;
    this.r2 = r2;
    this.g1 = g1;
    this.g2 = g2;
    this.b1 = b1;
    this.b2 = b2;
    this.hist = hist1;
  }

  VBox.prototype.invalidate = function() {
    delete this._count;
    delete this._avg;
    return delete this._volume;
  };

  VBox.prototype.volume = function() {
    if (this._volume == null) {
      this._volume = (this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1);
    }
    return this._volume;
  };

  VBox.prototype.count = function() {
    var c, hist;
    if (this._count == null) {
      hist = this.hist;
      c = 0;
      
      for (var r = this.r1; r <= this.r2; r++) {
        for (var g = this.g1; g <= this.g2; g++) {
          for (var b = this.b1; b <= this.b2; b++) {
            var index = getColorIndex(r, g, b);
            c += hist[index];
          }
        }
      }
      ;
      this._count = c;
    }
    return this._count;
  };

  VBox.prototype.clone = function() {
    return new VBox(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.hist);
  };

  VBox.prototype.avg = function() {
    var bsum, gsum, hist, mult, ntot, rsum;
    if (this._avg == null) {
      hist = this.hist;
      ntot = 0;
      mult = 1 << (8 - SIGBITS);
      rsum = gsum = bsum = 0;
      
      for (var r = this.r1; r <= this.r2; r++) {
        for (var g = this.g1; g <= this.g2; g++) {
          for (var b = this.b1; b <= this.b2; b++) {
            var index = getColorIndex(r, g, b);
            var h = hist[index];
            ntot += h;
            rsum += (h * (r + 0.5) * mult);
            gsum += (h * (g + 0.5) * mult);
            bsum += (h * (b + 0.5) * mult);
          }
        }
      }
      ;
      if (ntot) {
        this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];
      } else {
        this._avg = [~~(mult * (this.r1 + this.r2 + 1) / 2), ~~(mult * (this.g1 + this.g2 + 1) / 2), ~~(mult * (this.b1 + this.b2 + 1) / 2)];
      }
    }
    return this._avg;
  };

  VBox.prototype.split = function() {
    var accSum, bw, d, doCut, gw, hist, i, j, maxd, maxw, ref1, reverseSum, rw, splitPoint, sum, total, vbox;
    hist = this.hist;
    if (!this.count()) {
      return null;
    }
    if (this.count() === 1) {
      return [this.clone()];
    }
    rw = this.r2 - this.r1 + 1;
    gw = this.g2 - this.g1 + 1;
    bw = this.b2 - this.b1 + 1;
    maxw = Math.max(rw, gw, bw);
    accSum = null;
    sum = total = 0;
    maxd = null;
    switch (maxw) {
      case rw:
        maxd = 'r';
        accSum = new Uint32Array(this.r2 + 1);
        
        for (var r = this.r1; r <= this.r2; r++) {
          sum = 0
          for (var g = this.g1; g <= this.g2; g++) {
            for (var b = this.b1; b <= this.b2; b++) {
              var index = getColorIndex(r, g, b);
              sum += hist[index];
            }
          }
          total += sum;
          accSum[r] = total;
        }
        ;
        break;
      case gw:
        maxd = 'g';
        accSum = new Uint32Array(this.g2 + 1);
        
        for (var g = this.g1; g <= this.g2; g++) {
          sum = 0
          for (var r = this.r1; r <= this.r2; r++) {
            for (var b = this.b1; b <= this.b2; b++) {
              var index = getColorIndex(r, g, b);
              sum += hist[index];
            }
          }
          total += sum;
          accSum[g] = total;
        }
        ;
        break;
      case bw:
        maxd = 'b';
        accSum = new Uint32Array(this.b2 + 1);
        
        for (var b = this.b1; b <= this.b2; b++) {
          sum = 0
          for (var r = this.r1; r <= this.r2; r++) {
            for (var g = this.g1; g <= this.g2; g++) {
              var index = getColorIndex(r, g, b);
              sum += hist[index];
            }
          }
          total += sum;
          accSum[b] = total;
        }
        ;
    }
    splitPoint = -1;
    reverseSum = new Uint32Array(accSum.length);
    for (i = j = 0, ref1 = accSum.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
      d = accSum[i];
      if (splitPoint < 0 && d > total / 2) {
        splitPoint = i;
      }
      reverseSum[i] = total - d;
    }
    vbox = this;
    doCut = function(d) {
      var c2, d1, d2, dim1, dim2, left, right, vbox1, vbox2;
      dim1 = d + "1";
      dim2 = d + "2";
      d1 = vbox[dim1];
      d2 = vbox[dim2];
      vbox1 = vbox.clone();
      vbox2 = vbox.clone();
      left = splitPoint - d1;
      right = d2 - splitPoint;
      if (left <= right) {
        d2 = Math.min(d2 - 1, ~~(splitPoint + right / 2));
        d2 = Math.max(0, d2);
      } else {
        d2 = Math.max(d1, ~~(splitPoint - 1 - left / 2));
        d2 = Math.min(vbox[dim2], d2);
      }
      while (!accSum[d2]) {
        d2++;
      }
      c2 = reverseSum[d2];
      while (!c2 && accSum[d2 - 1]) {
        c2 = reverseSum[--d2];
      }
      vbox1[dim2] = d2;
      vbox2[dim1] = d2 + 1;
      return [vbox1, vbox2];
    };
    return doCut(maxd);
  };

  VBox.prototype.contains = function(p) {
    var b, g, r;
    r = p[0] >> RSHIFT;
    g = p[1] >> RSHIFT;
    b = p[2] >> RSHIFT;
    return r >= this.r1 && r <= this.r2 && g >= this.g1 && g <= this.g2 && b >= this.b1 && b <= this.b2;
  };

  return VBox;

})();

},{"../../util":15}],12:[function(require,module,exports){
var Quantizer;

module.exports = Quantizer = (function() {
  function Quantizer() {}

  Quantizer.prototype.initialize = function(pixels, opts) {};

  Quantizer.prototype.getQuantizedColors = function() {};

  return Quantizer;

})();

module.exports.MMCQ = require('./mmcq');

},{"./mmcq":13}],13:[function(require,module,exports){
var MMCQ, MMCQImpl, Quantizer, Swatch,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Swatch = require('../swatch');

Quantizer = require('./index');

MMCQImpl = require('./impl/mmcq');

module.exports = MMCQ = (function(superClass) {
  extend(MMCQ, superClass);

  function MMCQ() {
    return MMCQ.__super__.constructor.apply(this, arguments);
  }

  MMCQ.prototype.initialize = function(pixels, opts) {
    var mmcq;
    this.opts = opts;
    mmcq = new MMCQImpl();
    return this.swatches = mmcq.quantize(pixels, this.opts);
  };

  MMCQ.prototype.getQuantizedColors = function() {
    return this.swatches;
  };

  return MMCQ;

})(Quantizer);

},{"../swatch":14,"./impl/mmcq":9,"./index":12}],14:[function(require,module,exports){
var Swatch, util;

util = require('./util');


/*
  From Vibrant.js by Jari Zwarts
  Ported to node.js by AKFish

  Swatch class
 */

module.exports = Swatch = (function() {
  Swatch.prototype.hsl = void 0;

  Swatch.prototype.rgb = void 0;

  Swatch.prototype.population = 1;

  Swatch.prototype.yiq = 0;

  function Swatch(rgb, population) {
    this.rgb = rgb;
    this.population = population;
  }

  Swatch.prototype.getHsl = function() {
    if (!this.hsl) {
      return this.hsl = util.rgbToHsl(this.rgb[0], this.rgb[1], this.rgb[2]);
    } else {
      return this.hsl;
    }
  };

  Swatch.prototype.getPopulation = function() {
    return this.population;
  };

  Swatch.prototype.getRgb = function() {
    return this.rgb;
  };

  Swatch.prototype.getHex = function() {
    return util.rgbToHex(this.rgb[0], this.rgb[1], this.rgb[2]);
  };

  Swatch.prototype.getTitleTextColor = function() {
    this._ensureTextColors();
    if (this.yiq < 200) {
      return "#fff";
    } else {
      return "#000";
    }
  };

  Swatch.prototype.getBodyTextColor = function() {
    this._ensureTextColors();
    if (this.yiq < 150) {
      return "#fff";
    } else {
      return "#000";
    }
  };

  Swatch.prototype._ensureTextColors = function() {
    if (!this.yiq) {
      return this.yiq = (this.rgb[0] * 299 + this.rgb[1] * 587 + this.rgb[2] * 114) / 1000;
    }
  };

  return Swatch;

})();

},{"./util":15}],15:[function(require,module,exports){
var DELTAE94, RSHIFT, SIGBITS;

DELTAE94 = {
  NA: 0,
  PERFECT: 1,
  CLOSE: 2,
  GOOD: 10,
  SIMILAR: 50
};

SIGBITS = 5;

RSHIFT = 8 - SIGBITS;

module.exports = {
  clone: function(o) {
    var _o, key, value;
    if (typeof o === 'object') {
      if (Array.isArray(o)) {
        return o.map((function(_this) {
          return function(v) {
            return _this.clone(v);
          };
        })(this));
      } else {
        _o = {};
        for (key in o) {
          value = o[key];
          _o[key] = this.clone(value);
        }
        return _o;
      }
    }
    return o;
  },
  defaults: function() {
    var _o, i, key, len, o, value;
    o = {};
    for (i = 0, len = arguments.length; i < len; i++) {
      _o = arguments[i];
      for (key in _o) {
        value = _o[key];
        if (o[key] == null) {
          o[key] = this.clone(value);
        }
      }
    }
    return o;
  },
  hexToRgb: function(hex) {
    var m;
    m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (m != null) {
      return [m[1], m[2], m[3]].map(function(s) {
        return parseInt(s, 16);
      });
    }
    return null;
  },
  rgbToHex: function(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);
  },
  rgbToHsl: function(r, g, b) {
    var d, h, l, max, min, s;
    r /= 255;
    g /= 255;
    b /= 255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    h = void 0;
    s = void 0;
    l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
      }
      h /= 6;
    }
    return [h, s, l];
  },
  hslToRgb: function(h, s, l) {
    var b, g, hue2rgb, p, q, r;
    r = void 0;
    g = void 0;
    b = void 0;
    hue2rgb = function(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    };
    if (s === 0) {
      r = g = b = l;
    } else {
      q = l < 0.5 ? l * (1 + s) : l + s - (l * s);
      p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - (1 / 3));
    }
    return [r * 255, g * 255, b * 255];
  },
  rgbToXyz: function(r, g, b) {
    var x, y, z;
    r /= 255;
    g /= 255;
    b /= 255;
    r = r > 0.04045 ? Math.pow((r + 0.005) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.005) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.005) / 1.055, 2.4) : b / 12.92;
    r *= 100;
    g *= 100;
    b *= 100;
    x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x, y, z];
  },
  xyzToCIELab: function(x, y, z) {
    var L, REF_X, REF_Y, REF_Z, a, b;
    REF_X = 95.047;
    REF_Y = 100;
    REF_Z = 108.883;
    x /= REF_X;
    y /= REF_Y;
    z /= REF_Z;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    L = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [L, a, b];
  },
  rgbToCIELab: function(r, g, b) {
    var ref, x, y, z;
    ref = this.rgbToXyz(r, g, b), x = ref[0], y = ref[1], z = ref[2];
    return this.xyzToCIELab(x, y, z);
  },
  deltaE94: function(lab1, lab2) {
    var L1, L2, WEIGHT_C, WEIGHT_H, WEIGHT_L, a1, a2, b1, b2, dL, da, db, xC1, xC2, xDC, xDE, xDH, xDL, xSC, xSH;
    WEIGHT_L = 1;
    WEIGHT_C = 1;
    WEIGHT_H = 1;
    L1 = lab1[0], a1 = lab1[1], b1 = lab1[2];
    L2 = lab2[0], a2 = lab2[1], b2 = lab2[2];
    dL = L1 - L2;
    da = a1 - a2;
    db = b1 - b2;
    xC1 = Math.sqrt(a1 * a1 + b1 * b1);
    xC2 = Math.sqrt(a2 * a2 + b2 * b2);
    xDL = L2 - L1;
    xDC = xC2 - xC1;
    xDE = Math.sqrt(dL * dL + da * da + db * db);
    if (Math.sqrt(xDE) > Math.sqrt(Math.abs(xDL)) + Math.sqrt(Math.abs(xDC))) {
      xDH = Math.sqrt(xDE * xDE - xDL * xDL - xDC * xDC);
    } else {
      xDH = 0;
    }
    xSC = 1 + 0.045 * xC1;
    xSH = 1 + 0.015 * xC1;
    xDL /= WEIGHT_L;
    xDC /= WEIGHT_C * xSC;
    xDH /= WEIGHT_H * xSH;
    return Math.sqrt(xDL * xDL + xDC * xDC + xDH * xDH);
  },
  rgbDiff: function(rgb1, rgb2) {
    var lab1, lab2;
    lab1 = this.rgbToCIELab.apply(this, rgb1);
    lab2 = this.rgbToCIELab.apply(this, rgb2);
    return this.deltaE94(lab1, lab2);
  },
  hexDiff: function(hex1, hex2) {
    var rgb1, rgb2;
    rgb1 = this.hexToRgb(hex1);
    rgb2 = this.hexToRgb(hex2);
    return this.rgbDiff(rgb1, rgb2);
  },
  DELTAE94_DIFF_STATUS: DELTAE94,
  getColorDiffStatus: function(d) {
    if (d < DELTAE94.NA) {
      return "N/A";
    }
    if (d <= DELTAE94.PERFECT) {
      return "Perfect";
    }
    if (d <= DELTAE94.CLOSE) {
      return "Close";
    }
    if (d <= DELTAE94.GOOD) {
      return "Good";
    }
    if (d < DELTAE94.SIMILAR) {
      return "Similar";
    }
    return "Wrong";
  },
  SIGBITS: SIGBITS,
  RSHIFT: RSHIFT,
  getColorIndex: function(r, g, b) {
    return (r << (2 * SIGBITS)) + (g << SIGBITS) + b;
  }
};

},{}],16:[function(require,module,exports){

/*
  From Vibrant.js by Jari Zwarts
  Ported to node.js by AKFish

  Color algorithm class that finds variations on colors in an image.

  Credits
  --------
  Lokesh Dhakar (http://www.lokeshdhakar.com) - Created ColorThief
  Google - Palette support library in Android
 */
var Builder, DefaultGenerator, Filter, Swatch, Vibrant, util,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Swatch = require('./swatch');

util = require('./util');

DefaultGenerator = require('./generator').Default;

Filter = require('./filter');

module.exports = Vibrant = (function() {
  Vibrant.DefaultOpts = {
    colorCount: 64,
    quality: 5,
    generator: new DefaultGenerator(),
    Image: null,
    Quantizer: require('./quantizer').MMCQ,
    filters: []
  };

  Vibrant.from = function(src) {
    return new Builder(src);
  };

  Vibrant.prototype.quantize = require('quantize');

  Vibrant.prototype._swatches = [];

  function Vibrant(sourceImage, opts) {
    this.sourceImage = sourceImage;
    if (opts == null) {
      opts = {};
    }
    this.swatches = bind(this.swatches, this);
    this.opts = util.defaults(opts, this.constructor.DefaultOpts);
    this.generator = this.opts.generator;
  }

  Vibrant.prototype.getPalette = function(cb) {
    var image;
    return image = new this.opts.Image(this.sourceImage, (function(_this) {
      return function(err, image) {
        var error, error1;
        if (err != null) {
          return cb(err);
        }
        try {
          _this._process(image, _this.opts);
          return cb(null, _this.swatches());
        } catch (error1) {
          error = error1;
          return cb(error);
        }
      };
    })(this));
  };

  Vibrant.prototype.getSwatches = function(cb) {
    return this.getPalette(cb);
  };

  Vibrant.prototype._process = function(image, opts) {
    var imageData, quantizer, swatches;
    image.scaleDown(this.opts);
    imageData = image.getImageData();
    quantizer = new this.opts.Quantizer();
    quantizer.initialize(imageData.data, this.opts);
    swatches = quantizer.getQuantizedColors();
    this.generator.generate(swatches);
    return image.removeCanvas();
  };

  Vibrant.prototype.swatches = function() {
    return {
      Vibrant: this.generator.getVibrantSwatch(),
      Muted: this.generator.getMutedSwatch(),
      DarkVibrant: this.generator.getDarkVibrantSwatch(),
      DarkMuted: this.generator.getDarkMutedSwatch(),
      LightVibrant: this.generator.getLightVibrantSwatch(),
      LightMuted: this.generator.getLightMutedSwatch()
    };
  };

  return Vibrant;

})();

module.exports.Builder = Builder = (function() {
  function Builder(src1, opts1) {
    this.src = src1;
    this.opts = opts1 != null ? opts1 : {};
    this.opts.filters = util.clone(Vibrant.DefaultOpts.filters);
  }

  Builder.prototype.maxColorCount = function(n) {
    this.opts.colorCount = n;
    return this;
  };

  Builder.prototype.maxDimension = function(d) {
    this.opts.maxDimension = d;
    return this;
  };

  Builder.prototype.addFilter = function(f) {
    if (typeof f === 'function') {
      this.opts.filters.push(f);
    }
    return this;
  };

  Builder.prototype.removeFilter = function(f) {
    var i;
    if ((i = this.opts.filters.indexOf(f)) > 0) {
      this.opts.filters.splice(i);
    }
    return this;
  };

  Builder.prototype.clearFilters = function() {
    this.opts.filters = [];
    return this;
  };

  Builder.prototype.quality = function(q) {
    this.opts.quality = q;
    return this;
  };

  Builder.prototype.useImage = function(image) {
    this.opts.Image = image;
    return this;
  };

  Builder.prototype.useGenerator = function(generator) {
    this.opts.generator = generator;
    return this;
  };

  Builder.prototype.useQuantizer = function(quantizer) {
    this.opts.Quantizer = quantizer;
    return this;
  };

  Builder.prototype.build = function() {
    if (this.v == null) {
      this.v = new Vibrant(this.src, this.opts);
    }
    return this.v;
  };

  Builder.prototype.getSwatches = function(cb) {
    return this.build().getPalette(cb);
  };

  Builder.prototype.getPalette = function(cb) {
    return this.build().getPalette(cb);
  };

  Builder.prototype.from = function(src) {
    return new Vibrant(src, this.opts);
  };

  return Builder;

})();

module.exports.Util = util;

module.exports.Swatch = Swatch;

module.exports.Quantizer = require('./quantizer/');

module.exports.Generator = require('./generator/');

module.exports.Filter = require('./filter/');

},{"./filter":4,"./filter/":4,"./generator":6,"./generator/":6,"./quantizer":12,"./quantizer/":12,"./swatch":14,"./util":15,"quantize":20}],17:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":18}],18:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],19:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
/*
 * quantize.js Copyright 2008 Nick Rabinowitz
 * Ported to node.js by Olivier Lesnicki
 * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php
 */

// fill out a couple protovis dependencies
/*
 * Block below copied from Protovis: http://mbostock.github.com/protovis/
 * Copyright 2010 Stanford Visualization Group
 * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php
 */
if (!pv) {
    var pv = {
        map: function(array, f) {
            var o = {};
            return f ? array.map(function(d, i) {
                o.index = i;
                return f.call(o, d);
            }) : array.slice();
        },
        naturalOrder: function(a, b) {
            return (a < b) ? -1 : ((a > b) ? 1 : 0);
        },
        sum: function(array, f) {
            var o = {};
            return array.reduce(f ? function(p, d, i) {
                o.index = i;
                return p + f.call(o, d);
            } : function(p, d) {
                return p + d;
            }, 0);
        },
        max: function(array, f) {
            return Math.max.apply(null, f ? pv.map(array, f) : array);
        }
    }
}

/**
 * Basic Javascript port of the MMCQ (modified median cut quantization)
 * algorithm from the Leptonica library (http://www.leptonica.com/).
 * Returns a color map you can use to map original pixels to the reduced
 * palette. Still a work in progress.
 * 
 * @author Nick Rabinowitz
 * @example
 
// array of pixels as [R,G,B] arrays
var myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]
                // etc
                ];
var maxColors = 4;
 
var cmap = MMCQ.quantize(myPixels, maxColors);
var newPalette = cmap.palette();
var newPixels = myPixels.map(function(p) { 
    return cmap.map(p); 
});
 
 */
var MMCQ = (function() {
    // private constants
    var sigbits = 5,
        rshift = 8 - sigbits,
        maxIterations = 1000,
        fractByPopulations = 0.75;

    // get reduced-space color index for a pixel

    function getColorIndex(r, g, b) {
        return (r << (2 * sigbits)) + (g << sigbits) + b;
    }

    // Simple priority queue

    function PQueue(comparator) {
        var contents = [],
            sorted = false;

        function sort() {
            contents.sort(comparator);
            sorted = true;
        }

        return {
            push: function(o) {
                contents.push(o);
                sorted = false;
            },
            peek: function(index) {
                if (!sorted) sort();
                if (index === undefined) index = contents.length - 1;
                return contents[index];
            },
            pop: function() {
                if (!sorted) sort();
                return contents.pop();
            },
            size: function() {
                return contents.length;
            },
            map: function(f) {
                return contents.map(f);
            },
            debug: function() {
                if (!sorted) sort();
                return contents;
            }
        };
    }

    // 3d color space box

    function VBox(r1, r2, g1, g2, b1, b2, histo) {
        var vbox = this;
        vbox.r1 = r1;
        vbox.r2 = r2;
        vbox.g1 = g1;
        vbox.g2 = g2;
        vbox.b1 = b1;
        vbox.b2 = b2;
        vbox.histo = histo;
    }
    VBox.prototype = {
        volume: function(force) {
            var vbox = this;
            if (!vbox._volume || force) {
                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));
            }
            return vbox._volume;
        },
        count: function(force) {
            var vbox = this,
                histo = vbox.histo;
            if (!vbox._count_set || force) {
                var npix = 0,
                    i, j, k, index;
                for (i = vbox.r1; i <= vbox.r2; i++) {
                    for (j = vbox.g1; j <= vbox.g2; j++) {
                        for (k = vbox.b1; k <= vbox.b2; k++) {
                            index = getColorIndex(i, j, k);
                            npix += (histo[index] || 0);
                        }
                    }
                }
                vbox._count = npix;
                vbox._count_set = true;
            }
            return vbox._count;
        },
        copy: function() {
            var vbox = this;
            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);
        },
        avg: function(force) {
            var vbox = this,
                histo = vbox.histo;
            if (!vbox._avg || force) {
                var ntot = 0,
                    mult = 1 << (8 - sigbits),
                    rsum = 0,
                    gsum = 0,
                    bsum = 0,
                    hval,
                    i, j, k, histoindex;
                for (i = vbox.r1; i <= vbox.r2; i++) {
                    for (j = vbox.g1; j <= vbox.g2; j++) {
                        for (k = vbox.b1; k <= vbox.b2; k++) {
                            histoindex = getColorIndex(i, j, k);
                            hval = histo[histoindex] || 0;
                            ntot += hval;
                            rsum += (hval * (i + 0.5) * mult);
                            gsum += (hval * (j + 0.5) * mult);
                            bsum += (hval * (k + 0.5) * mult);
                        }
                    }
                }
                if (ntot) {
                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];
                } else {
                    //console.log('empty box');
                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];
                }
            }
            return vbox._avg;
        },
        contains: function(pixel) {
            var vbox = this,
                rval = pixel[0] >> rshift;
            gval = pixel[1] >> rshift;
            bval = pixel[2] >> rshift;
            return (rval >= vbox.r1 && rval <= vbox.r2 &&
                gval >= vbox.g1 && gval <= vbox.g2 &&
                bval >= vbox.b1 && bval <= vbox.b2);
        }
    };

    // Color map

    function CMap() {
        this.vboxes = new PQueue(function(a, b) {
            return pv.naturalOrder(
                a.vbox.count() * a.vbox.volume(),
                b.vbox.count() * b.vbox.volume()
            )
        });;
    }
    CMap.prototype = {
        push: function(vbox) {
            this.vboxes.push({
                vbox: vbox,
                color: vbox.avg()
            });
        },
        palette: function() {
            return this.vboxes.map(function(vb) {
                return vb.color
            });
        },
        size: function() {
            return this.vboxes.size();
        },
        map: function(color) {
            var vboxes = this.vboxes;
            for (var i = 0; i < vboxes.size(); i++) {
                if (vboxes.peek(i).vbox.contains(color)) {
                    return vboxes.peek(i).color;
                }
            }
            return this.nearest(color);
        },
        nearest: function(color) {
            var vboxes = this.vboxes,
                d1, d2, pColor;
            for (var i = 0; i < vboxes.size(); i++) {
                d2 = Math.sqrt(
                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +
                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +
                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)
                );
                if (d2 < d1 || d1 === undefined) {
                    d1 = d2;
                    pColor = vboxes.peek(i).color;
                }
            }
            return pColor;
        },
        forcebw: function() {
            // XXX: won't  work yet
            var vboxes = this.vboxes;
            vboxes.sort(function(a, b) {
                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))
            });

            // force darkest color to black if everything < 5
            var lowest = vboxes[0].color;
            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)
                vboxes[0].color = [0, 0, 0];

            // force lightest color to white if everything > 251
            var idx = vboxes.length - 1,
                highest = vboxes[idx].color;
            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)
                vboxes[idx].color = [255, 255, 255];
        }
    };

    // histo (1-d array, giving the number of pixels in
    // each quantized region of color space), or null on error

    function getHisto(pixels) {
        var histosize = 1 << (3 * sigbits),
            histo = new Array(histosize),
            index, rval, gval, bval;
        pixels.forEach(function(pixel) {
            rval = pixel[0] >> rshift;
            gval = pixel[1] >> rshift;
            bval = pixel[2] >> rshift;
            index = getColorIndex(rval, gval, bval);
            histo[index] = (histo[index] || 0) + 1;
        });
        return histo;
    }

    function vboxFromPixels(pixels, histo) {
        var rmin = 1000000,
            rmax = 0,
            gmin = 1000000,
            gmax = 0,
            bmin = 1000000,
            bmax = 0,
            rval, gval, bval;
        // find min/max
        pixels.forEach(function(pixel) {
            rval = pixel[0] >> rshift;
            gval = pixel[1] >> rshift;
            bval = pixel[2] >> rshift;
            if (rval < rmin) rmin = rval;
            else if (rval > rmax) rmax = rval;
            if (gval < gmin) gmin = gval;
            else if (gval > gmax) gmax = gval;
            if (bval < bmin) bmin = bval;
            else if (bval > bmax) bmax = bval;
        });
        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);
    }

    function medianCutApply(histo, vbox) {
        if (!vbox.count()) return;

        var rw = vbox.r2 - vbox.r1 + 1,
            gw = vbox.g2 - vbox.g1 + 1,
            bw = vbox.b2 - vbox.b1 + 1,
            maxw = pv.max([rw, gw, bw]);
        // only one pixel, no split
        if (vbox.count() == 1) {
            return [vbox.copy()]
        }
        /* Find the partial sum arrays along the selected axis. */
        var total = 0,
            partialsum = [],
            lookaheadsum = [],
            i, j, k, sum, index;
        if (maxw == rw) {
            for (i = vbox.r1; i <= vbox.r2; i++) {
                sum = 0;
                for (j = vbox.g1; j <= vbox.g2; j++) {
                    for (k = vbox.b1; k <= vbox.b2; k++) {
                        index = getColorIndex(i, j, k);
                        sum += (histo[index] || 0);
                    }
                }
                total += sum;
                partialsum[i] = total;
            }
        } else if (maxw == gw) {
            for (i = vbox.g1; i <= vbox.g2; i++) {
                sum = 0;
                for (j = vbox.r1; j <= vbox.r2; j++) {
                    for (k = vbox.b1; k <= vbox.b2; k++) {
                        index = getColorIndex(j, i, k);
                        sum += (histo[index] || 0);
                    }
                }
                total += sum;
                partialsum[i] = total;
            }
        } else { /* maxw == bw */
            for (i = vbox.b1; i <= vbox.b2; i++) {
                sum = 0;
                for (j = vbox.r1; j <= vbox.r2; j++) {
                    for (k = vbox.g1; k <= vbox.g2; k++) {
                        index = getColorIndex(j, k, i);
                        sum += (histo[index] || 0);
                    }
                }
                total += sum;
                partialsum[i] = total;
            }
        }
        partialsum.forEach(function(d, i) {
            lookaheadsum[i] = total - d
        });

        function doCut(color) {
            var dim1 = color + '1',
                dim2 = color + '2',
                left, right, vbox1, vbox2, d2, count2 = 0;
            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {
                if (partialsum[i] > total / 2) {
                    vbox1 = vbox.copy();
                    vbox2 = vbox.copy();
                    left = i - vbox[dim1];
                    right = vbox[dim2] - i;
                    if (left <= right)
                        d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));
                    else d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));
                    // avoid 0-count boxes
                    while (!partialsum[d2]) d2++;
                    count2 = lookaheadsum[d2];
                    while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];
                    // set dimensions
                    vbox1[dim2] = d2;
                    vbox2[dim1] = vbox1[dim2] + 1;
                    // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());
                    return [vbox1, vbox2];
                }
            }

        }
        // determine the cut planes
        return maxw == rw ? doCut('r') :
            maxw == gw ? doCut('g') :
            doCut('b');
    }

    function quantize(pixels, maxcolors) {
        // short-circuit
        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {
            // console.log('wrong number of maxcolors');
            return false;
        }

        // XXX: check color content and convert to grayscale if insufficient

        var histo = getHisto(pixels),
            histosize = 1 << (3 * sigbits);

        // check that we aren't below maxcolors already
        var nColors = 0;
        histo.forEach(function() {
            nColors++
        });
        if (nColors <= maxcolors) {
            // XXX: generate the new colors from the histo and return
        }

        // get the beginning vbox from the colors
        var vbox = vboxFromPixels(pixels, histo),
            pq = new PQueue(function(a, b) {
                return pv.naturalOrder(a.count(), b.count())
            });
        pq.push(vbox);

        // inner function to do the iteration

        function iter(lh, target) {
            var ncolors = 1,
                niters = 0,
                vbox;
            while (niters < maxIterations) {
                vbox = lh.pop();
                if (!vbox.count()) { /* just put it back */
                    lh.push(vbox);
                    niters++;
                    continue;
                }
                // do the cut
                var vboxes = medianCutApply(histo, vbox),
                    vbox1 = vboxes[0],
                    vbox2 = vboxes[1];

                if (!vbox1) {
                    // console.log("vbox1 not defined; shouldn't happen!");
                    return;
                }
                lh.push(vbox1);
                if (vbox2) { /* vbox2 can be null */
                    lh.push(vbox2);
                    ncolors++;
                }
                if (ncolors >= target) return;
                if (niters++ > maxIterations) {
                    // console.log("infinite loop; perhaps too few pixels!");
                    return;
                }
            }
        }

        // first set of colors, sorted by population
        iter(pq, fractByPopulations * maxcolors);
        // console.log(pq.size(), pq.debug().length, pq.debug().slice());

        // Re-sort by the product of pixel occupancy times the size in color space.
        var pq2 = new PQueue(function(a, b) {
            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())
        });
        while (pq.size()) {
            pq2.push(pq.pop());
        }

        // next set - generate the median cuts using the (npix * vol) sorting.
        iter(pq2, maxcolors - pq2.size());

        // calculate the actual colors
        var cmap = new CMap();
        while (pq2.size()) {
            cmap.push(pq2.pop());
        }

        return cmap;
    }

    return {
        quantize: quantize
    }
})();

module.exports = MMCQ.quantize

},{}],21:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],22:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],23:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":21,"./encode":22}],24:[function(require,module,exports){
(function (process){
var _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114;
function abs(n) {
    return Math.abs(n);
}
function all(a) {
    var itr85, idx85;
    var e;
    itr85 = _Iterable(a);
    for (idx85 = 0; idx85 < itr85.length; idx85++) {
        e = itr85[idx85];
        if (!e) {
            return false;
        }
    }
    return true;
}
function any(a) {
    var itr86, idx86;
    var e;
    itr86 = _Iterable(a);
    for (idx86 = 0; idx86 < itr86.length; idx86++) {
        e = itr86[idx86];
        if (e) {
            return true;
        }
    }
    return false;
}
function bin(a) {
    return "0b" + (a >>> 0).toString(2);
}
function _bind(fn, thisArg) {
    var fn, ret;
    if (fn.orig) {
        fn = fn.orig;
    }
    if (thisArg === false) {
        return fn;
    }
    ret = function() {
        return fn.apply(thisArg, arguments);
    };
    ret.orig = fn;
    return ret;
}
function _rebindAll(thisArg, rebind) {
    var rebind;
    if (rebind === void 0) {
        rebind = true;
    }
    for (var p in thisArg) {
        if (thisArg[p] && thisArg[p].orig) {
            if (rebind) {
                thisArg[p] = _bind(thisArg[p], thisArg);
            } else {
                thisArg[p] = thisArg[p].orig;
            }
        }
    }
}
function cmp(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
chr = String.fromCharCode;
function dir(item) {
    var arr;
    arr = [];
    for (var i in item) {
        arr.push(i);
    }
    return arr;
}
function enumerate(item) {
    var arr, iter, i;
    arr = [];
    iter = _Iterable(item);
    for (i = 0; i < iter.length; i++) {
        arr[arr.length] = [ i, item[i] ];
    }
    return arr;
}
function _eslice(arr, step, start, end) {
    var arr, isString, step, start, end;
    arr = arr.slice(0);
    if (typeof arr === "string" || arr instanceof String) {
        isString = true;
        arr = arr.split("");
    }
    if (step < 0) {
        step = -step;
        arr.reverse();
        if (typeof start !== "undefined") {
            start = arr.length - start - 1;
        }
        if (typeof end !== "undefined") {
            end = arr.length - end - 1;
        }
    }
    if (typeof start === "undefined") {
        start = 0;
    }
    if (typeof end === "undefined") {
        end = arr.length;
    }
    arr = arr.slice(start, end).filter(function(e, i) {
        return i % step === 0;
    });
    return isString ? arr.join("") : arr;
}
function _extends(child, parent) {
    child.prototype = Object.create(parent.prototype);
    child.prototype.__base__ = parent;
    child.prototype.constructor = child;
}
function filter(oper, arr) {
    return arr.filter(oper);
}
function hex(a) {
    return "0x" + (a >>> 0).toString(16);
}
function _in(val, arr) {
    if (typeof arr.indexOf === "function") {
        return arr.indexOf(val) !== -1;
    }
    return arr.hasOwnProperty(val);
}
function _Iterable(iterable) {
    var tmp;
    if (iterable.constructor === [].constructor || iterable.constructor === "".constructor || (tmp = Array.prototype.slice.call(iterable)).length) {
        return tmp || iterable;
    }
    return Object.keys(iterable);
}
function len(obj) {
    var tmp;
    if (obj.constructor === [].constructor || obj.constructor === "".constructor || (tmp = Array.prototype.slice.call(obj)).length) {
        return (tmp || obj).length;
    }
    return Object.keys(obj).length;
}
function map(oper, arr) {
    return arr.map(oper);
}
function max(a) {
    return Math.max.apply(null, Array.isArray(a) ? a : arguments);
}
function min(a) {
    return Math.min.apply(null, Array.isArray(a) ? a : arguments);
}
function _merge(target, source, overwrite) {
    var itr87, idx87;
    var prop;
    for (var i in source) {
        if (source.hasOwnProperty(i) && (overwrite || typeof target[i] === "undefined")) {
            target[i] = source[i];
        }
    }
    itr87 = _Iterable(Object.getOwnPropertyNames(source.prototype));
    for (idx87 = 0; idx87 < itr87.length; idx87++) {
        prop = itr87[idx87];
        if (overwrite || typeof target.prototype[prop] === "undefined") {
            target.prototype[prop] = source.prototype[prop];
        }
    }
}
function _mixin() {
    var classes = [].slice.call(arguments, 0);
    return function(baseClass) {
        var itr88, idx88, itr89, idx89;
        var cls, key;
        itr88 = _Iterable(classes);
        for (idx88 = 0; idx88 < itr88.length; idx88++) {
            cls = itr88[idx88];
            itr89 = _Iterable(Object.getOwnPropertyNames(cls.prototype));
            for (idx89 = 0; idx89 < itr89.length; idx89++) {
                key = itr89[idx89];
                if (!(_in(key, baseClass.prototype))) {
                    baseClass.prototype[key] = cls.prototype[key];
                }
            }
        }
        return baseClass;
    };
}
function _print() {
    if (typeof console === "object") {
        console.log.apply(console, arguments);
    }
}
function range(start, stop, step) {
    var stop, start, step, length, idx, range;
    if (arguments.length <= 1) {
        stop = start || 0;
        start = 0;
    }
    step = arguments[2] || 1;
    length = Math.max(Math.ceil((stop - start) / step), 0);
    idx = 0;
    range = new Array(length);
    while (idx < length) {
        range[idx++] = start;
        start += step;
    }
    return range;
}
function reduce(f, a) {
    return Array.prototype.reduce.call(a, f);
}
function reversed(arr) {
    var tmp;
    tmp = arr.slice(0);
    return tmp.reverse();
}
function sorted(arr) {
    var tmp;
    tmp = arr.slice(0);
    return tmp.sort();
}
function sum(arr, start) {
    start = start === void 0 ? 0 : start;
    return arr.reduce(function(prev, cur) {
        return prev + cur;
    }, start);
}
function _type(obj) {
    return obj && obj.constructor && obj.constructor.name ? obj.constructor.name : Object.prototype.toString.call(obj).slice(8, -1);
}
function zip(a, b) {
    var i;
    return (function() {
        var idx90, itr90 = _Iterable(range(Math.min(a.length, b.length))), res = [], i;
        for (idx90 = 0; idx90 < itr90.length; idx90++) {
            i = itr90[idx90];
            res.push([ a[i], b[i] ]);
        }
        return res;
    })();
}
function getattr(obj, name) {
    return obj[name];
}
function setattr(obj, name, value) {
    obj[name] = value;
}
function hasattr(obj, name) {
    return name in obj;
}
function _eq(a, b) {
    var itr91, idx91;
    var i;
    if (a === b) {
        return true;
    }
    if (Array.isArray(a) && Array.isArray(b) || a instanceof Object && b instanceof Object) {
        if (a.constructor !== b.constructor || a.length !== b.length) {
            return false;
        }
        if (Array.isArray(a)) {
            for (i = 0; i < a.length; i++) {
                if (!_eq(a[i], b[i])) {
                    return false;
                }
            }
        } else {
            if (Object.keys(a).length !== Object.keys(b).length) {
                return false;
            }
            itr91 = _Iterable(a);
            for (idx91 = 0; idx91 < itr91.length; idx91++) {
                i = itr91[idx91];
                if (!_eq(a[i], b[i])) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}
function kwargs(f) {
    var argNames;
    argNames = f.toString().match(/\(([^\)]+)/)[1];
    if (!kwargs.memo[argNames]) {
        kwargs.memo[argNames] = argNames ? argNames.split(",").map(function(s) {
            return s.trim();
        }) : [];
    }
    argNames = kwargs.memo[argNames];
    return function() {
        var args, kw, i;
        args = [].slice.call(arguments);
        if (args.length) {
            kw = args[args.length-1];
            if (typeof kw === "object") {
                for (i = 0; i < argNames.length; i++) {
                    if (_in(argNames[i], kw)) {
                        args[i] = kw[argNames[i]];
                    }
                }
            } else {
                args.push(kw);
            }
        }
        try {
            return f.apply(this, args);
        } catch (_Exception) {
            var e = _Exception;
            if (/Class constructor \w+ cannot be invoked without 'new'/.test(e)) {
                return new f(args);
            }
            throw _Exception;
        }
    };
}
kwargs.memo = {};
var AssertionError = (_124 = function AssertionError() {
    AssertionError.prototype.__init__.apply(this, arguments);
}, _extends(_124, Error), Object.defineProperties(_124.prototype, {
    __init__: {
        enumerable: true, 
        writable: true, 
        value: function __init__(message){
            var self = this;
            self.name = "AssertionError";
            self.message = message;
        }
    }
}), _124);
var IndexError = (_125 = function IndexError() {
    IndexError.prototype.__init__.apply(this, arguments);
}, _extends(_125, Error), Object.defineProperties(_125.prototype, {
    __init__: {
        enumerable: true, 
        writable: true, 
        value: function __init__(message){
            var self = this;
            self.name = "IndexError";
            self.message = message;
        }
    }
}), _125);
var KeyError = (_126 = function KeyError() {
    KeyError.prototype.__init__.apply(this, arguments);
}, _extends(_126, Error), Object.defineProperties(_126.prototype, {
    __init__: {
        enumerable: true, 
        writable: true, 
        value: function __init__(message){
            var self = this;
            self.name = "KeyError";
            self.message = message;
        }
    }
}), _126);
var TypeError = (_127 = function TypeError() {
    TypeError.prototype.__init__.apply(this, arguments);
}, _extends(_127, Error), Object.defineProperties(_127.prototype, {
    __init__: {
        enumerable: true, 
        writable: true, 
        value: function __init__(message){
            var self = this;
            self.name = "TypeError";
            self.message = message;
        }
    }
}), _127);
var ValueError = (_128 = function ValueError() {
    ValueError.prototype.__init__.apply(this, arguments);
}, _extends(_128, Error), Object.defineProperties(_128.prototype, {
    __init__: {
        enumerable: true, 
        writable: true, 
        value: function __init__(message){
            var self = this;
            self.name = "ValueError";
            self.message = message;
        }
    }
}), _128);
var _modules = {};
_modules["utils"] = {};
_modules["ast"] = {};
_modules["tokenizer"] = {};
_modules["parser"] = {};
_modules["_baselib"] = {};
_modules["output"] = {};

(function(){
    var __name__ = "utils";
    var RAPYD_PREFIX, MAP, colors;
    RAPYD_PREFIX = "";
    function slice(a, start) {
        return Array.prototype.slice.call(a, start || 0);
    }
    function member(name, array) {
        var itr1, idx1;
        var i;
        itr1 = _Iterable(range(array.length - 1, -1, -1));
        for (idx1 = 0; idx1 < itr1.length; idx1++) {
            i = itr1[idx1];
            if (array[i] === name) {
                return true;
            }
        }
        return false;
    }
    function find_if(func, array) {
        var i;
        for (i = 0; i < len(array); i++) {
            if (func(array[i])) {
                return array[i];
            }
        }
    }
    function repeat_string(str_, i) {
        var d;
        if (i <= 0) {
            return "";
        }
        if (i === 1) {
            return str_;
        }
        d = repeat_string(str_, i >> 1);
        d += d;
        if (i & 1) {
            d += str_;
        }
        return d;
    }
    function DefaultsError(msg, defs) {
        this.msg = msg;
        this.defs = defs;
    }
    var ImportError = (_1 = function ImportError() {
        ImportError.prototype.__init__.apply(this, arguments);
    }, _extends(_1, Error), Object.defineProperties(_1.prototype, {
        __init__: {
            enumerable: true, 
            writable: true, 
            value: function __init__(message){
                var self = this;
                self.message = message;
            }
        }
    }), _1);
    var ParseError = (_2 = function ParseError() {
        ParseError.prototype.__init__.apply(this, arguments);
    }, _extends(_2, Error), Object.defineProperties(_2.prototype, {
        __init__: {
            enumerable: true, 
            writable: true, 
            value: function __init__(message, line, col, pos, is_eof){
                var self = this;
                self.message = message;
                self.line = line;
                self.col = col;
                self.pos = pos;
                self.stack = new Error().stack;
                self.is_eof = is_eof;
            }
        },
        toString: {
            enumerable: true, 
            writable: true, 
            value: function toString(){
                var self = this;
                return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
            }
        }
    }), _2);
    function defaults(args, defs, croak) {
        var itr2, idx2, itr3, idx3;
        var args, ret, key;
        if (args === true) {
            args = {};
        }
        ret = args || {};
        if (croak) {
            itr2 = _Iterable(ret);
            for (idx2 = 0; idx2 < itr2.length; idx2++) {
                key = itr2[idx2];
                if (!(_in(key, defs))) {
                    throw new DefaultsError("`" + key + "` is not a supported option", defs);
                }
            }
        }
        itr3 = _Iterable(defs);
        for (idx3 = 0; idx3 < itr3.length; idx3++) {
            key = itr3[idx3];
            ret[key] = args && _in(key, args) ? args[key] : defs[key];
        }
        return ret;
    }
    function merge(obj, ext) {
        var itr4, idx4;
        var key;
        itr4 = _Iterable(ext);
        for (idx4 = 0; idx4 < itr4.length; idx4++) {
            key = itr4[idx4];
            obj[key] = ext[key];
        }
        return obj;
    }
    function noop() {
    }
    MAP = function() {
        var skip;
        function MAP(a, f, backwards) {
            var itr5, idx5;
            var ret, top, i;
            ret = [];
            top = [];
            function doit() {
                var val, is_last;
                val = f(a[i], i);
                is_last = val instanceof Last;
                if (is_last) {
                    val = val.v;
                }
                if (val instanceof AtTop) {
                    val = val.v;
                    if (val instanceof Splice) {
                        top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);
                    } else {
                        top.push(val);
                    }
                } else if (val !== skip) {
                    if (val instanceof Splice) {
                        ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);
                    } else {
                        ret.push(val);
                    }
                }
                return is_last;
            }
            if (Array.isArray(a)) {
                if (backwards) {
                    itr5 = _Iterable(range(a.length - 1, -1, -1));
                    for (idx5 = 0; idx5 < itr5.length; idx5++) {
                        i = itr5[idx5];
                        if (doit()) {
                            break;
                        }
                    }
                    ret.reverse();
                    top.reverse();
                } else {
                    for (i = 0; i < len(a); i++) {
                        if (doit()) {
                            break;
                        }
                    }
                }
            } else {
                for (i in a) {
                    if (a.hasOwnProperty(i)) {
                        if (doit()) {
                            break;
                        }
                    }
                }
            }
            return top.concat(ret);
        }
        MAP.at_top = function(val) {
            return new AtTop(val);
        };
        MAP.splice = function(val) {
            return new Splice(val);
        };
        MAP.last = function(val) {
            return new Last(val);
        };
        skip = MAP.skip = {};
        function AtTop(val) {
            this.v = val;
        }
        function Splice(val) {
            this.v = val;
        }
        function Last(val) {
            this.v = val;
        }
        return MAP;
    }();
    function push_uniq(array, el) {
        if (!(_in(el, array))) {
            array.push(el);
        }
    }
    function string_template(text, props) {
        return text.replace(/\{(.+?)\}/g, function(str_, p) {
            return props[p];
        });
    }
    function remove(array, el) {
        var itr6, idx6;
        var idx;
        itr6 = _Iterable(range(array.length - 1, -1, -1));
        for (idx6 = 0; idx6 < itr6.length; idx6++) {
            idx = itr6[idx6];
            if (array[idx] === el) {
                array.splice(i, 1);
            }
        }
    }
    function mergeSort(array, cmp) {
        if (array.length < 2) {
            return array.slice();
        }
        function merge(a, b) {
            var r, ai, bi, i;
            r = [];
            ai = 0;
            bi = 0;
            i = 0;
            while (ai < a.length && bi < b.length) {
                if (cmp(a[ai], b[bi]) <= 0) {
                    r[i] = a[ai];
                    ++ai;
                } else {
                    r[i] = b[bi];
                    ++bi;
                }
                ++i;
            }
            if (ai < a.length) {
                r.push.apply(r, a.slice(ai));
            }
            if (bi < b.length) {
                r.push.apply(r, b.slice(bi));
            }
            return r;
        }
        function _ms(a) {
            var m, left, right;
            if (a.length <= 1) {
                return a;
            }
            m = Math.floor(a.length / 2);
            left = a.slice(0, m);
            right = a.slice(m);
            left = _ms(left);
            right = _ms(right);
            return _merge(left, right);
        }
        return _ms(array);
    }
    function set_difference(a, b) {
        return a.filter(function(el) {
            return !(_in(el, b));
        });
    }
    function set_intersection(a, b) {
        return a.filter(function(el) {
            return _in(el, b);
        });
    }
    function makePredicate(words) {
        var words, f, cats, i, skip, j, cat;
        if (!Array.isArray(words)) {
            words = words.split(" ");
        }
        f = "";
        cats = [];
        for (i = 0; i < len(words); i++) {
            skip = false;
            for (j = 0; j < len(cats); j++) {
                if (cats[j][0].length === words[i].length) {
                    cats[j].push(words[i]);
                    skip = true;
                    break;
                }
            }
            if (!skip) {
                cats.push([ words[i] ]);
            }
        }
        function compareTo(arr) {
            var i;
            if (arr.length === 1) {
                return f += "return str === " + JSON.stringify(arr[0]) + ";";
            }
            f += "switch(str){";
            for (i = 0; i < len(arr); i++) {
                f += "case " + JSON.stringify(arr[i]) + ":";
            }
            f += "return true}return false;";
        }
        if (cats.length > 3) {
            cats.sort(function(a, b) {
                return b.length - a.length;
            });
            f += "switch(str.length){";
            for (i = 0; i < len(cats); i++) {
                cat = cats[i];
                f += "case " + cat[0].length + ":";
                compareTo(cat);
            }
            f += "}";
        } else {
            compareTo(words);
        }
        return new Function("str", f);
    }
    function Dictionary() {
        this._values = Object.create(null);
        this._size = 0;
    }
    Dictionary.prototype = {
        set: function(key, val) {
            if (!this.has(key)) {
                ++this._size;
            }
            this._values["$" + key] = val;
            return this;
        },
        add: function(key, val) {
            if (this.has(key)) {
                this.get(key).push(val);
            } else {
                this.set(key, [ val ]);
            }
            return this;
        },
        get: function(key) {
            return this._values["$" + key];
        },
        del_: function(key) {
            if (this.has(key)) {
                --this._size;
                delete this._values["$" + key];
            }
            return this;
        },
        has: function(key) {
            return _in("$" + key, this._values);
        },
        each: function(f) {
            var i;
            for (i in this._values) {
                f(this._values[i], i.substr(1));
            }
        },
        size: function() {
            return this._size;
        },
        map: function(f) {
            var ret, i;
            ret = [];
            for (i in this._values) {
                ret.push(f(this._values[i], i.substr(1)));
            }
            return ret;
        }
    };
    colors = [ "red", "green", "yellow", "blue", "magenta", "cyan", "white" ];
    function ansi(code) {
        var code;
        code = code || 0;
        return "[" + code + "m";
    }
    function colored(string, color, bold) {
        var prefix;
        prefix = [];
        if (bold) {
            prefix.push(ansi(1));
        }
        if (color) {
            prefix.push(ansi(colors.indexOf(color) + 31));
        }
        return prefix.join("") + string + ansi(0);
    }
    _modules["utils"]["RAPYD_PREFIX"] = RAPYD_PREFIX;

    _modules["utils"]["MAP"] = MAP;

    _modules["utils"]["colors"] = colors;

    _modules["utils"]["slice"] = slice;

    _modules["utils"]["member"] = member;

    _modules["utils"]["find_if"] = find_if;

    _modules["utils"]["repeat_string"] = repeat_string;

    _modules["utils"]["DefaultsError"] = DefaultsError;

    _modules["utils"]["ImportError"] = ImportError;

    _modules["utils"]["ParseError"] = ParseError;

    _modules["utils"]["defaults"] = defaults;

    _modules["utils"]["merge"] = merge;

    _modules["utils"]["noop"] = noop;

    _modules["utils"]["push_uniq"] = push_uniq;

    _modules["utils"]["string_template"] = string_template;

    _modules["utils"]["remove"] = remove;

    _modules["utils"]["mergeSort"] = mergeSort;

    _modules["utils"]["set_difference"] = set_difference;

    _modules["utils"]["set_intersection"] = set_intersection;

    _modules["utils"]["makePredicate"] = makePredicate;

    _modules["utils"]["Dictionary"] = Dictionary;

    _modules["utils"]["ansi"] = ansi;

    _modules["utils"]["colored"] = colored;
})();

(function(){
    var __name__ = "ast";
    var noop = _modules["utils"].noop;
    var string_template = _modules["utils"].string_template;
    var colored = _modules["utils"].colored;
    
    function memoized(f) {
        return function(x) {
            if (!this.computedType) {
                this.computedType = f.call(this, x);
            }
            return this.computedType;
        };
    }
    var AST = (_3 = function AST() {
        AST.prototype.__init__.apply(this, arguments);
    }, Object.defineProperties(_3.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {}        },
        __init__: {
            enumerable: true, 
            writable: true, 
            value: function __init__(initializer){
                var self = this;
                var obj, i;
                if (initializer) {
                    obj = self;
                    while (obj) {
                        for (i in obj.properties) {
                            self[i] = initializer[i];
                        }
                        obj = Object.getPrototypeOf(obj);
                    }
                }
            }
        },
        clone: {
            enumerable: true, 
            writable: true, 
            value: function clone(){
                var self = this;
                return new self.constructor(self);
            }
        }
    }), _3);
    var Token = (_4 = function Token() {
        AST.prototype.__init__.apply(this, arguments);
    }, _extends(_4, AST), Object.defineProperties(_4.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                "type": "The type of the token",
                "value": "The value of the token",
                "line": "The line number at which the token occurs",
                "col": "The column number at which the token occurs",
                "pos": "Absolute position of the token start, relative to document start",
                "endpos": "Absolute position of the token start, relative to document start",
                "newline_before": "True if there was a newline before this token",
                "comments_before": "True if there were comments before this token",
                "file": "Name of the file currently being parsed"
            }        }
    }), _4);
    var Node = (_5 = function Node() {
        AST.prototype.__init__.apply(this, arguments);
    }, _extends(_5, AST), Object.defineProperties(_5.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                "start": "[Token] The first token of this node",
                "end": "[Token] The last token of this node"
            }        },
        computedType: {
            enumerable: true, 
            writable: true, 
            value: null        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(){
                var heap = this;
                return "?";
            })
        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self);
            }
        },
        walk: {
            enumerable: true, 
            writable: true, 
            value: function walk(visitor){
                var self = this;
                return self._walk(visitor);
            }
        },
        _dump: {
            enumerable: true, 
            writable: true, 
            value: function _dump(depth, omit, offset, include_name, compact){
                var itr7, idx7, itr8, idx8, itr9, idx9, itr10, idx10;
                var self = this;
                var key, colored_key, value, element, property;
                function out(string) {
                    var pad;
                    pad = new Array(offset + 1).join("  ");
                    console.log(pad + string);
                }
                if (include_name) {
                    out(colored(_type(self), "yellow"));
                }
                itr7 = _Iterable(this);
                for (idx7 = 0; idx7 < itr7.length; idx7++) {
                    key = itr7[idx7];
                    if (_in(key, omit)) {
                        continue;
                    }
                    colored_key = colored(key + ": ", "blue");
                    value = self[key];
                    if (Array.isArray(value)) {
                        if (value.length) {
                            out(" " + colored_key + "[");
                            if (depth > 1) {
                                itr8 = _Iterable(value);
                                for (idx8 = 0; idx8 < itr8.length; idx8++) {
                                    element = itr8[idx8];
                                    element._dump(depth - 1, omit, offset + 1, true, compact);
                                }
                            } else {
                                itr9 = _Iterable(value);
                                for (idx9 = 0; idx9 < itr9.length; idx9++) {
                                    element = itr9[idx9];
                                    out("   " + colored(_type(element), "yellow"));
                                }
                            }
                            out(" ]");
                        } else {
                            if (!compact) {
                                out(" " + colored_key + "[]");
                            }
                        }
                    } else if (!(_in(value, [ void 0, null ]))) {
                        if (_type(value)) {
                            if (_type(value) === "Token") {
                                if (compact) {
                                    out(" " + colored_key + colored(_type(value) + "(" + value.file + ":" + value.line + ":" + value.col + ": " + value.value + ")", "magenta"));
                                } else {
                                    out(" " + colored_key + colored(_type(value), "magenta"));
                                    itr10 = _Iterable(value);
                                    for (idx10 = 0; idx10 < itr10.length; idx10++) {
                                        property = itr10[idx10];
                                        out("   " + colored(property + ": ", "blue") + value[property]);
                                    }
                                }
                            } else {
                                out(" " + colored_key + colored(_type(value), "yellow"));
                                if (depth > 1) {
                                    value._dump(depth - 1, omit, offset + 1, false, compact);
                                }
                            }
                        } else if (typeof value === "string") {
                            out(" " + colored_key + colored('"' + value + '"', "green"));
                        } else if (typeof value === "number") {
                            out(" " + colored_key + colored(value, "green"));
                        } else if (typeof value === "boolean") {
                            out(" " + colored_key + colored(value, "green"));
                        } else {
                            out(" " + colored_key + colored(value, "red"));
                        }
                    } else {
                        if (!compact) {
                            out(" " + colored_key + value);
                        }
                    }
                }
            }
        },
        dump: {
            enumerable: true, 
            writable: true, 
            value: function dump(depth, omit, compact){
                var self = this;
                depth = depth === void 0 ? 2 : depth;
                omit = omit === void 0 ? [ "start", "end" ] : omit;
                compact = compact === void 0 ? true : compact;
                return self._dump(depth, omit, 0, true, compact);
            }
        }
    }), Object.defineProperties(_5, {
        warn_function: {
            enumerable: true, 
            writable: true, 
            value: function warn_function(self){
            }
        },
        warn: {
            enumerable: true, 
            writable: true, 
            value: function warn(txt, props){
                if (Node.warn_function) {
                    Node.warn_function(string_template(txt, props));
                }
            }
        }
    }), _5);
    var Statement = (_6 = function Statement() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_6, Node), _6);
    var Debugger = (_7 = function Debugger() {
        Statement.prototype.__init__.apply(this, arguments);
    }, _extends(_7, Statement), _7);
    var Directive = (_8 = function Directive() {
        Statement.prototype.__init__.apply(this, arguments);
    }, _extends(_8, Statement), Object.defineProperties(_8.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                value: "[string] The value of this directive as a plain string (it's not an String!)",
                scope: "[Scope/S] The scope that this directive affects"
            }        }
    }), _8);
    var SimpleStatement = (_9 = function SimpleStatement() {
        Statement.prototype.__init__.apply(this, arguments);
    }, _extends(_9, Statement), Object.defineProperties(_9.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                body: "[Node] an expression node (should not be instanceof Statement)"
            }        },
        walk_: {
            enumerable: true, 
            writable: true, 
            value: function walk_(){
                var visitor = this;
                var node;
                node = this;
                return visitor._visit(node, function() {
                    node.body._walk(visitor);
                });
            }
        }
    }), _9);
    function walk_body(node, visitor) {
        var itr11, idx11;
        var stat;
        if (node.body instanceof Statement) {
            node.body._walk(visitor);
        } else if (node.body) {
            itr11 = _Iterable(node.body);
            for (idx11 = 0; idx11 < itr11.length; idx11++) {
                stat = itr11[idx11];
                stat._walk(visitor);
            }
        }
    }
    var Block = (_10 = function Block() {
        Statement.prototype.__init__.apply(this, arguments);
    }, _extends(_10, Statement), Object.defineProperties(_10.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                body: "[Statement*] an array of statements"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    walk_body(self, visitor);
                });
            }
        }
    }), _10);
    var BlockStatement = (_11 = function BlockStatement() {
        Block.prototype.__init__.apply(this, arguments);
    }, _extends(_11, Block), _11);
    var EmptyStatement = (_12 = function EmptyStatement() {
        Statement.prototype.__init__.apply(this, arguments);
    }, _extends(_12, Statement), Object.defineProperties(_12.prototype, {
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self);
            }
        }
    }), _12);
    var StatementWithBody = (_13 = function StatementWithBody() {
        Statement.prototype.__init__.apply(this, arguments);
    }, _extends(_13, Statement), Object.defineProperties(_13.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                body: "[Statement] the body; this should always be present, even if it's an EmptyStatement"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.body._walk(visitor);
                });
            }
        }
    }), _13);
    var LabeledStatement = (_14 = function LabeledStatement() {
        StatementWithBody.prototype.__init__.apply(this, arguments);
    }, _extends(_14, StatementWithBody), Object.defineProperties(_14.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                label: "[Label] a label definition"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.label._walk(visitor);
                    self.body._walk(visitor);
                });
            }
        }
    }), _14);
    var DWLoop = (_15 = function DWLoop() {
        StatementWithBody.prototype.__init__.apply(this, arguments);
    }, _extends(_15, StatementWithBody), Object.defineProperties(_15.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                condition: "[Node] the loop condition.  Should not be instanceof Statement"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.condition._walk(visitor);
                    self.body._walk(visitor);
                });
            }
        }
    }), _15);
    var Do = (_16 = function Do() {
        DWLoop.prototype.__init__.apply(this, arguments);
    }, _extends(_16, DWLoop), _16);
    var While = (_17 = function While() {
        DWLoop.prototype.__init__.apply(this, arguments);
    }, _extends(_17, DWLoop), _17);
    var ForIn = (_18 = function ForIn() {
        StatementWithBody.prototype.__init__.apply(this, arguments);
    }, _extends(_18, StatementWithBody), Object.defineProperties(_18.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                init: "[Node] the `for/in` initialization code",
                name: "[SymbolRef?] the loop variable, only if `init` is Var",
                object: "[Node] the object that we're looping through"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.init._walk(visitor);
                    self.object._walk(visitor);
                    self.body._walk(visitor);
                });
            }
        }
    }), _18);
    var ForJS = (_19 = function ForJS() {
        StatementWithBody.prototype.__init__.apply(this, arguments);
    }, _extends(_19, StatementWithBody), Object.defineProperties(_19.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                condition: "[Verbatim] raw JavaScript conditional"
            }        }
    }), _19);
    var ListComprehension = (_20 = function ListComprehension() {
        ForIn.prototype.__init__.apply(this, arguments);
    }, _extends(_20, ForIn), Object.defineProperties(_20.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                condition: "[Node] the `if` condition",
                statement: "[Node] statement to perform on each element before returning it"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.init._walk(visitor);
                    self.statement._walk(visitor);
                    if (self.condition) {
                        self.condition._walk(visitor);
                    }
                });
            }
        }
    }), _20);
    var DictComprehension = (_21 = function DictComprehension() {
        ListComprehension.prototype.__init__.apply(this, arguments);
    }, _extends(_21, ListComprehension), Object.defineProperties(_21.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                value_statement: "[Node] statement to perform on each value before returning it"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.init._walk(visitor);
                    self.statement._walk(visitor);
                    self.value_statement._walk(visitor);
                    if (self.condition) {
                        self.condition._walk(visitor);
                    }
                });
            }
        }
    }), _21);
    var With = (_22 = function With() {
        StatementWithBody.prototype.__init__.apply(this, arguments);
    }, _extends(_22, StatementWithBody), Object.defineProperties(_22.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                expression: "[Node] the `with` expression"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.expression._walk(visitor);
                    self.body._walk(visitor);
                });
            }
        }
    }), _22);
    var Scope = (_23 = function Scope() {
        Block.prototype.__init__.apply(this, arguments);
    }, _extends(_23, Block), Object.defineProperties(_23.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                docstring: "[string?] docstring for this scope, if any",
                directives: "[string*/S] an array of directives declared in this scope",
                variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
                localvars: "[SymbolDef*] list of variables local to this scope",
                functions: "[Object/S] like `variables`, but only lists function declarations",
                parent_scope: "[Scope?/S] link to the parent scope",
                enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes"
            }        }
    }), _23);
    var TopLevel = (_24 = function TopLevel() {
        Scope.prototype.__init__.apply(this, arguments);
    }, _extends(_24, Scope), Object.defineProperties(_24.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                globals: "[Object/S] a map of name -> SymbolDef for all undeclared names",
                baselib: "[Object/s] a collection of used parts of baselib",
                imports: "[Object/S] a map of module_id->TopLevel for all imported modules",
                nonlocalvars: "[String*] a list of all non-local variable names (names that come from the global scope)",
                strict: "[boolean/S] true if strict directive is in scope",
                shebang: "[string] If #! line is present, it will be stored here",
                import_order: "[number] The global order in which this scope was imported",
                module_id: "[string] The id of this module",
                exports: "[SymbolDef*] list of names exported from this module",
                submodules: "[string*] list of names exported from this module",
                classes: "[Object/S] a map of class names to Class for classes defined in this module",
                filename: "[string] The absolute path to the file from which this module was read",
                srchash: "[string] SHA1 hash of source code, used for caching"
            }        }
    }), _24);
    var Splat = (_25 = function Splat() {
        Statement.prototype.__init__.apply(this, arguments);
    }, _extends(_25, Statement), Object.defineProperties(_25.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                module: "[SymbolVar] name of the module we're splatting",
                key: "[string] The key by which this module is stored in the global modules mapping",
                body: "[TopLevel] parsed contents of the imported file"
            }        }
    }), _25);
    var Import = (_26 = function Import() {
        Statement.prototype.__init__.apply(this, arguments);
    }, _extends(_26, Statement), Object.defineProperties(_26.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                module: "[SymbolVar] name of the module we're importing",
                key: "[string] The key by which this module is stored in the global modules mapping",
                alias: "[SymbolAlias] The name this module is imported as, can be None. For import x as y statements.",
                argnames: "[ImportedVar*] names of objects to be imported",
                body: "[TopLevel] parsed contents of the imported file"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    var itr12, idx12;
                    var arg;
                    itr12 = _Iterable(self.argnames);
                    for (idx12 = 0; idx12 < itr12.length; idx12++) {
                        arg = itr12[idx12];
                        arg._walk(visitor);
                    }
                });
            }
        }
    }), _26);
    var Imports = (_27 = function Imports() {
        Statement.prototype.__init__.apply(this, arguments);
    }, _extends(_27, Statement), Object.defineProperties(_27.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                "imports": "[Import+] array of imports"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    var itr13, idx13;
                    var imp;
                    itr13 = _Iterable(self.imports);
                    for (idx13 = 0; idx13 < itr13.length; idx13++) {
                        imp = itr13[idx13];
                        imp._walk(visitor);
                    }
                });
            }
        }
    }), _27);
    var Decorator = (_28 = function Decorator() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_28, Node), Object.defineProperties(_28.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                expression: "[Node] decorator expression"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                if (self.expression) {
                    self.expression.walk(visitor);
                }
            }
        }
    }), _28);
    var Annotation = (_29 = function Annotation() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_29, Node), Object.defineProperties(_29.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                expression: "[Node] decorator expression"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                if (self.expression) {
                    self.expression.walk(visitor);
                }
            }
        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var self = this;
                function parse(obj) {
                    var _30;
                    if (obj instanceof Array) {
                        if (obj.elements.length === 1) {
                            return "[" + parse(obj.elements[0]) + "]";
                        }
                        return "[?]";
                    }
                    if (obj instanceof ObjectLiteral) {
                        if (obj.properties.length === 1) {
                            return "{String:" + parse(obj.properties[0].value) + "}";
                        }
                        return "{String:?}";
                    }
                    if (obj instanceof SymbolRef) {
                        return obj.name === "Array" ? "[?]" : _in(obj.name, [ "Object", "Dictionary" ]) ? "{String:?}" : obj.name;
                    }
                    if (obj instanceof Call) {
                        if (obj.expression instanceof SymbolRef && obj.expression.name === "Array" && obj.args.length === 1) {
                            return "[" + parse(obj.args[0]) + "]";
                        }
                        if (obj.expression instanceof SymbolRef && _in(obj.expression.name, [ "Object", "Dictionary" ])) {
                            if (1 <= (_30 = obj.args.length) && _30 <= 2) {
                                return "{String:" + parse(obj.args[obj.args.length-1]) + "}";
                            }
                            return "{String:?}";
                        }
                    }
                    return "?";
                }
                return parse(self.expression);
            })
        }
    }), _29);
    var Lambda = (_31 = function Lambda() {
        Scope.prototype.__init__.apply(this, arguments);
    }, _extends(_31, Scope), Object.defineProperties(_31.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                name: "[SymbolDeclaration?] the name of this function/class/method",
                argnames: "[SymbolFunarg*] array of arguments",
                kwargs: "[SymbolFunarg?] kwargs symbol, if any",
                uses_arguments: "[boolean/S] tells whether this function accesses the arguments array",
                decorators: "[Decorator*] function decorators, if any",
                generator: "[boolean] true if this is a generator function (false by default)",
                return_annotation: "[Annotation?] the return type annotation provided (if any)"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    var itr14, idx14, itr15, idx15;
                    var d, arg;
                    if (self.decorators) {
                        itr14 = _Iterable(self.decorators);
                        for (idx14 = 0; idx14 < itr14.length; idx14++) {
                            d = itr14[idx14];
                            d.walk(visitor);
                        }
                    }
                    if (self.name) {
                        self.name._walk(visitor);
                    }
                    itr15 = _Iterable(self.argnames);
                    for (idx15 = 0; idx15 < itr15.length; idx15++) {
                        arg = itr15[idx15];
                        arg._walk(visitor);
                    }
                    if (self.argnames.starargs) {
                        self.argnames.starargs._walk(visitor);
                    }
                    if (self.kwargs) {
                        self.kwargs._walk(visitor);
                    }
                    walk_body(self, visitor);
                });
            }
        }
    }), _31);
    var Accessor = (_32 = function Accessor() {
        Lambda.prototype.__init__.apply(this, arguments);
    }, _extends(_32, Lambda), _32);
    var Function = (_33 = function Function() {
        Lambda.prototype.__init__.apply(this, arguments);
    }, _extends(_33, Lambda), Object.defineProperties(_33.prototype, {
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var itr16, idx16;
                var self = this;
                var annotated, args, arg, computedType, result, signature;
                if (self.argnames.starargs) {
                    return "Function";
                }
                annotated = true;
                args = [];
                itr16 = _Iterable(self.argnames);
                for (idx16 = 0; idx16 < itr16.length; idx16++) {
                    arg = itr16[idx16];
                    if (arg.annotation) {
                        computedType = arg.annotation.resolveType(heap);
                        if (computedType) {
                            args.push(computedType);
                        } else {
                            annotated = false;
                            break;
                        }
                    } else {
                        annotated = false;
                        break;
                    }
                }
                if (self.return_annotation) {
                    result = self.return_annotation.resolveType(heap);
                    if (!result) {
                        annotated = false;
                    }
                }
                signature = "Function";
                if (annotated) {
                    signature += "(" + args.join(",") + ")";
                    if (result) {
                        signature += " -> " + result;
                    }
                }
                return signature;
            })
        }
    }), _33);
    var Class = (_34 = function Class() {
        Scope.prototype.__init__.apply(this, arguments);
    }, _extends(_34, Scope), Object.defineProperties(_34.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                name: "[SymbolDeclaration?] the name of this class",
                init: "[Function] constructor for the class",
                parent: "[Class?] parent class this class inherits from",
                static: "[string*] list of static methods",
                external: "[boolean] true if class is declared elsewhere, but will be within current scope at runtime",
                bound: "[string*] hash of methods that need to be bound to behave correctly (function pointers)",
                decorators: "[Decorator*] function decorators, if any",
                module_id: "[string] The id of the module this class is defined in",
                statements: "[Node*] list of statements in the class scope (excluding method definitions)"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.name._walk(visitor);
                    walk_body(this, visitor);
                    if (self.parent) {
                        self.parent._walk(visitor);
                    }
                });
            }
        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var self = this;
                return self.name.name;
            })
        }
    }), _34);
    var Module = (_35 = function Module() {
        Scope.prototype.__init__.apply(this, arguments);
    }, _extends(_35, Scope), Object.defineProperties(_35.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                name: "[SymbolDeclaration?] the name of this class",
                external: "[boolean] true if module is declared elsewhere, but will be within current scope at runtime",
                decorators: "[Decorator*] module decorators, if any"
            }        }
    }), _35);
    var Method = (_36 = function Method() {
        Lambda.prototype.__init__.apply(this, arguments);
    }, _extends(_36, Lambda), Object.defineProperties(_36.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                static: "[boolean] true if method is static"
            }        }
    }), _36);
    var Constructor = (_37 = function Constructor() {
        Method.prototype.__init__.apply(this, arguments);
    }, _extends(_37, Method), Object.defineProperties(_37.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                callsSuper: "[boolean] true if user manually called super or Parent.__init__",
                parent: "[string?] parent class this class inherits from"
            }        }
    }), _37);
    var Jump = (_38 = function Jump() {
        Statement.prototype.__init__.apply(this, arguments);
    }, _extends(_38, Statement), _38);
    var Exit = (_39 = function Exit() {
        Jump.prototype.__init__.apply(this, arguments);
    }, _extends(_39, Jump), Object.defineProperties(_39.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                value: "[Node?] the value returned or thrown by this statement; could be null for Return"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    if (self.value) {
                        self.value._walk(visitor);
                    }
                });
            }
        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var self = this;
                return self.value.resolveType(heap);
            })
        }
    }), _39);
    var Return = (_40 = function Return() {
        Exit.prototype.__init__.apply(this, arguments);
    }, _extends(_40, Exit), _40);
    var Yield = (_41 = function Yield() {
        Exit.prototype.__init__.apply(this, arguments);
    }, _extends(_41, Exit), _41);
    var Throw = (_42 = function Throw() {
        Exit.prototype.__init__.apply(this, arguments);
    }, _extends(_42, Exit), _42);
    var LoopControl = (_43 = function LoopControl() {
        Jump.prototype.__init__.apply(this, arguments);
    }, _extends(_43, Jump), Object.defineProperties(_43.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                label: "[LabelRef?] the label, or null if none"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    if (self.label) {
                        self.label._walk(visitor);
                    }
                });
            }
        }
    }), _43);
    var Break = (_44 = function Break() {
        LoopControl.prototype.__init__.apply(this, arguments);
    }, _extends(_44, LoopControl), _44);
    var Continue = (_45 = function Continue() {
        LoopControl.prototype.__init__.apply(this, arguments);
    }, _extends(_45, LoopControl), _45);
    var If = (_46 = function If() {
        StatementWithBody.prototype.__init__.apply(this, arguments);
    }, _extends(_46, StatementWithBody), Object.defineProperties(_46.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                condition: "[Node] the `if` condition",
                alternative: "[Statement?] the `else` part, or null if not present"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.condition._walk(visitor);
                    self.body._walk(visitor);
                    if (self.alternative) {
                        self.alternative._walk(visitor);
                    }
                });
            }
        }
    }), _46);
    var Switch = (_47 = function Switch() {
        Block.prototype.__init__.apply(this, arguments);
    }, _extends(_47, Block), Object.defineProperties(_47.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                expression: "[Node] the `switch` discriminant"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.expression._walk(visitor);
                    walk_body(self, visitor);
                });
            }
        }
    }), _47);
    var SwitchBranch = (_48 = function SwitchBranch() {
        Block.prototype.__init__.apply(this, arguments);
    }, _extends(_48, Block), _48);
    var Default = (_49 = function Default() {
        SwitchBranch.prototype.__init__.apply(this, arguments);
    }, _extends(_49, SwitchBranch), _49);
    var Case = (_50 = function Case() {
        SwitchBranch.prototype.__init__.apply(this, arguments);
    }, _extends(_50, SwitchBranch), Object.defineProperties(_50.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                expression: "[Node] the `case` expression"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.expression._walk(visitor);
                    walk_body(self, visitor);
                });
            }
        }
    }), _50);
    var Try = (_51 = function Try() {
        Block.prototype.__init__.apply(this, arguments);
    }, _extends(_51, Block), Object.defineProperties(_51.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                bcatch: "[Catch?] the catch block, or null if not present",
                bfinally: "[Finally?] the finally block, or null if not present"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    walk_body(self, visitor);
                    if (self.bcatch) {
                        self.bcatch._walk(visitor);
                    }
                    if (self.bfinally) {
                        self.bfinally._walk(visitor);
                    }
                });
            }
        }
    }), _51);
    var Catch = (_52 = function Catch() {
        Block.prototype.__init__.apply(this, arguments);
    }, _extends(_52, Block), _52);
    var Except = (_53 = function Except() {
        Block.prototype.__init__.apply(this, arguments);
    }, _extends(_53, Block), Object.defineProperties(_53.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                argname: "[SymbolCatch] symbol for the exception",
                errors: "[SymbolVar*] error classes to catch in this block"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    var itr17, idx17;
                    var e;
                    if (self.argname) {
                        self.argname.walk(visitor);
                    }
                    if (self.errors) {
                        itr17 = _Iterable(self.errors);
                        for (idx17 = 0; idx17 < itr17.length; idx17++) {
                            e = itr17[idx17];
                            e.walk(visitor);
                        }
                    }
                    walk_body(self, visitor);
                });
            }
        }
    }), _53);
    var Finally = (_54 = function Finally() {
        Block.prototype.__init__.apply(this, arguments);
    }, _extends(_54, Block), _54);
    var Definitions = (_55 = function Definitions() {
        Statement.prototype.__init__.apply(this, arguments);
    }, _extends(_55, Statement), Object.defineProperties(_55.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                definitions: "[VarDef*] array of variable definitions"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    var itr18, idx18;
                    var def_;
                    itr18 = _Iterable(self.definitions);
                    for (idx18 = 0; idx18 < itr18.length; idx18++) {
                        def_ = itr18[idx18];
                        def_._walk(visitor);
                    }
                });
            }
        }
    }), _55);
    var Var = (_56 = function Var() {
        Definitions.prototype.__init__.apply(this, arguments);
    }, _extends(_56, Definitions), _56);
    var Const = (_57 = function Const() {
        Definitions.prototype.__init__.apply(this, arguments);
    }, _extends(_57, Definitions), _57);
    var VarDef = (_58 = function VarDef() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_58, Node), Object.defineProperties(_58.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                name: "[SymbolVar|SymbolConst] name of the variable",
                value: "[Node?] initializer, or null if there's no initializer"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.name._walk(visitor);
                    if (self.value) {
                        self.value._walk(visitor);
                    }
                });
            }
        }
    }), _58);
    var BaseCall = (_59 = function BaseCall() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_59, Node), Object.defineProperties(_59.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                args: "[Node*] array of arguments"
            }        }
    }), _59);
    var Call = (_60 = function Call() {
        BaseCall.prototype.__init__.apply(this, arguments);
    }, _extends(_60, BaseCall), Object.defineProperties(_60.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                expression: "[Node] expression to invoke as function"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    var itr19, idx19, itr20, idx20, itr21, idx21;
                    var arg;
                    self.expression._walk(visitor);
                    itr19 = _Iterable(self.args);
                    for (idx19 = 0; idx19 < itr19.length; idx19++) {
                        arg = itr19[idx19];
                        arg._walk(visitor);
                    }
                    if (self.args.kwargs) {
                        itr20 = _Iterable(self.args.kwargs);
                        for (idx20 = 0; idx20 < itr20.length; idx20++) {
                            arg = itr20[idx20];
                            arg[0]._walk(visitor);
                            arg[1]._walk(visitor);
                        }
                    }
                    if (self.args.kwarg_items) {
                        itr21 = _Iterable(self.args.kwarg_items);
                        for (idx21 = 0; idx21 < itr21.length; idx21++) {
                            arg = itr21[idx21];
                            arg._walk(visitor);
                        }
                    }
                });
            }
        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var itr22, idx22;
                var self = this;
                var scope, parse, result;
                if (self.expression instanceof SymbolRef) {
                    itr22 = _Iterable(reversed(heap));
                    for (idx22 = 0; idx22 < itr22.length; idx22++) {
                        scope = itr22[idx22];
                        if (_in(self.expression.name, scope.vars) && _in("->", scope.vars[self.expression.name][scope.vars[self.expression.name].length-1])) {
                            return scope.vars[self.expression.name][scope.vars[self.expression.name].length-1].split("->")[1].trim();
                        } else if (_in(self.expression.name, scope.functions) && _in("->", scope.functions[self.expression.name])) {
                            return scope.functions[self.expression.name].split("->")[1].trim();
                        } else if (scope.type === "function" && self.expression.name === scope.name && scope.return) {
                            parse = function(variable) {
                                var _61;
                                var wrap, wrapper, element, result;
                                wrap = {
                                    "array": function(value) {
                                        return "[" + value + "]";
                                    },
                                    "dict": function(value) {
                                        return "{String:" + value + "}";
                                    },
                                    "base": function(value) {
                                        return value;
                                    }
                                };
                                wrapper = "base";
                                if (variable instanceof Array) {
                                    if (variable.elements.length !== 1) {
                                        return;
                                    }
                                    wrapper = "array";
                                    element = variable.elements[0];
                                } else if (variable instanceof Call && variable.expression instanceof SymbolRef && variable.expression.name === "Array") {
                                    if (variable.args.length !== 1) {
                                        return;
                                    }
                                    wrapper = "array";
                                    element = variable.args[0];
                                } else if (variable instanceof ObjectLiteral) {
                                    if (variable.properties.length !== 1) {
                                        return;
                                    }
                                    wrapper = "dict";
                                    element = variable.properties[0].value;
                                } else if (variable instanceof Call && variable.expression instanceof SymbolRef && _in(variable.expression.name, [ "Object", "Dictionary" ])) {
                                    if (1 <= (_61 = variable.args.length) && _61 <= 2) {
                                        element = variable.args[variable.args.length-1];
                                        wrapper = "dict";
                                    } else {
                                        return;
                                    }
                                } else {
                                    element = variable;
                                }
                                if (element instanceof SymbolRef && _in(element.name, NATIVE_CLASSES)) {
                                    return wrap[wrapper](element.name);
                                } else if (element instanceof Array || element instanceof ObjectLiteral || element instanceof Call) {
                                    result = parse(element);
                                    if (result) {
                                        return wrap[wrapper](result);
                                    }
                                }
                            };
                            result = parse(scope.return_annotation);
                            if (result) {
                                return result;
                            }
                        }
                    }
                }
                return "?";
            })
        }
    }), _60);
    var ClassCall = (_62 = function ClassCall() {
        BaseCall.prototype.__init__.apply(this, arguments);
    }, _extends(_62, BaseCall), Object.defineProperties(_62.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                class: "[string] name of the class method belongs to",
                super: "[boolean] this call can be replaced with a super() call",
                method: "[string] class method being called",
                static: "[boolean] defines whether the method is static"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    var itr23, idx23, itr24, idx24, itr25, idx25;
                    var arg;
                    if (self.expression) {
                        self.expression._walk(visitor);
                    }
                    itr23 = _Iterable(self.args);
                    for (idx23 = 0; idx23 < itr23.length; idx23++) {
                        arg = itr23[idx23];
                        arg._walk(visitor);
                    }
                    itr24 = _Iterable(self.args.kwargs);
                    for (idx24 = 0; idx24 < itr24.length; idx24++) {
                        arg = itr24[idx24];
                        arg[0]._walk(visitor);
                        arg[1]._walk(visitor);
                    }
                    itr25 = _Iterable(self.args.kwarg_items);
                    for (idx25 = 0; idx25 < itr25.length; idx25++) {
                        arg = itr25[idx25];
                        arg._walk(visitor);
                    }
                });
            }
        }
    }), _62);
    var New = (_63 = function New() {
        Call.prototype.__init__.apply(this, arguments);
    }, _extends(_63, Call), _63);
    var Seq = (_64 = function Seq() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_64, Node), Object.defineProperties(_64.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                car: "[Node] first element in sequence",
                cdr: "[Node] second element in sequence"
            }        },
        cons: {
            enumerable: true, 
            writable: true, 
            value: function cons(x, y){
                var self = this;
                var seq;
                seq = new Seq(x);
                seq.car = x;
                seq.cdr = y;
                return seq;
            }
        },
        from_array: {
            enumerable: true, 
            writable: true, 
            value: function from_array(array){
                var itr26, idx26;
                var self = this;
                var list, i, p;
                if (array.length === 0) {
                    return null;
                }
                if (array.length === 1) {
                    return array[0].clone();
                }
                list = null;
                itr26 = _Iterable(range(array.length - 1, -1, -1));
                for (idx26 = 0; idx26 < itr26.length; idx26++) {
                    i = itr26[idx26];
                    list = Seq.prototype.cons.call(array[i], list);
                }
                p = list;
                while (p) {
                    if (p.cdr && !p.cdr.cdr) {
                        p.cdr = p.cdr.car;
                        break;
                    }
                    p = p.cdr;
                }
                return list;
            }
        },
        to_array: {
            enumerable: true, 
            writable: true, 
            value: function to_array(){
                var self = this;
                var p, a;
                p = this;
                a = [];
                while (p) {
                    a.push(p.car);
                    if (p.cdr && !(p.cdr instanceof Seq)) {
                        a.push(p.cdr);
                        break;
                    }
                    p = p.cdr;
                }
                return a;
            }
        },
        add: {
            enumerable: true, 
            writable: true, 
            value: function add(node){
                var self = this;
                var p, cell;
                p = this;
                while (p) {
                    if (!(p.cdr instanceof Seq)) {
                        cell = Seq.prototype.cons.call(p.cdr, node);
                        return p.cdr = cell;
                    }
                    p = p.cdr;
                }
            }
        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.car._walk(visitor);
                    if (self.cdr) {
                        self.cdr._walk(visitor);
                    }
                });
            }
        }
    }), _64);
    var PropAccess = (_65 = function PropAccess() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_65, Node), Object.defineProperties(_65.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                expression: "[Node] the container expression",
                property: "[Node|string] the property to access. For Dot this is always a plain string, while for Sub it's an arbitrary Node"
            }        }
    }), _65);
    var Dot = (_66 = function Dot() {
        PropAccess.prototype.__init__.apply(this, arguments);
    }, _extends(_66, PropAccess), Object.defineProperties(_66.prototype, {
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.expression._walk(visitor);
                });
            }
        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var self = this;
                var containerType;
                containerType = self.expression.resolveType(heap);
                if (containerType && containerType[0] === "{") {
                    return /\{\w+:(.*)\}/.exec(containerType)[1];
                }
                return "?";
            })
        }
    }), _66);
    var Sub = (_67 = function Sub() {
        PropAccess.prototype.__init__.apply(this, arguments);
    }, _extends(_67, PropAccess), Object.defineProperties(_67.prototype, {
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.expression._walk(visitor);
                    self.property._walk(visitor);
                });
            }
        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var self = this;
                var containerType;
                containerType = self.expression.resolveType(heap);
                if (containerType) {
                    if (containerType[0] === "[" && self.property instanceof Number) {
                        return /\[(.*)\]/.exec(containerType)[1];
                    }
                    if (containerType[0] === "{") {
                        return /\{\w+:(.*)\}/.exec(containerType)[1];
                    }
                }
                return "?";
            })
        }
    }), _67);
    var Slice = (_68 = function Slice() {
        PropAccess.prototype.__init__.apply(this, arguments);
    }, _extends(_68, PropAccess), Object.defineProperties(_68.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                property2: "[Node] the 2nd property to access - typically ending index for the array.",
                assignment: "[Node] The data being spliced in."
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.expression._walk(visitor);
                    self.property._walk(visitor);
                    self.property2._walk(visitor);
                });
            }
        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var self = this;
                return self.expression.resolveType(heap);
            })
        }
    }), _68);
    var Unary = (_69 = function Unary() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_69, Node), Object.defineProperties(_69.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                operator: "[string] the operator",
                expression: "[Node] expression that this unary operator applies to"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.expression._walk(visitor);
                });
            }
        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var self = this;
                if (self.operator === "!") {
                    return "Boolean";
                }
                if (_in(self.operator, [ "-", "+" ]) && self.expression.resolveType(heap) === "Number") {
                    return "Number";
                }
                return "?";
            })
        }
    }), _69);
    var UnaryPrefix = (_70 = function UnaryPrefix() {
        Unary.prototype.__init__.apply(this, arguments);
    }, _extends(_70, Unary), _70);
    var UnaryPostfix = (_71 = function UnaryPostfix() {
        Unary.prototype.__init__.apply(this, arguments);
    }, _extends(_71, Unary), _71);
    var Binary = (_72 = function Binary() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_72, Node), Object.defineProperties(_72.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                left: "[Node] left-hand side expression",
                operator: "[string] the operator",
                right: "[Node] right-hand side expression"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.left._walk(visitor);
                    self.right._walk(visitor);
                });
            }
        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var self = this;
                var left, right;
                if (!(self.left && self.right)) {
                    return "?";
                }
                left = self.left.resolveType(heap);
                right = self.left.resolveType(heap);
                if (left === "Number" && right === "Number") {
                    return "Number";
                }
                if (left === "Boolean" && right === "Boolean" || _in(self.operator, [ "===", "!==", ">", ">=", "<", "<=" ])) {
                    return "Boolean";
                }
                if (left === "String" && self.operator === "+") {
                    return "String";
                }
                return "?";
            })
        }
    }), _72);
    var Range = (_73 = function Range() {
        Binary.prototype.__init__.apply(this, arguments);
    }, _extends(_73, Binary), Object.defineProperties(_73.prototype, {
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var self = this;
                return "[Number]";
            })
        }
    }), _73);
    var DeepEquality = (_74 = function DeepEquality() {
        Binary.prototype.__init__.apply(this, arguments);
    }, _extends(_74, Binary), Object.defineProperties(_74.prototype, {
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var self = this;
                return "Boolean";
            })
        }
    }), _74);
    var Conditional = (_75 = function Conditional() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_75, Node), Object.defineProperties(_75.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                condition: "[Node] test to run before deciding the return value",
                consequent: "[Node] return expression in the event on truthy test evaluation",
                alternative: "[Node] return expression in the event of falsy test evaluation"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.condition._walk(visitor);
                    self.consequent._walk(visitor);
                    self.alternative._walk(visitor);
                });
            }
        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var self = this;
                var computedType;
                computedType = self.consequent.resolveType(heap);
                return computedType === self.alternative.resolveType(heap) ? computedType : "?";
            })
        }
    }), _75);
    var Assign = (_76 = function Assign() {
        Binary.prototype.__init__.apply(this, arguments);
    }, _extends(_76, Binary), Object.defineProperties(_76.prototype, {
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var self = this;
                if (self.operator === "=") {
                    return self.right.resolveType(heap);
                }
                return "?";
            })
        }
    }), _76);
    var Array = (_77 = function Array() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_77, Node), Object.defineProperties(_77.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                elements: "[Node*] array of elements"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    var itr27, idx27;
                    var el;
                    itr27 = _Iterable(self.elements);
                    for (idx27 = 0; idx27 < itr27.length; idx27++) {
                        el = itr27[idx27];
                        el._walk(visitor);
                    }
                });
            }
        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var itr28, idx28;
                var self = this;
                var expected, element, current;
                if (!self.elements.length) {
                    return "[?]";
                }
                expected = self.elements[0].resolveType(heap);
                itr28 = _Iterable(self.elements.slice(1));
                for (idx28 = 0; idx28 < itr28.length; idx28++) {
                    element = itr28[idx28];
                    current = element.resolveType(heap);
                    if (current !== expected) {
                        if (expected.indexOf("Function") === 0 && current.indexOf("Function") === 0) {
                            return "[Function]";
                        }
                        return "[?]";
                    }
                }
                return "[" + expected + "]";
            })
        }
    }), _77);
    var TupleUnpack = (_78 = function TupleUnpack() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_78, Node), Object.defineProperties(_78.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                elements: "[Node*] array of elements being assigned to",
                right: "[Node] right-hand side expression"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    var itr29, idx29;
                    var el;
                    itr29 = _Iterable(self.elements);
                    for (idx29 = 0; idx29 < itr29.length; idx29++) {
                        el = itr29[idx29];
                        el._walk(visitor);
                    }
                    self.right._walk(visitor);
                });
            }
        }
    }), _78);
    var ObjectLiteral = (_79 = function ObjectLiteral() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_79, Node), Object.defineProperties(_79.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                properties: "[ObjectProperty*] array of properties"
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    var itr30, idx30;
                    var prop;
                    itr30 = _Iterable(self.properties);
                    for (idx30 = 0; idx30 < itr30.length; idx30++) {
                        prop = itr30[idx30];
                        prop._walk(visitor);
                    }
                });
            }
        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var itr31, idx31;
                var self = this;
                var start, spread, expected, element, current, result;
                if (!self.properties.length) {
                    return "{String:?}";
                }
                start = 0;
                spread = null;
                while (self.properties[start] instanceof UnaryPrefix) {
                    spread = self.properties[start].expression.resolveType(heap);
                    if (_in("?", spread)) {
                        return "{String:?}";
                    }
                    ++start;
                }
                expected = self.properties[start].value.resolveType(heap);
                itr31 = _Iterable(self.properties.slice(start + 1));
                for (idx31 = 0; idx31 < itr31.length; idx31++) {
                    element = itr31[idx31];
                    if (element instanceof UnaryPrefix) {
                        if (spread) {
                            if (spread !== element.expression.resolveType(heap)) {
                                return "{String:?}";
                            }
                        } else {
                            spread = element.expression.resolveType(heap);
                        }
                    } else if (element instanceof Accessor) {
                    } else {
                        current = element.value.resolveType(heap);
                        if (current !== expected) {
                            if (expected.indexOf("Function") === 0 && current.indexOf("Function") === 0) {
                                return "{String:Function}";
                            }
                            return "{String:?}";
                        }
                    }
                }
                result = "{String:" + expected + "}";
                if (spread) {
                    if (spread === result) {
                        return result;
                    } else {
                        return "{String:?}";
                    }
                }
                return result;
            })
        }
    }), _79);
    var ObjectProperty = (_80 = function ObjectProperty() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_80, Node), Object.defineProperties(_80.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                key: "[Node] the property name or expression for computed key ",
                value: "[Node] property value. For setters and getters this is an Function."
            }        },
        _walk: {
            enumerable: true, 
            writable: true, 
            value: function _walk(visitor){
                var self = this;
                return visitor._visit(self, function() {
                    self.key._walk(visitor);
                    self.value._walk(visitor);
                });
            }
        }
    }), _80);
    var ObjectKeyVal = (_81 = function ObjectKeyVal() {
        ObjectProperty.prototype.__init__.apply(this, arguments);
    }, _extends(_81, ObjectProperty), _81);
    var ObjectSetter = (_82 = function ObjectSetter() {
        Accessor.prototype.__init__.apply(this, arguments);
    }, _extends(_82, Accessor), _82);
    var ObjectGetter = (_83 = function ObjectGetter() {
        Accessor.prototype.__init__.apply(this, arguments);
    }, _extends(_83, Accessor), _83);
    var Symbol = (_84 = function Symbol() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_84, Node), Object.defineProperties(_84.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                name: "[string] name of this symbol",
                scope: "[Scope/S] the current scope (not necessarily the definition scope)",
                thedef: "[SymbolDef/S] the definition of this symbol"
            }        }
    }), _84);
    var SymbolAlias = (_85 = function SymbolAlias() {
        Symbol.prototype.__init__.apply(this, arguments);
    }, _extends(_85, Symbol), _85);
    var SymbolAccessor = (_86 = function SymbolAccessor() {
        Symbol.prototype.__init__.apply(this, arguments);
    }, _extends(_86, Symbol), _86);
    var SymbolDeclaration = (_87 = function SymbolDeclaration() {
        Symbol.prototype.__init__.apply(this, arguments);
    }, _extends(_87, Symbol), Object.defineProperties(_87.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                init: "[Node*/S] array of initializers for this declaration."
            }        }
    }), _87);
    var SymbolVar = (_88 = function SymbolVar() {
        SymbolDeclaration.prototype.__init__.apply(this, arguments);
    }, _extends(_88, SymbolDeclaration), _88);
    var SymbolNonlocal = (_89 = function SymbolNonlocal() {
        SymbolDeclaration.prototype.__init__.apply(this, arguments);
    }, _extends(_89, SymbolDeclaration), _89);
    var ImportedVar = (_90 = function ImportedVar() {
        SymbolVar.prototype.__init__.apply(this, arguments);
    }, _extends(_90, SymbolVar), Object.defineProperties(_90.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                alias: "SymbolAlias the alias for this imported symbol"
            }        }
    }), _90);
    var SymbolConst = (_91 = function SymbolConst() {
        SymbolDeclaration.prototype.__init__.apply(this, arguments);
    }, _extends(_91, SymbolDeclaration), _91);
    var SymbolFunarg = (_92 = function SymbolFunarg() {
        SymbolVar.prototype.__init__.apply(this, arguments);
    }, _extends(_92, SymbolVar), Object.defineProperties(_92.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                annotation: "[Annotation?] annotation provided for this argument, if any"
            }        }
    }), _92);
    var SymbolDefun = (_93 = function SymbolDefun() {
        SymbolDeclaration.prototype.__init__.apply(this, arguments);
    }, _extends(_93, SymbolDeclaration), _93);
    var SymbolLambda = (_94 = function SymbolLambda() {
        SymbolDeclaration.prototype.__init__.apply(this, arguments);
    }, _extends(_94, SymbolDeclaration), _94);
    var SymbolCatch = (_95 = function SymbolCatch() {
        SymbolDeclaration.prototype.__init__.apply(this, arguments);
    }, _extends(_95, SymbolDeclaration), _95);
    var Label = (_96 = function Label() {
        Symbol.prototype.__init__.apply(this, arguments);
    }, _extends(_96, Symbol), Object.defineProperties(_96.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                references: "[LabelRef*] a list of nodes referring to this label"
            }        }
    }), _96);
    var SymbolRef = (_97 = function SymbolRef() {
        Symbol.prototype.__init__.apply(this, arguments);
    }, _extends(_97, Symbol), Object.defineProperties(_97.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                parens: "[boolean/S] if true, this variable is wrapped in parentheses"
            }        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(heap){
                var itr32, idx32;
                var self = this;
                var scope;
                itr32 = _Iterable(reversed(heap));
                for (idx32 = 0; idx32 < itr32.length; idx32++) {
                    scope = itr32[idx32];
                    if (_in(self.name, scope.vars)) {
                        return scope.vars[self.name][scope.vars[self.name].length-1];
                    }
                    if (scope.args && _in(self.name, scope.args)) {
                        return scope.args[self.name];
                    }
                }
                return "?";
            })
        }
    }), _97);
    var SymbolClassRef = (_98 = function SymbolClassRef() {
        Symbol.prototype.__init__.apply(this, arguments);
    }, _extends(_98, Symbol), Object.defineProperties(_98.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                class: "[SymbolDeclaration?] the name of this class"
            }        }
    }), _98);
    var LabelRef = (_99 = function LabelRef() {
        Symbol.prototype.__init__.apply(this, arguments);
    }, _extends(_99, Symbol), _99);
    var This = (_100 = function This() {
        Symbol.prototype.__init__.apply(this, arguments);
    }, _extends(_100, Symbol), _100);
    var Constant = (_101 = function Constant() {
        Node.prototype.__init__.apply(this, arguments);
    }, _extends(_101, Node), Object.defineProperties(_101.prototype, {
        getValue: {
            enumerable: true, 
            writable: true, 
            value: function getValue(){
                var self = this;
                return this.value;
            }
        }
    }), _101);
    var String = (_102 = function String() {
        Constant.prototype.__init__.apply(this, arguments);
    }, _extends(_102, Constant), Object.defineProperties(_102.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                value: "[string] the contents of this string",
                modifier: "[string] string type modifier"
            }        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(){
                var self = this;
                return "String";
            })
        }
    }), _102);
    var Verbatim = (_103 = function Verbatim() {
        Constant.prototype.__init__.apply(this, arguments);
    }, _extends(_103, Constant), Object.defineProperties(_103.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                value: "[string] A string of raw JS code"
            }        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(){
                var self = this;
                return "?";
            })
        }
    }), _103);
    var Number = (_104 = function Number() {
        Constant.prototype.__init__.apply(this, arguments);
    }, _extends(_104, Constant), Object.defineProperties(_104.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                value: "[number] the numeric value"
            }        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(){
                var self = this;
                return "Number";
            })
        }
    }), _104);
    var Identifier = (_105 = function Identifier() {
        Constant.prototype.__init__.apply(this, arguments);
    }, _extends(_105, Constant), Object.defineProperties(_105.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                value: "[string] the name of this key"
            }        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(){
                var self = this;
                return "String";
            })
        }
    }), _105);
    var RegExp = (_106 = function RegExp() {
        Constant.prototype.__init__.apply(this, arguments);
    }, _extends(_106, Constant), Object.defineProperties(_106.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                value: "[RegExp] the actual regexp"
            }        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(){
                var self = this;
                return "RegExp";
            })
        }
    }), _106);
    var Atom = (_107 = function Atom() {
        Constant.prototype.__init__.apply(this, arguments);
    }, _extends(_107, Constant), _107);
    var Null = (_108 = function Null() {
        Atom.prototype.__init__.apply(this, arguments);
    }, _extends(_108, Atom), Object.defineProperties(_108.prototype, {
        value: {
            enumerable: true, 
            writable: true, 
            value: null        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(){
                var self = this;
                return null;
            })
        }
    }), _108);
    var NotANumber = (_109 = function NotANumber() {
        Atom.prototype.__init__.apply(this, arguments);
    }, _extends(_109, Atom), Object.defineProperties(_109.prototype, {
        value: {
            enumerable: true, 
            writable: true, 
            value: 0 / 0        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(){
                var self = this;
                return null;
            })
        }
    }), _109);
    var Undefined = (_110 = function Undefined() {
        Atom.prototype.__init__.apply(this, arguments);
    }, _extends(_110, Atom), Object.defineProperties(_110.prototype, {
        value: {
            enumerable: true, 
            writable: true, 
            value: void 0        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(){
                var self = this;
                return null;
            })
        }
    }), _110);
    var Hole = (_111 = function Hole() {
        Atom.prototype.__init__.apply(this, arguments);
    }, _extends(_111, Atom), Object.defineProperties(_111.prototype, {
        value: {
            enumerable: true, 
            writable: true, 
            value: void 0        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(){
                var self = this;
                return null;
            })
        }
    }), _111);
    var Infinity = (_112 = function Infinity() {
        Atom.prototype.__init__.apply(this, arguments);
    }, _extends(_112, Atom), Object.defineProperties(_112.prototype, {
        value: {
            enumerable: true, 
            writable: true, 
            value: 1 / 0        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(){
                var self = this;
                return "Number";
            })
        }
    }), _112);
    var Boolean = (_113 = function Boolean() {
        Atom.prototype.__init__.apply(this, arguments);
    }, _extends(_113, Atom), Object.defineProperties(_113.prototype, {
        properties: {
            enumerable: true, 
            writable: true, 
            value: {
                value: "[boolean] value"
            }        },
        resolveType: {
            enumerable: true, 
            writable: true, 
            value: memoized(function resolveType(){
                var self = this;
                return "Boolean";
            })
        }
    }), _113);
    var TreeWalker = (_114 = function TreeWalker() {
        TreeWalker.prototype.__init__.apply(this, arguments);
    }, Object.defineProperties(_114.prototype, {
        __init__: {
            enumerable: true, 
            writable: true, 
            value: function __init__(callback){
                var self = this;
                self.visit = callback;
                self.stack = [];
            }
        },
        _visit: {
            enumerable: true, 
            writable: true, 
            value: function _visit(node, descend){
                var self = this;
                var ret;
                self.stack.push(node);
                ret = self.visit(node, descend ? function() {
                    descend.call(node);
                } : noop);
                if (!ret && descend) {
                    descend.call(node);
                }
                self.stack.pop();
                return ret;
            }
        },
        parent: {
            enumerable: true, 
            writable: true, 
            value: function parent(n){
                var self = this;
                return self.stack[self.stack.length - 2 - (n || 0)];
            }
        },
        push: {
            enumerable: true, 
            writable: true, 
            value: function push(node){
                var self = this;
                self.stack.push(node);
            }
        },
        pop: {
            enumerable: true, 
            writable: true, 
            value: function pop(){
                var self = this;
                return self.stack.pop();
            }
        },
        self: {
            enumerable: true, 
            writable: true, 
            value: function self(){
                var self = this;
                return self.stack[self.stack.length - 1];
            }
        },
        find_parent: {
            enumerable: true, 
            writable: true, 
            value: function find_parent(type){
                var itr33, idx33;
                var self = this;
                var stack, i, x;
                stack = self.stack;
                itr33 = _Iterable(range(stack.length - 1, -1, -1));
                for (idx33 = 0; idx33 < itr33.length; idx33++) {
                    i = itr33[idx33];
                    x = stack[i];
                    if (x instanceof type) {
                        return x;
                    }
                }
            }
        },
        in_boolean_context: {
            enumerable: true, 
            writable: true, 
            value: function in_boolean_context(){
                var self = this;
                var stack, i, self, p;
                stack = self.stack;
                i = stack.length;
                self = stack[--i];
                while (i > 0) {
                    p = stack[--i];
                    if (p instanceof If && p.condition === self || p instanceof Conditional && p.condition === self || p instanceof DWLoop && p.condition === self || p instanceof UnaryPrefix && p.operator === "!" && p.expression === self) {
                        return true;
                    }
                    if (!(p instanceof Binary && (p.operator === "&&" || p.operator === "||"))) {
                        return false;
                    }
                    self = p;
                }
            }
        },
        loopcontrol_target: {
            enumerable: true, 
            writable: true, 
            value: function loopcontrol_target(label){
                var itr34, idx34, itr35, idx35;
                var self = this;
                var stack, i, x;
                stack = self.stack;
                if (label) {
                    itr34 = _Iterable(range(stack.length - 1, -1, -1));
                    for (idx34 = 0; idx34 < itr34.length; idx34++) {
                        i = itr34[idx34];
                        x = stack[i];
                        if (x instanceof LabeledStatement && x.label.name === label.name) {
                            return x.body;
                        }
                    }
                } else {
                    itr35 = _Iterable(range(stack.length - 1, -1, -1));
                    for (idx35 = 0; idx35 < itr35.length; idx35++) {
                        i = itr35[idx35];
                        x = stack[i];
                        if (x instanceof Switch || x instanceof ForIn || x instanceof DWLoop) {
                            return x;
                        }
                    }
                }
            }
        }
    }), _114);
    _modules["ast"]["memoized"] = memoized;

    _modules["ast"]["AST"] = AST;

    _modules["ast"]["Token"] = Token;

    _modules["ast"]["Node"] = Node;

    _modules["ast"]["Statement"] = Statement;

    _modules["ast"]["Debugger"] = Debugger;

    _modules["ast"]["Directive"] = Directive;

    _modules["ast"]["SimpleStatement"] = SimpleStatement;

    _modules["ast"]["walk_body"] = walk_body;

    _modules["ast"]["Block"] = Block;

    _modules["ast"]["BlockStatement"] = BlockStatement;

    _modules["ast"]["EmptyStatement"] = EmptyStatement;

    _modules["ast"]["StatementWithBody"] = StatementWithBody;

    _modules["ast"]["LabeledStatement"] = LabeledStatement;

    _modules["ast"]["DWLoop"] = DWLoop;

    _modules["ast"]["Do"] = Do;

    _modules["ast"]["While"] = While;

    _modules["ast"]["ForIn"] = ForIn;

    _modules["ast"]["ForJS"] = ForJS;

    _modules["ast"]["ListComprehension"] = ListComprehension;

    _modules["ast"]["DictComprehension"] = DictComprehension;

    _modules["ast"]["With"] = With;

    _modules["ast"]["Scope"] = Scope;

    _modules["ast"]["TopLevel"] = TopLevel;

    _modules["ast"]["Splat"] = Splat;

    _modules["ast"]["Import"] = Import;

    _modules["ast"]["Imports"] = Imports;

    _modules["ast"]["Decorator"] = Decorator;

    _modules["ast"]["Annotation"] = Annotation;

    _modules["ast"]["Lambda"] = Lambda;

    _modules["ast"]["Accessor"] = Accessor;

    _modules["ast"]["Function"] = Function;

    _modules["ast"]["Class"] = Class;

    _modules["ast"]["Module"] = Module;

    _modules["ast"]["Method"] = Method;

    _modules["ast"]["Constructor"] = Constructor;

    _modules["ast"]["Jump"] = Jump;

    _modules["ast"]["Exit"] = Exit;

    _modules["ast"]["Return"] = Return;

    _modules["ast"]["Yield"] = Yield;

    _modules["ast"]["Throw"] = Throw;

    _modules["ast"]["LoopControl"] = LoopControl;

    _modules["ast"]["Break"] = Break;

    _modules["ast"]["Continue"] = Continue;

    _modules["ast"]["If"] = If;

    _modules["ast"]["Switch"] = Switch;

    _modules["ast"]["SwitchBranch"] = SwitchBranch;

    _modules["ast"]["Default"] = Default;

    _modules["ast"]["Case"] = Case;

    _modules["ast"]["Try"] = Try;

    _modules["ast"]["Catch"] = Catch;

    _modules["ast"]["Except"] = Except;

    _modules["ast"]["Finally"] = Finally;

    _modules["ast"]["Definitions"] = Definitions;

    _modules["ast"]["Var"] = Var;

    _modules["ast"]["Const"] = Const;

    _modules["ast"]["VarDef"] = VarDef;

    _modules["ast"]["BaseCall"] = BaseCall;

    _modules["ast"]["Call"] = Call;

    _modules["ast"]["ClassCall"] = ClassCall;

    _modules["ast"]["New"] = New;

    _modules["ast"]["Seq"] = Seq;

    _modules["ast"]["PropAccess"] = PropAccess;

    _modules["ast"]["Dot"] = Dot;

    _modules["ast"]["Sub"] = Sub;

    _modules["ast"]["Slice"] = Slice;

    _modules["ast"]["Unary"] = Unary;

    _modules["ast"]["UnaryPrefix"] = UnaryPrefix;

    _modules["ast"]["UnaryPostfix"] = UnaryPostfix;

    _modules["ast"]["Binary"] = Binary;

    _modules["ast"]["Range"] = Range;

    _modules["ast"]["DeepEquality"] = DeepEquality;

    _modules["ast"]["Conditional"] = Conditional;

    _modules["ast"]["Assign"] = Assign;

    _modules["ast"]["Array"] = Array;

    _modules["ast"]["TupleUnpack"] = TupleUnpack;

    _modules["ast"]["ObjectLiteral"] = ObjectLiteral;

    _modules["ast"]["ObjectProperty"] = ObjectProperty;

    _modules["ast"]["ObjectKeyVal"] = ObjectKeyVal;

    _modules["ast"]["ObjectSetter"] = ObjectSetter;

    _modules["ast"]["ObjectGetter"] = ObjectGetter;

    _modules["ast"]["Symbol"] = Symbol;

    _modules["ast"]["SymbolAlias"] = SymbolAlias;

    _modules["ast"]["SymbolAccessor"] = SymbolAccessor;

    _modules["ast"]["SymbolDeclaration"] = SymbolDeclaration;

    _modules["ast"]["SymbolVar"] = SymbolVar;

    _modules["ast"]["SymbolNonlocal"] = SymbolNonlocal;

    _modules["ast"]["ImportedVar"] = ImportedVar;

    _modules["ast"]["SymbolConst"] = SymbolConst;

    _modules["ast"]["SymbolFunarg"] = SymbolFunarg;

    _modules["ast"]["SymbolDefun"] = SymbolDefun;

    _modules["ast"]["SymbolLambda"] = SymbolLambda;

    _modules["ast"]["SymbolCatch"] = SymbolCatch;

    _modules["ast"]["Label"] = Label;

    _modules["ast"]["SymbolRef"] = SymbolRef;

    _modules["ast"]["SymbolClassRef"] = SymbolClassRef;

    _modules["ast"]["LabelRef"] = LabelRef;

    _modules["ast"]["This"] = This;

    _modules["ast"]["Constant"] = Constant;

    _modules["ast"]["String"] = String;

    _modules["ast"]["Verbatim"] = Verbatim;

    _modules["ast"]["Number"] = Number;

    _modules["ast"]["Identifier"] = Identifier;

    _modules["ast"]["RegExp"] = RegExp;

    _modules["ast"]["Atom"] = Atom;

    _modules["ast"]["Null"] = Null;

    _modules["ast"]["NotANumber"] = NotANumber;

    _modules["ast"]["Undefined"] = Undefined;

    _modules["ast"]["Hole"] = Hole;

    _modules["ast"]["Infinity"] = Infinity;

    _modules["ast"]["Boolean"] = Boolean;

    _modules["ast"]["TreeWalker"] = TreeWalker;
})();

(function(){
    var __name__ = "tokenizer";
    var ES6_KEYWORDS, KEYWORDS, JS_KEYWORDS, KEYWORDS_ATOM, RESERVED_WORDS, KEYWORDS_BEFORE_EXPRESSION, ALL_KEYWORDS, OPERATOR_CHARS, RE_HEX_NUMBER, RE_OCT_NUMBER, RE_DEC_NUMBER, OPERATORS, OP_MAP, WHITESPACE_CHARS, PUNC_BEFORE_EXPRESSION, PUNC_CHARS, REGEXP_MODIFIERS, UNICODE, IDENTIFIER_PAT, STRING_MODIFIERS, UNARY_POSTFIX, PRECEDENCE, EX_EOF;
    var makePredicate = _modules["utils"].makePredicate;
    var ParseError = _modules["utils"].ParseError;
    
    var ast = _modules["ast"];
    
    function characters(str_) {
        return str_.split("");
    }
    ES6_KEYWORDS = "async await yield";
    KEYWORDS = "as break case class const continue debugger default def del do elif else except " + "finally for from if import in is new nonlocal pass raise return switch til to " + "try void while with or and not " + ES6_KEYWORDS;
    JS_KEYWORDS = "var function instanceof typeof catch delete throw".split(" ");
    KEYWORDS_ATOM = "False None True";
    RESERVED_WORDS = "abstract boolean byte char double enum export extends final float goto " + "implements int interface long native package private protected public short static " + "synchronized this throws transient volatile " + KEYWORDS_ATOM + " " + KEYWORDS;
    KEYWORDS_BEFORE_EXPRESSION = "return new del raise elif else if";
    ALL_KEYWORDS = RESERVED_WORDS + " " + KEYWORDS_BEFORE_EXPRESSION;
    KEYWORDS = makePredicate(KEYWORDS);
    ES6_KEYWORDS = makePredicate(ES6_KEYWORDS);
    RESERVED_WORDS = makePredicate(RESERVED_WORDS);
    KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
    KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
    OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^@"));
    RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
    RE_OCT_NUMBER = /^0[0-7]+$/;
    RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;
    OPERATORS = makePredicate([ "in", "instanceof", "typeof", "new", "void", "del", "++", "--", "+", "-", "not", "~", "&", "|", "^", "**", "*", "/", "//", "%", ">>", "<<", ">>>", "<", ">", "<=", ">=", "==", "===", "is", "!=", "!==", "?", "=", "+=", "-=", "/=", "//=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=", "and", "or", "til", "to", "@", "->" ]);
    OP_MAP = {
        "or": "||",
        "and": "&&",
        "not": "!",
        "del": "delete",
        "None": "null",
        "is": "==="
    };
    WHITESPACE_CHARS = makePredicate(characters(" \n\r\t\f"));
    PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,.;:"));
    PUNC_CHARS = makePredicate(characters("[]{}(),;:"));
    REGEXP_MODIFIERS = makePredicate(characters("gmsiy"));
    UNICODE = {
        letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
        non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
        space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
        connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
    };
    IDENTIFIER_PAT = /^[a-z_$][_a-z0-9$]*$/i;
    STRING_MODIFIERS = "urfURF";
    UNARY_POSTFIX = makePredicate([ "--", "++" ]);
    PRECEDENCE = function(a, ret) {
        var i, b, j;
        for (i = 0; i < a.length; i++) {
            b = a[i];
            for (j = 0; j < b.length; j++) {
                ret[b[j]] = i + 1;
            }
        }
        return ret;
    }([ [ "||" ], [ "&&" ], [ "|" ], [ "^" ], [ "&" ], [ "==", "===", "!=", "!==" ], [ "<", ">", "<=", ">=", "in", "instanceof" ], [ ">>", "<<", ">>>" ], [ "+", "-" ], [ "*", "/", "//", "%" ], [ "**" ] ], {});
    function is_letter(code) {
        return code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 170 && UNICODE.letter.test(String.fromCharCode(code));
    }
    function is_digit(code) {
        return code >= 48 && code <= 57;
    }
    function is_alphanumeric_char(code) {
        return is_digit(code) || is_letter(code);
    }
    function is_unicode_combining_mark(ch) {
        return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);
    }
    function is_unicode_connector_punctuation(ch) {
        return UNICODE.connector_punctuation.test(ch);
    }
    function is_string_modifier(val) {
        var itr36, idx36;
        var ch;
        itr36 = _Iterable(val);
        for (idx36 = 0; idx36 < itr36.length; idx36++) {
            ch = itr36[idx36];
            if (_in(ch, STRING_MODIFIERS)) {
                return true;
            }
        }
        return false;
    }
    function is_identifier(name) {
        return !RESERVED_WORDS(name) && IDENTIFIER_PAT.test(name);
    }
    function is_identifier_start(code) {
        return code === 36 || code === 95 || is_letter(code);
    }
    function is_identifier_char(ch) {
        var code;
        code = ch.charCodeAt(0);
        return is_identifier_start(code) || is_digit(code) || code === 8204 || code === 8205 || is_unicode_combining_mark(ch) || is_unicode_connector_punctuation(ch);
    }
    function parse_js_number(num) {
        if (RE_HEX_NUMBER.test(num)) {
            return parseInt(num.substr(2), 16);
        } else if (RE_OCT_NUMBER.test(num)) {
            return parseInt(num.substr(1), 8);
        } else if (RE_DEC_NUMBER.test(num)) {
            return parseFloat(num);
        }
    }
    function is_token(token, type, val) {
        return token.type === type && (val === null || val === void 0 || token.value === val);
    }
    function js_error(message, filename, line, col, pos, is_eof) {
        ast.Node.warn("ERROR:{message}[{file}:{line},{col}]", {
            message: message,
            file: filename,
            line: line,
            col: col
        });
        throw new ParseError(message, line, col, pos, is_eof);
    }
    EX_EOF = {};
    function tokenizer($TEXT, filename) {
        var _115, _116, _117;
        var S;
        S = {
            text: $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, ""),
            filename: filename,
            pos: 0,
            tokpos: 0,
            line: 1,
            tokline: 0,
            col: 0,
            tokcol: 0,
            newline_before: false,
            regex_allowed: false,
            comments_before: [],
            whitespace_before: [],
            newblock: false,
            endblock: false,
            indentation_matters: [ true ],
            cached_whitespace: "",
            prev: void 0,
            index_or_slice: [ false ],
            expect_object_literal_key: false
        };
        function peek() {
            return S.text.charAt(S.pos);
        }
        function prevChar() {
            return S.text.charAt(S.tokpos - 1);
        }
        function next(signal_eof, in_string) {
            var ch;
            ch = S.text.charAt(S.pos);
            ++S.pos;
            if (signal_eof && !ch) {
                throw EX_EOF;
            }
            if (ch === "\n") {
                S.newline_before = S.newline_before || !in_string;
                ++S.line;
                S.col = 0;
            } else {
                ++S.col;
            }
            return ch;
        }
        function find(what, signal_eof) {
            var pos;
            pos = S.text.indexOf(what, S.pos);
            if (signal_eof && pos === -1) {
                throw EX_EOF;
            }
            return pos;
        }
        function start_token() {
            S.tokline = S.line;
            S.tokcol = S.col;
            S.tokpos = S.pos;
        }
        function token(full_type, value, is_comment, keep_newline) {
            var full_type, type, subtype, value, ret, i;
            full_type = full_type.split(":");
            type = full_type[0];
            subtype = full_type[1];
            S.regex_allowed = type === "operator" && !UNARY_POSTFIX[value] || type === "keyword" && KEYWORDS_BEFORE_EXPRESSION(value) || type === "punc" && PUNC_BEFORE_EXPRESSION(value);
            if (type === "operator" && value === "is" && S.text.substr(S.pos).trimLeft().substr(0, 4).trimRight() === "not") {
                next_token();
                value = "!==";
            }
            if (type === "operator" && OP_MAP[value]) {
                value = OP_MAP[value];
            }
            ret = {
                type: type,
                subtype: subtype,
                value: value,
                line: S.tokline,
                col: S.tokcol,
                pos: S.tokpos,
                endpos: S.pos,
                newline_before: S.newline_before,
                file: filename
            };
            if (!is_comment) {
                ret.comments_before = S.comments_before;
                S.comments_before = [];
                for (i = 0; i < len(ret.comments_before); i++) {
                    ret.newline_before = ret.newline_before || ret.comments_before[i].newline_before;
                }
            }
            if (!keep_newline) {
                S.newline_before = false;
            }
            if (type === "punc") {
                if (value === ":" && !S.index_or_slice[S.index_or_slice.length-1] && !S.expect_object_literal_key && (!S.text.substring(S.pos + 1, find("\n")).trim() || !S.text.substring(S.pos + 1, find("#")).trim())) {
                    S.newblock = true;
                    S.indentation_matters.push(true);
                }
                if (value === "[") {
                    if (S.prev && S.prev.type === "name") {
                        S.index_or_slice.push(true);
                    } else {
                        S.index_or_slice.push(false);
                    }
                    S.indentation_matters.push(false);
                } else if (value === "{" || value === "(") {
                    S.indentation_matters.push(false);
                } else if (value === "]") {
                    S.index_or_slice.pop();
                    S.indentation_matters.pop();
                } else if (value === "}" || value === ")") {
                    S.indentation_matters.pop();
                }
            }
            S.prev = new ast.Token(ret);
            return S.prev;
        }
        function parse_whitespace() {
            var leading_whitespace, whitespace_exists, ch;
            leading_whitespace = "";
            whitespace_exists = false;
            while (WHITESPACE_CHARS(peek())) {
                whitespace_exists = true;
                ch = next();
                if (ch === "\n") {
                    leading_whitespace = "";
                } else {
                    leading_whitespace += ch;
                }
            }
            if (peek() !== "#") {
                if (!whitespace_exists) {
                    leading_whitespace = S.cached_whitespace;
                } else {
                    S.cached_whitespace = leading_whitespace;
                }
                if (S.newline_before || S.endblock) {
                    return test_indent_token(leading_whitespace);
                }
            }
        }
        function test_indent_token(leading_whitespace) {
            var most_recent;
            most_recent = S.whitespace_before[S.whitespace_before.length - 1] || "";
            S.endblock = false;
            if (S.indentation_matters[S.indentation_matters.length-1] && leading_whitespace !== most_recent) {
                if (S.newblock && leading_whitespace && leading_whitespace.indexOf(most_recent) === 0) {
                    S.newblock = false;
                    S.whitespace_before.push(leading_whitespace);
                    return 1;
                } else if (most_recent && most_recent.indexOf(leading_whitespace) === 0) {
                    S.endblock = true;
                    S.whitespace_before.pop();
                    return -1;
                } else {
                    TokenizerError("Inconsistent indentation");
                }
            } else {
                return 0;
            }
        }
        function read_while(pred) {
            var ret, i, ch;
            ret = "";
            i = 0;
            while ((ch = peek()) && pred(ch, i)) {
                ++i;
                ret += next();
            }
            return ret;
        }
        function TokenizerError(err, is_eof) {
            js_error(err, filename, S.tokline, S.tokcol, S.tokpos, is_eof);
        }
        function read_num(prefix) {
            var has_e, after_e, has_x, has_dot, num, valid;
            has_e = false;
            after_e = false;
            has_x = false;
            has_dot = prefix === ".";
            num = read_while(function(ch, i) {
                var code, tmp_, has_x, has_e, has_dot;
                code = ch.charCodeAt(0);
                tmp_ = code;
                if (tmp_ === 120 || tmp_ === 88) {
                    return has_x ? false : has_x = true;
                } else if (tmp_ === 101 || tmp_ === 69) {
                    return has_x ? true : has_e ? false : has_e = after_e = true;
                } else if (tmp_ === 45) {
                    return after_e || i === 0 && !prefix;
                } else if (tmp_ === 43) {
                    return after_e;
                } else if (tmp_ === 46) {
                    after_e = false;
                    return !has_dot && !has_x && !has_e ? has_dot = true : false;
                }
                return is_alphanumeric_char(code);
            });
            if (prefix) {
                num = prefix + num;
            }
            valid = parse_js_number(num);
            if (!isNaN(valid)) {
                return token("num", valid);
            } else {
                TokenizerError("Invalid syntax: " + num);
            }
        }
        function read_escaped_char(in_string, digester) {
            var digester, ch, tmp_;
            digester = digester || function(in_str) {
                return next(true, in_str);
            };
            ch = digester(in_string);
            tmp_ = ch.charCodeAt(0);
            if (tmp_ === 110) {
                return "\n";
            } else if (tmp_ === 114) {
                return "\r";
            } else if (tmp_ === 116) {
                return "\t";
            } else if (tmp_ === 98) {
                return "\b";
            } else if (tmp_ === 118) {
                return "";
            } else if (tmp_ === 102) {
                return "\f";
            } else if (tmp_ === 48) {
                return "\0";
            } else if (tmp_ === 120) {
                return String.fromCharCode(hex_bytes(2, digester));
            } else if (tmp_ === 117) {
                return String.fromCharCode(hex_bytes(4, digester));
            } else if (tmp_ === 10) {
                return "";
            } else {
                return ch;
            }
        }
        function hex_bytes(n, digester) {
            var num, i, digit;
            num = 0;
            for (i = 0; i < n; i++) {
                digit = parseInt(digester(), 16);
                if (isNaN(digit)) {
                    TokenizerError("Invalid hex-character pattern in string");
                }
                num = num << 4 | digit;
            }
            return num;
        }
        
        var read_string = (_115 = function read_string(modifier) {
            var token_type, quote, ret, i, tmp, find_newlines, ch;
            token_type = "string";
            if (modifier) {
                token_type += ":" + modifier;
            }
            quote = next();
            ret = "";
            if (peek() === quote) {
                next(true);
                if (peek() === quote) {
                    next(true);
                    i = find(quote + quote + quote, true);
                    if (i !== -1) {
                        tmp = S.text.substring(S.pos, i);
                        S.pos = i + 3;
                        while (tmp.length) {
                            if (tmp[0] === "\\") {
                                tmp = tmp.slice(1);
                                ret += read_escaped_char(true, function() {
                                    var ch;
                                    ch = tmp[0];
                                    tmp = tmp.slice(1);
                                    return ch;
                                });
                            } else {
                                ret += tmp[0];
                                tmp = tmp.slice(1);
                            }
                        }
                        find_newlines = ret.match(/\n/g);
                        if (find_newlines) {
                            S.line += find_newlines.length;
                        }
                        return token(token_type, ret);
                    }
                } else {
                    return token(token_type, "");
                }
            }
            while (true) {
                ch = next(true);
                if (ch === "\n") {
                    TokenizerError("End of line while scanning string literal.");
                }
                if (ch === "\\") {
                    if (peek() === "\n") {
                        next(true);
                        continue;
                    } else {
                        ch = read_escaped_char(true);
                    }
                } else if (ch === quote) {
                    break;
                }
                ret += ch;
            }
            return token(token_type, ret);
        }, _115 = with_eof_error("Unterminated string constant")(_115), _115);
        function read_line_comment(shebang) {
            shebang = shebang === void 0 ? false : shebang;
            var i, ret;
            if (!shebang) {
                next();
            }
            i = find("\n");
            if (i === -1) {
                ret = S.text.substr(S.pos);
                S.pos = S.text.length;
            } else {
                ret = S.text.substring(S.pos, i);
                S.pos = i;
            }
            return token(shebang ? "shebang" : "comment:line", ret, true);
        }
        
        var read_multiline_comment = (_116 = function read_multiline_comment() {
            var i, text, a, n;
            next();
            i = find("*/", true);
            text = S.text.substring(S.pos, i);
            a = text.split("\n");
            n = a.length;
            S.pos = i + 2;
            S.line += n - 1;
            if (n > 1) {
                S.col = a[n - 1].length;
            } else {
                S.col += a[n - 1].length;
            }
            S.col += 2;
            S.newline_before = S.newline_before || _in("\n", text);
            return token("comment:multiline", text, true);
        }, _116 = with_eof_error("Unterminated multiline comment")(_116), _116);
        function read_name() {
            var backslash, name, escaped, ch, hex;
            backslash = false;
            name = "";
            escaped = false;
            while ((ch = peek()) !== null) {
                if (!backslash) {
                    if (ch === "\\") {
                        if (S.text.charAt(S.pos + 1) === "\n") {
                            S.pos += 2;
                            continue;
                        } else {
                            escaped = backslash = true;
                            next();
                        }
                    } else if (is_identifier_char(ch)) {
                        name += next();
                    } else {
                        break;
                    }
                } else {
                    if (ch !== "u") {
                        TokenizerError("Expecting UnicodeEscapeSequence -- uXXXX");
                    }
                    ch = read_escaped_char();
                    if (!is_identifier_char(ch)) {
                        TokenizerError("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                    }
                    name += ch;
                    backslash = false;
                }
            }
            if (KEYWORDS(name) && escaped) {
                hex = name.charCodeAt(0).toString(16).toUpperCase();
                name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
            }
            return name;
        }
        
        var read_regexp = (_117 = function read_regexp(regexp) {
            var prev_backslash, in_class, verbose_regexp, in_comment, mods, ch, regexp;
            prev_backslash = false;
            in_class = false;
            verbose_regexp = false;
            in_comment = false;
            if (peek() === "/") {
                next(true);
                if (peek() === "/") {
                    verbose_regexp = true;
                    next(true);
                } else {
                    mods = read_name();
                    return token("regexp", new RegExp(regexp, mods));
                }
            }
            while (ch = next(true)) {
                if (in_comment) {
                    if (ch === "\n") {
                        in_comment = false;
                    }
                    continue;
                }
                if (prev_backslash) {
                    regexp += "\\" + ch;
                    prev_backslash = false;
                } else if (ch === "[") {
                    in_class = true;
                    regexp += ch;
                } else if (ch === "]" && in_class) {
                    in_class = false;
                    regexp += ch;
                } else if (ch === "/" && !in_class) {
                    if (verbose_regexp) {
                        if (peek() !== "/") {
                            regexp += "\\/";
                            continue;
                        }
                        next(true);
                        if (peek() !== "/") {
                            regexp += "\\/\\/";
                            continue;
                        }
                        next(true);
                    }
                    break;
                } else if (ch === "\\") {
                    prev_backslash = true;
                } else if (verbose_regexp && !in_class && _in(ch, " \n\r\t")) {
                } else if (verbose_regexp && !in_class && ch === "#") {
                    in_comment = true;
                } else {
                    regexp += ch;
                }
            }
            mods = read_name();
            return token("regexp", new RegExp(regexp, mods));
        }, _117 = with_eof_error("Unterminated regular expression")(_117), _117);
        function read_operator(prefix) {
            var op;
            function grow(op) {
                var bigger;
                if (!peek()) {
                    return op;
                }
                bigger = op + peek();
                if (OPERATORS(bigger)) {
                    next();
                    return grow(bigger);
                } else {
                    return op;
                }
            }
            op = grow(prefix || next());
            if (_in(op, [ "++", "--", "===", "!==" ])) {
                TokenizerError("Invalid operator " + op + "");
            } else if (op === "->") {
                return token("punc", op);
            }
            return token("operator", op);
        }
        function handle_slash() {
            next();
            return S.regex_allowed ? read_regexp("") : read_operator("/");
        }
        function handle_dot() {
            next();
            return is_digit(peek().charCodeAt(0)) ? read_num(".") : token("punc", ".");
        }
        function read_word() {
            var word;
            word = read_name();
            return KEYWORDS_ATOM(word) ? token("atom", word) : !KEYWORDS(word) ? token("name", word) : OPERATORS(word) && prevChar() !== "." ? token("operator", word) : token("keyword", word);
        }
        function with_eof_error(eof_error) {
            return function(cont) {
                return function(x) {
                    try {
                        return cont(x);
                    } catch (_Exception) {
                        var ex = _Exception;
                        if (ex === EX_EOF) {
                            TokenizerError(eof_error, true);
                        } else {
                            throw _Exception;
                        }
                    }
                };
            };
        }
        function next_token(force_regexp) {
            var indent, ch, code, tmp_, regex_allowed, tok, mods, string_tok;
            if (!(_in(force_regexp, [null, void 0]))) {
                return read_regexp(force_regexp);
            }
            indent = parse_whitespace();
            if (indent === -1) {
                return token("punc", "}", false, true);
            }
            start_token();
            ch = peek();
            if (!ch) {
                return token("eof");
            }
            code = ch.charCodeAt(0);
            tmp_ = code;
            if (tmp_ === 34 || tmp_ === 39) {
                return read_string();
            } else if (tmp_ === 35) {
                if (S.pos === 0 && S.text.charAt(1) === "!") {
                    return read_line_comment(true);
                }
                regex_allowed = S.regex_allowed;
                S.comments_before.push(read_line_comment());
                S.regex_allowed = regex_allowed;
                return next_token();
            } else if (tmp_ === 46) {
                return handle_dot();
            } else if (tmp_ === 47) {
                return handle_slash();
            }
            if (is_digit(code)) {
                return read_num();
            }
            if (PUNC_CHARS(ch)) {
                return token("punc", next());
            }
            if (OPERATOR_CHARS(ch)) {
                return read_operator();
            }
            if (code === 92 && S.text.charAt(S.pos + 1) === "\n") {
                next();
                next();
                S.newline_before = false;
                return next_token();
            }
            if (code === 92 || is_identifier_start(code)) {
                tok = read_word();
                if (_in(peek(), "'\"") && is_string_modifier(tok.value)) {
                    mods = tok.value.toLowerCase();
                    string_tok = read_string(mods);
                    tok.endpos = string_tok.endpos;
                    tok.value = string_tok.value;
                    tok.subtype = string_tok.subtype;
                    tok.type = string_tok.type;
                }
                return tok;
            }
            TokenizerError("Unexpected character " + ch + "");
        }
        next_token.context = function(nc) {
            if (nc) {
                S = nc;
            }
            return S;
        };
        return next_token;
    }
    _modules["tokenizer"]["ES6_KEYWORDS"] = ES6_KEYWORDS;

    _modules["tokenizer"]["KEYWORDS"] = KEYWORDS;

    _modules["tokenizer"]["JS_KEYWORDS"] = JS_KEYWORDS;

    _modules["tokenizer"]["KEYWORDS_ATOM"] = KEYWORDS_ATOM;

    _modules["tokenizer"]["RESERVED_WORDS"] = RESERVED_WORDS;

    _modules["tokenizer"]["KEYWORDS_BEFORE_EXPRESSION"] = KEYWORDS_BEFORE_EXPRESSION;

    _modules["tokenizer"]["ALL_KEYWORDS"] = ALL_KEYWORDS;

    _modules["tokenizer"]["OPERATOR_CHARS"] = OPERATOR_CHARS;

    _modules["tokenizer"]["RE_HEX_NUMBER"] = RE_HEX_NUMBER;

    _modules["tokenizer"]["RE_OCT_NUMBER"] = RE_OCT_NUMBER;

    _modules["tokenizer"]["RE_DEC_NUMBER"] = RE_DEC_NUMBER;

    _modules["tokenizer"]["OPERATORS"] = OPERATORS;

    _modules["tokenizer"]["OP_MAP"] = OP_MAP;

    _modules["tokenizer"]["WHITESPACE_CHARS"] = WHITESPACE_CHARS;

    _modules["tokenizer"]["PUNC_BEFORE_EXPRESSION"] = PUNC_BEFORE_EXPRESSION;

    _modules["tokenizer"]["PUNC_CHARS"] = PUNC_CHARS;

    _modules["tokenizer"]["REGEXP_MODIFIERS"] = REGEXP_MODIFIERS;

    _modules["tokenizer"]["UNICODE"] = UNICODE;

    _modules["tokenizer"]["IDENTIFIER_PAT"] = IDENTIFIER_PAT;

    _modules["tokenizer"]["STRING_MODIFIERS"] = STRING_MODIFIERS;

    _modules["tokenizer"]["UNARY_POSTFIX"] = UNARY_POSTFIX;

    _modules["tokenizer"]["PRECEDENCE"] = PRECEDENCE;

    _modules["tokenizer"]["EX_EOF"] = EX_EOF;

    _modules["tokenizer"]["characters"] = characters;

    _modules["tokenizer"]["is_letter"] = is_letter;

    _modules["tokenizer"]["is_digit"] = is_digit;

    _modules["tokenizer"]["is_alphanumeric_char"] = is_alphanumeric_char;

    _modules["tokenizer"]["is_unicode_combining_mark"] = is_unicode_combining_mark;

    _modules["tokenizer"]["is_unicode_connector_punctuation"] = is_unicode_connector_punctuation;

    _modules["tokenizer"]["is_string_modifier"] = is_string_modifier;

    _modules["tokenizer"]["is_identifier"] = is_identifier;

    _modules["tokenizer"]["is_identifier_start"] = is_identifier_start;

    _modules["tokenizer"]["is_identifier_char"] = is_identifier_char;

    _modules["tokenizer"]["parse_js_number"] = parse_js_number;

    _modules["tokenizer"]["is_token"] = is_token;

    _modules["tokenizer"]["js_error"] = js_error;

    _modules["tokenizer"]["tokenizer"] = tokenizer;
})();

(function(){
    var __name__ = "parser";
    var NATIVE_CLASSES, COMMON_STATIC, CLASS_MAP, key, BASELIB, STDLIB, UNARY_PREFIX, ASSIGNMENT, STATEMENTS_WITH_LABELS, ATOMIC_START_TOKEN;
    var makePredicate = _modules["utils"].makePredicate;
    var defaults = _modules["utils"].defaults;
    var ImportError = _modules["utils"].ImportError;
    var js_error = _modules["utils"].js_error;
    var RAPYD_PREFIX = _modules["utils"].RAPYD_PREFIX;
    
    var ast = _modules["ast"];
    
    var tokenizer = _modules["tokenizer"];
    
    function array_to_hash(a) {
        var ret, i;
        ret = {};
        for (i = 0; i < len(a); i++) {
            ret[a[i]] = true;
        }
        return ret;
    }
    NATIVE_CLASSES = {
        "Image": {},
        "RegExp": {},
        "Error": {},
        "Object": {
            static: [ "assign", "getOwnPropertyNames", "keys", "create", "defineProperty", "defineProperties", "getPrototypeOf", "setPrototypeOf" ]
        },
        "String": {
            static: [ "fromCharCode" ]
        },
        "Array": {
            static: [ "isArray", "from", "of" ]
        },
        "Number": {
            static: [ "isFinite", "isNaN" ]
        },
        "Function": {},
        "Date": {
            static: [ "UTC", "now", "parse" ]
        },
        "Boolean": {},
        "ArrayBuffer": {},
        "DataView": {},
        "Float32Array": {},
        "Float64Array": {},
        "Int16Array": {},
        "Int32Array": {},
        "Int8Array": {},
        "Uint16Array": {},
        "Uint32Array": {},
        "Uint8Array": {},
        "Uint8ClampedArray": {},
        "Map": {},
        "WeakMap": {},
        "Set": {},
        "WeakSet": {},
        "AssertionError": {},
        "IndexError": {},
        "KeyError": {},
        "TypeError": {},
        "ValueError": {}
    };
    COMMON_STATIC = [ "call", "apply", "bind", "toString" ];
    CLASS_MAP = {};
    BASELIB = (function() {
        var idx37, itr37 = _Iterable([ "abs", "all", "any", "bin", "bind", "rebind_all", "cmp", "chr", "dir", "enumerate", "eslice", "extends", "filter", "hex", "in", "iterable", "len", "map", "max", "min", "merge", "mixin", "print", "range", "reduce", "reversed", "sorted", "sum", "type", "zip", "getattr", "setattr", "hasattr", "eq", "kwargs", "AssertionError", "IndexError", "KeyError", "TypeError", "ValueError" ]), res = {}, key;
        for (idx37 = 0; idx37 < itr37.length; idx37++) {
            key = itr37[idx37];
            res[key] = 0;
        }
        return res;
    })();
    STDLIB = [ "abs", "bin", "cmp", "chr", "dir", "hex", "max", "min", "merge", "mixin", "print", "range", "reduce", "getattr", "setattr", "hasattr", "eq", "bind", "rebind_all", "type", "all", "any", "enumerate", "filter", "len", "map", "reversed", "sum", "zip", "AssertionError", "IndexError", "KeyError", "TypeError", "ValueError" ];
    function has_simple_decorator(decorators, name) {
        var remove, s;
        remove = [];
        for (var i = 0; i < decorators.length; i++) {
            s = decorators[i];
            if (s instanceof ast.SymbolRef && !s.parens && s.name === name) {
                remove.push(i);
            }
        }
        if (remove.length) {
            remove.reverse();
            for (var i = 0; i < remove.length; i++) {
                decorators.splice(remove[i], 1);
            }
            return true;
        }
        return false;
    }
    UNARY_PREFIX = makePredicate([ "typeof", "void", "delete", "--", "++", "!", "~", "-", "+", "*", "@" ]);
    ASSIGNMENT = makePredicate([ "=", "+=", "-=", "/=", "//=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ]);
    STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);
    ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);
    function parse($TEXT, options) {
        var itr38, idx38, _118, _119, _120;
        var options, module_id, import_dirs, IMPORTED, IMPORTING, S, cname, obj;
        options = defaults(options, {
            strict: false,
            filename: null,
            auto_bind: false,
            module_id: "__main__",
            es6: false,
            toplevel: null,
            import_dirs: [],
            dropDecorators: [],
            dropImports: [],
            dropDocstrings: false,
            classes: null
        });
        module_id = options.module_id;
        import_dirs = options.import_dirs.slice(0);
        if (options.libdir) {
            import_dirs.push(options.libdir);
        }
        if (options.basedir) {
            import_dirs.unshift(options.basedir);
        }
        IMPORTED = options.IMPORTED || {};
        IMPORTING = options.IMPORTING || {};
        IMPORTING[module_id] = true;
        S = {
            input: typeof $TEXT === "string" ? tokenizer.tokenizer($TEXT, options.filename) : $TEXT,
            token: null,
            prev: null,
            peeked: null,
            in_directives: true,
            in_loop: 0,
            in_scope: [ {
                type: null,
                vars: {},
                nonlocal: {},
                functions: {},
                classes: {}
            } ],
            labels: [],
            decorators: [],
            in_seq: false,
            in_decorator: false
        };
        if (options.classes) {
            itr38 = _Iterable(options.classes);
            for (idx38 = 0; idx38 < itr38.length; idx38++) {
                cname = itr38[idx38];
                obj = options.classes[cname];
                S.in_scope[0].classes[cname] = {
                    "static": obj.static,
                    "bound": obj.bound
                };
            }
        }
        S.token = next();
        function is_(type, value) {
            return tokenizer.is_token(S.token, type, value);
        }
        function peek() {
            return S.peeked || (S.peeked = S.input());
        }
        function next() {
            S.prev = S.token;
            if (S.peeked) {
                S.token = S.peeked;
                S.peeked = null;
            } else {
                S.token = S.input();
            }
            S.in_directives = S.in_directives && (S.token.type === "string" || is_("punc", ";"));
            return S.token;
        }
        function prev() {
            return S.prev;
        }
        function croak(msg, line, col, pos, is_eof) {
            var ctx;
            ctx = S.input.context();
            tokenizer.js_error(msg, ctx.filename, line !== void 0 ? line : ctx.tokline, col !== void 0 ? col : ctx.tokcol, pos !== void 0 ? pos : ctx.tokpos, is_eof);
        }
        function token_error(token, msg) {
            var is_eof;
            is_eof = token.type === "eof" ? true : false;
            croak(msg, token.line, token.col, void 0, is_eof);
        }
        function unexpected(token) {
            var token;
            if (token === void 0) {
                token = S.token;
            }
            token_error(token, "Unexpected token: " + token.type + " " + token.value + "");
        }
        function expect_token(type, val) {
            if (is_(type, val)) {
                return next();
            }
            token_error(S.token, "Unexpected token " + S.token.type + " " + S.token.value + "" + ", expected " + type + " " + val + "");
        }
        function expect(punc) {
            return expect_token("punc", punc);
        }
        function can_insert_semicolon() {
            return !options.strict && (S.token.newline_before || is_("eof") || is_("punc", "}"));
        }
        function semicolon() {
            if (is_("punc", ";")) {
                next();
                S.token.newline_before = true;
            }
        }
        function parenthesised() {
            var exp;
            expect("(");
            exp = expression(true);
            expect(")");
            return exp;
        }
        function embed_tokens(parser) {
            return function() {
                var start, expr, end;
                start = S.token;
                expr = parser();
                if (expr === void 0) {
                    unexpected();
                }
                end = prev();
                expr.start = start;
                expr.end = end;
                return expr;
            };
        }
        function is_nested_comparison(stmt) {
            var comparators;
            comparators = {
                "<": true,
                ">": true,
                "<=": true,
                ">=": true,
                "==": true,
                "!=": true,
                "===": true,
                "!==": true
            };
            if (stmt instanceof ast.Binary && _in(stmt.operator, comparators) && stmt.left instanceof ast.Binary && _in(stmt.left.operator, comparators)) {
                return true;
            } else {
                return false;
            }
        }
        function scan_for_top_level_callables(body) {
            var itr39, idx39;
            var ans, name, obj, x, opt;
            ans = [];
            if (Array.isArray(body)) {
                for (name in body) {
                    obj = body[name];
                    if (obj instanceof ast.Function || obj instanceof ast.Class) {
                        if (obj.name) {
                            ans.push(obj.name);
                        } else {
                            token_error(obj.start, "Top-level functions must have names");
                        }
                    } else {
                        if (obj instanceof ast.Scope) {
                            continue;
                        }
                        itr39 = _Iterable([ "body", "alternative" ]);
                        for (idx39 = 0; idx39 < itr39.length; idx39++) {
                            x = itr39[idx39];
                            opt = obj[x];
                            if (opt) {
                                ans = ans.concat(scan_for_top_level_callables(opt));
                            }
                            if (opt instanceof ast.Assign && !(opt.right instanceof ast.Scope)) {
                                ans = ans.concat(scan_for_top_level_callables(opt.right));
                            }
                        }
                    }
                }
            } else if (body.body) {
                ans = ans.concat(scan_for_top_level_callables(body.body));
                if (body.alternative) {
                    ans = ans.concat(scan_for_top_level_callables(body.alternative));
                }
            }
            return ans;
        }
        
        var statement = (_118 = function statement() {
            var tmp_, dir, stat, type, start, func, chain, ctor, result, expectedType, actualType, tmp;
            if (is_("operator", "/") || is_("operator", "/=")) {
                S.peeked = null;
                S.token = S.input(S.token.value.slice(1));
            }
            tmp_ = S.token.type;
            if (tmp_ === "string") {
                dir = S.in_directives;
                stat = simple_statement();
                if (dir && stat.body instanceof ast.String && !is_("punc", ",")) {
                    return new ast.Directive({
                        value: stat.body.value
                    });
                }
                return stat;
            } else if (tmp_ === "shebang") {
                tmp_ = S.token.value;
                next();
                return new ast.Directive({
                    value: tmp_
                });
            } else if (tmp_ === "num" || tmp_ === "regexp" || tmp_ === "operator" || tmp_ === "atom") {
                return simple_statement();
            } else if (tmp_ === "punc") {
                tmp_ = S.token.value;
                if (tmp_ === ":") {
                    return new ast.BlockStatement({
                        start: S.token,
                        body: block_(),
                        end: prev()
                    });
                } else if (tmp_ === "{" || tmp_ === "[" || tmp_ === "(") {
                    return simple_statement();
                } else if (tmp_ === ";") {
                    next();
                    return new ast.EmptyStatement();
                } else {
                    unexpected();
                }
            } else if (tmp_ === "name") {
                if (_in(S.token.value, [ "set", "get" ])) {
                    if (!options.es6) {
                        croak("Class getters/setters require ES6 compilation mode");
                    }
                    type = S.token.value;
                    start = S.token.start;
                    next();
                    return accessor_(type, start, true);
                }
                return tokenizer.is_token(peek(), "punc", ":") ? labeled_statement() : simple_statement();
            } else if (tmp_ === "keyword") {
                tmp_ = S.token.value;
                if (tokenizer.ES6_KEYWORDS(tmp_) && !options.es6) {
                    token_error(prev(), "" + tmp_ + " keyword not supported with ES5 output, use --ecmascript6 compilation flag");
                }
                next();
                if (tmp_ === "break") {
                    return break_cont(ast.Break);
                } else if (tmp_ === "continue") {
                    return break_cont(ast.Continue);
                } else if (tmp_ === "debugger") {
                    semicolon();
                    return new ast.Debugger();
                } else if (tmp_ === "do") {
                    return new ast.Do({
                        body: in_loop(statement),
                        condition: function() {
                            var tmp;
                            expect(".");
                            expect_token("keyword", "while");
                            tmp = expression(true);
                            semicolon();
                            return tmp;
                        }.call(this)
                    });
                } else if (tmp_ === "while") {
                    return new ast.While({
                        condition: expression(true),
                        body: in_loop(statement)
                    });
                } else if (tmp_ === "for") {
                    if (is_("name", "JS")) {
                        return for_js();
                    }
                    return for_();
                } else if (tmp_ === "from") {
                    return import_(true);
                } else if (tmp_ === "import") {
                    return import_(false);
                } else if (tmp_ === "class") {
                    ++BASELIB["extends"];
                    if (options.auto_bind) {
                        ++BASELIB["rebind_all"];
                    }
                    return class_();
                } else if (tmp_ === "def") {
                    start = prev();
                    func = function_(S.in_scope[S.in_scope.length-1].type === "class" ? S.in_scope[S.in_scope.length-1].name : false);
                    func.start = start;
                    func.end = prev();
                    chain = subscripts(func, true);
                    if (chain === func) {
                        return func;
                    } else {
                        return new ast.SimpleStatement({
                            start: start,
                            body: chain,
                            end: prev()
                        });
                    }
                } else if (tmp_ === "if") {
                    return if_();
                } else if (tmp_ === "pass") {
                    semicolon();
                    return new ast.EmptyStatement();
                } else if (tmp_ === "return" || tmp_ === "yield") {
                    if (S.in_scope[S.in_scope.length-1].type !== "function") {
                        croak("'return' outside of function");
                    }
                    if (tmp_ === "yield") {
                        S.in_scope[S.in_scope.length-1].generator = true;
                        ctor = ast.Yield;
                    } else {
                        ctor = ast.Return;
                    }
                    result = new ctor({
                        value: is_("punc", ";") ? function() {
                            semicolon();
                            return null;
                        }() : can_insert_semicolon() ? null : function() {
                            var tmp;
                            tmp = expression(true);
                            semicolon();
                            return tmp;
                        }()
                    });
                    if (S.in_scope[S.in_scope.length-1].return_annotation) {
                        expectedType = S.in_scope[S.in_scope.length-1].return_annotation.resolveType(S.in_scope);
                        actualType = result.resolveType(S.in_scope);
                        if (!(_in(actualType, [ expectedType, "?" ]))) {
                            croak("Type annotation states that function returns " + expectedType + ", actual returned type is " + actualType + "");
                        }
                    }
                    return result;
                } else if (tmp_ === "switch") {
                    return new ast.Switch({
                        expression: parenthesised(),
                        body: in_loop(switch_body_)
                    });
                } else if (tmp_ === "raise") {
                    if (S.token.newline_before) {
                        return new ast.Throw({
                            value: new ast.SymbolCatch({
                                name: "_Exception"
                            })
                        });
                    }
                    tmp = expression(true);
                    semicolon();
                    return new ast.Throw({
                        value: tmp
                    });
                } else if (tmp_ === "try") {
                    return try_();
                } else if (tmp_ === "nonlocal") {
                    tmp = nonlocal_();
                    semicolon();
                    return tmp;
                } else if (tmp_ === "const") {
                    tmp = const_();
                    semicolon();
                    return tmp;
                } else if (tmp_ === "with") {
                    return new ast.With({
                        expression: parenthesised(),
                        body: statement()
                    });
                } else {
                    unexpected();
                }
            }
        }, _118 = embed_tokens(_118), _118);
        function labeled_statement() {
            var label, stat;
            label = as_symbol(ast.Label);
            if (find_if(function(l) {
                return l.name === label.name;
            }, S.labels)) {
                croak("Label " + label.name + " defined twice");
            }
            expect(":");
            S.labels.push(label);
            stat = statement();
            S.labels.pop();
            return new ast.LabeledStatement({
                body: stat,
                label: label
            });
        }
        function simple_statement(tmp) {
            var tmp;
            tmp = expression(true);
            semicolon();
            return new ast.SimpleStatement({
                body: tmp
            });
        }
        function break_cont(type_) {
            var label;
            label = null;
            if (!can_insert_semicolon()) {
                label = as_symbol(ast.LabelRef, true);
            }
            if (label !== null) {
                if (!find_if(function(l) {
                    return l.name === label.name;
                }, S.labels)) {
                    croak("Undefined label " + label.name);
                }
            } else if (S.in_loop === 0) {
                croak(_type(type_) + " not inside a loop or switch");
            }
            semicolon();
            return new type_({
                label: label
            });
        }
        function seq_to_array(seq) {
            return new ast.Array({
                start: seq.start,
                elements: seq.to_array(),
                end: seq.end
            });
        }
        function for_(list_comp) {
            var init;
            init = null;
            if (!is_("punc", ";")) {
                init = expression(true, true);
                if (init instanceof ast.Seq) {
                    init = seq_to_array(init);
                }
                if (is_("operator", "in")) {
                    if (init instanceof ast.Var && init.definitions.length > 1) {
                        croak("Only one variable declaration allowed in for..in loop");
                    }
                    next();
                    return for_in(init, list_comp);
                }
            }
            unexpected();
        }
        function for_in(init, list_comp) {
            var itr40, idx40, upk1;
            var lhs, obj, i, element, value;
            lhs = init instanceof ast.Var ? init.definitions[0].name : null;
            obj = expression(true);
            if (init instanceof ast.Array) {
                itr40 = _Iterable(enumerate(init.elements));
                for (idx40 = 0; idx40 < itr40.length; idx40++) {
                    upk1 = itr40[idx40];
                    i = upk1[0];
                    element = upk1[1];
                    value = null;
                    if (obj instanceof ast.Call && obj.expression instanceof ast.SymbolRef && obj.expression.name === "enumerate") {
                        if (i === 0) {
                            value = "Number";
                        }
                    }
                    mark_local_assignment(element, value);
                }
            } else {
                value = null;
                if (obj instanceof ast.Call && obj.expression instanceof ast.SymbolRef && obj.expression.name === "range") {
                    value = "Number";
                }
                mark_local_assignment(init, value);
            }
            ++BASELIB["iterable"];
            if (list_comp) {
                return {
                    init: init,
                    name: lhs,
                    object: obj
                };
            }
            return new ast.ForIn({
                init: init,
                name: lhs,
                object: obj,
                body: in_loop(statement)
            });
        }
        function for_js() {
            var condition;
            condition = expression(true, true);
            return new ast.ForJS({
                condition: condition,
                body: in_loop(statement)
            });
        }
        function get_class_in_scope(expr) {
            var itr41, idx41, itr42, idx42;
            var s, referenced_path, expr, class_name;
            if (expr instanceof ast.SymbolRef) {
                if (_in(expr.name, NATIVE_CLASSES)) {
                    return NATIVE_CLASSES[expr.name];
                }
                itr41 = _Iterable(range(S.in_scope.length - 1, -1, -1));
                for (idx41 = 0; idx41 < itr41.length; idx41++) {
                    s = itr41[idx41];
                    if (_in(expr.name, S.in_scope[s].classes)) {
                        return S.in_scope[s].classes[expr.name];
                    }
                }
            } else if (expr instanceof ast.Dot) {
                referenced_path = [];
                while (expr instanceof ast.Dot) {
                    referenced_path.unshift(expr.property);
                    expr = expr.expression;
                }
                if (expr instanceof ast.SymbolRef) {
                    referenced_path.unshift(expr.name);
                    if (len(referenced_path) > 1) {
                        class_name = referenced_path.join(".");
                        itr42 = _Iterable(range(S.in_scope.length - 1, -1, -1));
                        for (idx42 = 0; idx42 < itr42.length; idx42++) {
                            s = itr42[idx42];
                            if (_in(class_name, S.in_scope[s].classes)) {
                                return S.in_scope[s].classes[class_name];
                            }
                        }
                    }
                }
            }
            return false;
        }
        function do_import(key) {
            var itr44, idx44, upk3;
            var package_module_id, filename, src_code, modpath, location, data, contents;
            if (_in(key, IMPORTED)) {
                return;
            }
            if (IMPORTING[key]) {
                throw new ImportError("Detected a recursive import of: " + key + " while importing: " + module_id);
            }
            package_module_id = key.split(".").slice(0, -1).join(".");
            if (len(package_module_id) > 0) {
                do_import(package_module_id);
            }
            function safe_read(base_path) {
                var itr43, idx43, upk2;
                var i, path;
                itr43 = _Iterable(enumerate([ base_path + ".pyj", base_path + "/__init__.pyj" ]));
                for (idx43 = 0; idx43 < itr43.length; idx43++) {
                    upk2 = itr43[idx43];
                    i = upk2[0];
                    path = upk2[1];
                    try {
                        return [ options.readfile(path, "utf-8"), path ];
                    } catch (_Exception) {
                        var e = _Exception;
                        if (e.code === "ENOENT" || e.code === "EPERM" || e.code === "EACCESS") {
                            if (i === 1) {
                                return [null, null];
                            }
                        }
                        if (i === 1) {
                            throw _Exception;
                        }
                    }
                }
            }
            src_code = filename = null;
            modpath = key.replace(/\./g, "/");
            itr44 = _Iterable(import_dirs);
            for (idx44 = 0; idx44 < itr44.length; idx44++) {
                location = itr44[idx44];
                if (location) {
                    upk3 = safe_read(location + "/" + modpath);
                    data = upk3[0];
                    filename = upk3[1];
                    if (data !== null) {
                        src_code = data;
                        break;
                    }
                }
            }
            if (src_code === null) {
                throw "Failed Import: '" + key + "' module doesn't exist in any of the import directories: " + import_dirs.join(", ");
            }
            contents = parse(src_code, {
                filename: filename,
                toplevel: null,
                readfile: options.readfile || require("fs").readFileSync,
                basedir: options.basedir,
                libdir: options.libdir,
                module_id: key,
                IMPORTED: IMPORTED,
                IMPORTING: IMPORTING,
                auto_bind: options.auto_bind,
                es6: options.es6,
                import_dirs: options.import_dirs,
                dropDecorators: options.dropDecorators,
                dropImports: options.dropImports,
                dropDocstrings: options.dropDocstrings
            });
            if (len(package_module_id) > 0) {
                IMPORTED[package_module_id].submodules.push(key);
            }
        }
        function import_(from_import) {
            var itr45, idx45, itr46, idx46;
            var ans, name, tmp, key, alias, imp, classes, argnames, aname, argvar, obj, i;
            ans = new ast.Imports({
                "imports": []
            });
            while (true) {
                tmp = name = expression(false);
                key = "";
                while (tmp instanceof ast.Dot) {
                    key = "." + tmp.property + key;
                    tmp = tmp.expression;
                }
                key = tmp.name + key;
                if (!keepDecoratorOrImport(key, true)) {
                    return new ast.EmptyStatement({
                        start: prev(),
                        end: prev()
                    });
                }
                alias = null;
                if (!from_import && is_("keyword", "as")) {
                    next();
                    alias = as_symbol(ast.SymbolAlias);
                }
                imp = new ast.Import({
                    "module": name,
                    "key": key,
                    "alias": alias,
                    "argnames": null,
                    "body": function() {
                        return IMPORTED[key];
                    }
                });
                ans.imports.push(imp);
                if (from_import) {
                    break;
                }
                if (is_("punc", ",")) {
                    next();
                } else {
                    break;
                }
            }
            itr45 = _Iterable(ans["imports"]);
            for (idx45 = 0; idx45 < itr45.length; idx45++) {
                imp = itr45[idx45];
                do_import(imp.key);
                classes = IMPORTED[key].classes;
                if (from_import) {
                    expect_token("keyword", "import");
                    imp.argnames = argnames = [];
                    while (true) {
                        aname = as_symbol(ast.ImportedVar);
                        if (is_("keyword", "as")) {
                            next();
                            aname.alias = as_symbol(ast.SymbolAlias);
                        }
                        argnames.push(aname);
                        if (is_("punc", ",")) {
                            next();
                        } else {
                            break;
                        }
                    }
                    itr46 = _Iterable(argnames);
                    for (idx46 = 0; idx46 < itr46.length; idx46++) {
                        argvar = itr46[idx46];
                        obj = classes[argvar.name];
                        if (obj) {
                            key = argvar.alias ? argvar.alias.name : argvar.name;
                            S.in_scope[S.in_scope.length-1].classes[key] = {
                                "static": obj.static,
                                "bound": obj.bound
                            };
                        }
                    }
                } else {
                    for (i in classes) {
                        obj = classes[i];
                        if (obj instanceof ast.Class) {
                            key = imp.alias ? imp.alias.name : imp.key;
                            S.in_scope[S.in_scope.length-1].classes[key + "." + obj.name.name] = {
                                "static": obj.static,
                                "bound": obj.bound
                            };
                        }
                    }
                }
            }
            return ans;
        }
        function class_() {
            var itr49, idx49;
            var start, name, externaldecorator, class_details, parent, docstring, definition, i, stmt, class_var_names, visitor;
            start = prev();
            name = as_symbol(ast.SymbolDefun);
            if (!name) {
                unexpected();
            }
            externaldecorator = has_simple_decorator(S.decorators, "external");
            class_details = {
                "static": [],
                "bound": {}
            };
            parent = null;
            docstring = null;
            definition = new ast.Class({
                start: start,
                name: name,
                module_id: module_id,
                parent: function() {
                    var atom;
                    if (is_("punc", "(")) {
                        next();
                        if (is_("punc", ")")) {
                            S.in_parenthesized_expr = false;
                            next();
                            return null;
                        }
                        atom = expr_atom(false);
                        expect(")");
                        parent = atom.name;
                        return atom;
                    } else {
                        return null;
                    }
                }(),
                localvars: [],
                static: class_details.static,
                external: externaldecorator,
                bound: class_details.bound,
                statements: [],
                decorators: function() {
                    var itr47, idx47;
                    var d, decorator;
                    d = [];
                    itr47 = _Iterable(S.decorators);
                    for (idx47 = 0; idx47 < itr47.length; idx47++) {
                        decorator = itr47[idx47];
                        if (decorator === "kwargs") {
                            ++BASELIB["kwargs"];
                        }
                        d.push(new ast.Decorator({
                            expression: decorator
                        }));
                    }
                    S.decorators = [];
                    return d;
                }(),
                body: function(loop, labels) {
                    var a;
                    S.in_scope[S.in_scope.length-1].classes[name.name] = class_details;
                    S.in_scope.push({
                        type: "class",
                        name: name.name,
                        parent: parent,
                        nonlocal: {},
                        functions: {},
                        vars: {},
                        classes: {}
                    });
                    S.in_directives = true;
                    S.in_loop = 0;
                    S.labels = [];
                    a = block_();
                    docstring = S.in_scope[S.in_scope.length-1].docstring;
                    S.in_scope.pop();
                    S.in_loop = loop;
                    S.labels = labels;
                    return a;
                }(S.in_loop, S.labels),
                docstring: docstring,
                end: prev()
            });
            for (i in definition.body) {
                stmt = definition.body[i];
                if (stmt instanceof ast.Method && stmt.name.name === "__init__") {
                    definition.init = stmt;
                    break;
                }
            }
            class_var_names = {};
            function walker() {
                this._visit = function(node, descend) {
                    var itr48, idx48;
                    var child;
                    if (node instanceof ast.Method) {
                        class_var_names[node.name.name] = true;
                        return;
                    } else if (node instanceof ast.Assign && node.left instanceof ast.SymbolRef) {
                        class_var_names[node.left.name] = true;
                    }
                    itr48 = _Iterable(node);
                    for (idx48 = 0; idx48 < itr48.length; idx48++) {
                        child = itr48[idx48];
                        if (node[child] instanceof ast.SymbolRef && Object.prototype.hasOwnProperty.call(class_var_names, node[child].name)) {
                            node[child] = new ast.SymbolClassRef({
                                "class": name,
                                "name": node[child].name
                            });
                        }
                    }
                    if (descend) {
                        descend.call(node);
                    }
                };
            }
            visitor = new walker();
            itr49 = _Iterable(definition.body);
            for (idx49 = 0; idx49 < itr49.length; idx49++) {
                stmt = itr49[idx49];
                if (!(stmt instanceof ast.Class) && !(stmt instanceof ast.Method)) {
                    stmt.walk(visitor);
                    definition.statements.push(stmt);
                }
            }
            if (S.in_scope.length === 1) {
                CLASS_MAP[definition.name.name] = definition;
            }
            return definition;
        }
        function function_(in_class, ctor) {
            var start, is_accessor, name, generator, localvars, staticmethod, function_args, return_annotation, has_special_decorator, ctor, docstring, callsSuper, definition;
            start = prev();
            is_accessor = ctor === ast.ObjectGetter || ctor === ast.ObjectSetter;
            name = is_("name") ? as_symbol(in_class ? ast.SymbolDefun : is_accessor ? ast.SymbolAccessor : ast.SymbolLambda) : is_accessor && (is_("string") || is_("num")) ? as_atom_node() : null;
            if (in_class && !name) {
                unexpected();
            }
            if (name && _in(name.name, tokenizer.JS_KEYWORDS)) {
                name.name += "_";
            }
            generator = false;
            localvars = null;
            staticmethod = false;
            function_args = {};
            return_annotation = null;
            if (!S.in_decorator) {
                has_special_decorator = function(name) {
                    return has_simple_decorator(S.decorators, name);
                };
                if (in_class) {
                    if (has_special_decorator("staticmethod")) {
                        S.in_scope[S.in_scope.length-2].classes[in_class].static.push(name.name);
                        staticmethod = true;
                    }
                    if (has_special_decorator("bind") || name.name !== "__init__" && options.auto_bind) {
                        ++BASELIB["bind"];
                        S.in_scope[S.in_scope.length-2].classes[in_class].bound[name.name] = true;
                    }
                }
            }
            expect("(");
            if (!ctor) {
                ctor = in_class ? name.name === "__init__" ? ast.Constructor : ast.Method : ast.Function;
            }
            docstring = null;
            callsSuper = null;
            definition = new ctor({
                start: start,
                name: name,
                argnames: function(a) {
                    var defaults, first, seen_names, def_line, val, expr;
                    defaults = {};
                    first = true;
                    seen_names = {};
                    def_line = S.input.context().tokline;
                    function get_arg() {
                        var name_token, name_ctx, ntok, annotation, sym, name;
                        if (Object.prototype.hasOwnProperty.call(seen_names, S.token.value)) {
                            token_error(prev(), "Can't repeat parameter names");
                        }
                        if (S.token.value === "arguments") {
                            token_error(prev(), "Can't use the name arguments as a parameter name, it is reserved by JavaScript");
                        }
                        seen_names[S.token.value] = true;
                        name_token = S.token;
                        name_ctx = S.input.context();
                        ntok = peek();
                        if (ntok.type === "punc" && ntok.value === ":") {
                            next();
                            expect(":");
                            annotation = maybe_conditional();
                            if (!tokenizer.is_token(name_token, "name")) {
                                croak("Name expected", name_ctx.tokline);
                                return null;
                            }
                            sym = new ast.SymbolFunarg({
                                "name": name_token.value,
                                "start": S.token,
                                "end": S.token,
                                "annotation": annotation ? new ast.Annotation({
                                    "start": annotation.start,
                                    "expression": annotation,
                                    "end": annotation.end
                                }) : null
                            });
                        } else {
                            if (!is_("name")) {
                                if (S.input.context().tokline !== def_line) {
                                    croak("Name expected", def_line);
                                } else {
                                    croak("Name expected");
                                }
                                return null;
                            }
                            name = S.token.value;
                            if (_in(name, tokenizer.JS_KEYWORDS)) {
                                name += "_";
                            }
                            sym = new ast.SymbolFunarg({
                                "name": name,
                                "start": S.token,
                                "end": S.token,
                                "annotation": null
                            });
                            next();
                        }
                        function_args[sym.name] = sym.annotation ? sym.annotation.resolveType(S.in_scope) : "?";
                        return sym;
                    }
                    while (!is_("punc", ")")) {
                        if (first) {
                            first = false;
                        } else {
                            expect(",");
                        }
                        if (is_("operator", "**")) {
                            token_error(prev(), "**kwargs in function definition is not implemented yet, work in progress");
                            next();
                            if (a.kwargs) {
                                token_error(prev(), "Can't define multiple **kwargs in function definition");
                            }
                            a.kwargs = get_arg();
                        } else if (is_("operator", "*")) {
                            next();
                            if (a.starargs) {
                                token_error(prev(), "Can't define multiple *args in function definition");
                            }
                            if (a.kwargs) {
                                token_error(prev(), "Can't define *args after **kwargs in function definition");
                            }
                            a.starargs = get_arg();
                        } else {
                            if (a.starargs || a.kwargs) {
                                token_error(prev(), "Can't define a formal parameter after *args or **kwargs");
                            }
                            a.push(get_arg());
                            if (is_("operator", "=")) {
                                if (a.kwargs) {
                                    token_error(prev(), "Can't define an optional formal parameter after **kwargs");
                                }
                                val = prev().value;
                                next();
                                defaults[val] = expression(false);
                                a.has_defaults = true;
                            } else {
                                if (a.has_defaults) {
                                    token_error(prev(), "Can't define required formal parameters after optional formal parameters");
                                }
                            }
                        }
                    }
                    next();
                    if (is_("punc", "->")) {
                        next();
                        expr = expression(true);
                        return_annotation = new ast.Annotation({
                            start: expr.start,
                            expression: expr,
                            end: expr.end
                        });
                    }
                    a.defaults = defaults;
                    return a;
                }([]),
                decorators: S.in_decorator ? [] : function() {
                    var itr50, idx50;
                    var d, decorator;
                    d = [];
                    itr50 = _Iterable(S.decorators);
                    for (idx50 = 0; idx50 < itr50.length; idx50++) {
                        decorator = itr50[idx50];
                        d.push(new ast.Decorator({
                            expression: decorator
                        }));
                    }
                    S.decorators = [];
                    return d;
                }(),
                return_annotation: return_annotation,
                body: function(loop, labels) {
                    var a, variable;
                    S.in_scope.push({
                        type: "function",
                        name: name ? name.name : null,
                        return_annotation: return_annotation,
                        nonlocal: {},
                        vars: {},
                        args: function_args,
                        functions: {},
                        classes: {}
                    });
                    S.in_directives = true;
                    S.in_loop = 0;
                    S.labels = [];
                    a = block_();
                    generator = S.in_scope[S.in_scope.length-1].generator;
                    docstring = S.in_scope[S.in_scope.length-1].docstring;
                    callsSuper = S.in_scope[S.in_scope.length-1].callsSuper;
                    if (generator) {
                        _print(S.in_scope[S.in_scope.length-1]);
                    }
                    localvars = (function() {
                        var idx51, itr51 = _Iterable(Object.keys(S.in_scope[S.in_scope.length-1].vars)), res = [], variable;
                        for (idx51 = 0; idx51 < itr51.length; idx51++) {
                            variable = itr51[idx51];
                            if (!(_in(variable, S.in_scope[S.in_scope.length-1].nonlocal))) {
                                res.push(new_symbol(ast.SymbolVar, variable));
                            }
                        }
                        return res;
                    })();
                    S.in_scope.pop();
                    S.in_loop = loop;
                    S.labels = labels;
                    return a;
                }(S.in_loop, S.labels),
                docstring: docstring,
                generator: generator,
                localvars: localvars,
                end: prev(),
                static: in_class && staticmethod
            });
            if (name) {
                S.in_scope[S.in_scope.length-1].functions[name.name] = definition.resolveType(S.in_scope);
            }
            if (in_class && !staticmethod) {
                if (ctor === ast.Constructor) {
                    definition.parent = S.in_scope[S.in_scope.length-1].parent;
                    definition.callsSuper = callsSuper;
                }
                if (definition.argnames.length < 1) {
                    croak("Class methods require at least one argument (self)", start.line, start.col, start.pos);
                } else if (ctor === ast.ObjectGetter && definition.argnames.length !== 1) {
                    croak("Class getters don't take any arguments aside from one referencing the instance (self)", start.line, start.col, start.pos);
                } else if (ctor === ast.ObjectSetter && definition.argnames.length !== 2) {
                    croak("Class setters take exactly 2 arguments (self, value)", start.line, start.col, start.pos);
                }
            } else if (is_accessor) {
                if (ctor === ast.ObjectGetter && definition.argnames.length) {
                    croak("Object getters don't take any arguments", start.line, start.col, start.pos);
                } else if (ctor === ast.ObjectSetter && definition.argnames.length !== 1) {
                    croak("Object setters take exactly 1 argument", start.line, start.col, start.pos);
                }
            }
            return definition;
        }
        function accessor_(type, start, in_class) {
            var func;
            if (type === "get") {
                func = function_(in_class, ast.ObjectGetter);
            } else if (type === "set") {
                func = function_(in_class, ast.ObjectSetter);
            } else {
                croak("Expecting setter/getter, got '" + type + "' instead.");
            }
            func.start = start;
            func.end = prev();
            return func;
        }
        function if_() {
            var cond, body, belse;
            cond = expression(true);
            body = statement();
            belse = null;
            if (is_("keyword", "elif") || is_("keyword", "else")) {
                if (is_("keyword", "else")) {
                    next();
                } else {
                    S.token.value = "if";
                }
                belse = statement();
            }
            return new ast.If({
                condition: cond,
                body: body,
                alternative: belse
            });
        }
        function is_docstring(stmt) {
            if (stmt instanceof ast.Directive && !S.in_scope[S.in_scope.length-1].docstring) {
                return true;
            }
            return false;
        }
        function format_docstring(string) {
            var itr52, idx52, itr53, idx53;
            var lines, indent, line, pad, trimmed;
            lines = string.split(/\n/g);
            indent = 1e6;
            itr52 = _Iterable(lines.slice(1));
            for (idx52 = 0; idx52 < itr52.length; idx52++) {
                line = itr52[idx52];
                if (line.trim().length) {
                    pad = line.match(/^\s*/)[0];
                    indent = Math.min(indent, pad.length);
                }
            }
            trimmed = [ lines[0].trim() ];
            if (indent < 1e6) {
                itr53 = _Iterable(lines.slice(1));
                for (idx53 = 0; idx53 < itr53.length; idx53++) {
                    line = itr53[idx53];
                    trimmed.push(line.slice(indent).replace(/\s+$/));
                }
            }
            while (trimmed && !trimmed[trimmed.length-1]) {
                trimmed.pop();
            }
            while (trimmed && !trimmed[0]) {
                trimmed.shift();
            }
            return trimmed.join("\n");
        }
        function block_() {
            var a, stmt;
            expect(":");
            a = [];
            if (!S.token.newline_before) {
                while (!S.token.newline_before) {
                    if (is_("eof")) {
                        unexpected();
                    }
                    stmt = statement();
                    if (!a.length && is_docstring(stmt)) {
                        if (!options.dropDocstrings) {
                            S.in_scope[S.in_scope.length-1].docstring = format_docstring(stmt.value);
                        }
                    } else {
                        a.push(stmt);
                    }
                }
            } else {
                while (!is_("punc", "}")) {
                    if (is_("eof")) {
                        return a;
                    }
                    stmt = statement();
                    if (!a.length && is_docstring(stmt)) {
                        if (!options.dropDocstrings) {
                            S.in_scope[S.in_scope.length-1].docstring = format_docstring(stmt.value);
                        }
                    } else {
                        a.push(stmt);
                    }
                }
                next();
            }
            return a;
        }
        function switch_body_() {
            var a, cur, branch;
            expect("{");
            a = [];
            cur = null;
            branch = null;
            while (!is_("punc", "}")) {
                if (is_("eof")) {
                    unexpected();
                }
                if (is_("keyword", "case")) {
                    if (branch) {
                        branch.end = prev();
                    }
                    cur = [];
                    branch = new ast.Case({
                        start: function() {
                            var tmp;
                            tmp = S.token;
                            next();
                            return tmp;
                        }(),
                        expression: expression(true),
                        body: cur
                    });
                    a.push(branch);
                    expect(":");
                } else if (is_("keyword", "default")) {
                    if (branch) {
                        branch.end = prev();
                    }
                    cur = [];
                    branch = new ast.Default({
                        start: function() {
                            var tmp;
                            tmp = S.token;
                            next();
                            expect(":");
                            return tmp;
                        }(),
                        body: cur
                    });
                    a.push(branch);
                } else {
                    if (!cur) {
                        unexpected();
                    }
                    cur.push(statement());
                }
            }
            if (branch) {
                branch.end = prev();
            }
            next();
            return a;
        }
        function try_() {
            var body, bcatch, bfinally, start, exceptions, name;
            body = block_();
            bcatch = [];
            bfinally = null;
            while (is_("keyword", "except")) {
                start = S.token;
                next();
                exceptions = [];
                if (!is_("punc", ":") && !is_("keyword", "as")) {
                    exceptions.push(as_symbol(ast.SymbolVar));
                    while (is_("punc", ",")) {
                        next();
                        exceptions.push(as_symbol(ast.SymbolVar));
                    }
                }
                name = null;
                if (is_("keyword", "as")) {
                    next();
                    name = as_symbol(ast.SymbolCatch);
                }
                bcatch.push(new ast.Except({
                    start: start,
                    argname: name,
                    errors: exceptions,
                    body: block_(),
                    end: prev()
                }));
            }
            if (is_("keyword", "finally")) {
                start = S.token;
                next();
                bfinally = new ast.Finally({
                    start: start,
                    body: block_(),
                    end: prev()
                });
            }
            if (!bcatch.length && !bfinally) {
                croak("Missing except/finally blocks");
            }
            return new ast.Try({
                body: body,
                bcatch: bcatch.length ? new ast.Catch({
                    body: bcatch
                }) : null,
                bfinally: bfinally
            });
        }
        function vardefs(no_in, type) {
            var a, symbol;
            a = [];
            while (true) {
                symbol = new ast.VarDef({
                    start: S.token,
                    name: as_symbol(type === "const" ? ast.SymbolConst : type === "nonlocal" ? ast.SymbolNonlocal : ast.SymbolVar),
                    end: prev()
                });
                if (type === "nonlocal") {
                    S.in_scope[S.in_scope.length-1].nonlocal[symbol.name.name] = true;
                }
                a.push(symbol);
                if (!is_("punc", ",")) {
                    break;
                }
                next();
            }
            return a;
        }
        function nonlocal_(no_in) {
            return new ast.Var({
                start: prev(),
                definitions: vardefs(no_in, "nonlocal"),
                end: prev()
            });
        }
        function const_() {
            return new ast.Const({
                start: prev(),
                definitions: vardefs(false, "const"),
                end: prev()
            });
        }
        function new_() {
            var start, newexp, args;
            start = S.token;
            expect_token("operator", "new");
            newexp = expr_atom(false);
            if (is_("punc", "(")) {
                next();
                args = expr_list(")");
            } else {
                args = [];
            }
            return subscripts(new ast.New({
                start: start,
                expression: newexp,
                args: args,
                end: prev()
            }), true);
        }
        function as_atom_node(token) {
            var tok, tmp_, token, ret, tmp__;
            tok = token || S.token;
            tmp_ = tok.type;
            if (tmp_ === "name") {
                if (tok.value === "NaN") {
                    ret = kwargs(as_symbol)(ast.NotANumber, {token: tok});
                } else if (tok.value === "undefined") {
                    ret = kwargs(as_symbol)(ast.Undefined, {token: tok});
                } else {
                    ret = kwargs(as_symbol)(ast.SymbolRef, {token: tok});
                }
            } else if (tmp_ === "num") {
                ret = new ast.Number({
                    start: tok,
                    end: tok,
                    value: tok.value
                });
            } else if (tmp_ === "string") {
                ret = new ast.String({
                    start: tok,
                    end: tok,
                    value: tok.value,
                    modifier: tok.subtype
                });
            } else if (tmp_ === "regexp") {
                ret = new ast.RegExp({
                    start: tok,
                    end: tok,
                    value: tok.value
                });
            } else if (tmp_ === "atom") {
                tmp__ = tok.value;
                if (tmp__ === "False") {
                    ret = new ast.Boolean({
                        start: tok,
                        value: false,
                        end: tok
                    });
                } else if (tmp__ === "True") {
                    ret = new ast.Boolean({
                        start: tok,
                        value: true,
                        end: tok
                    });
                } else if (tmp__ === "None") {
                    ret = new ast.Null({
                        start: tok,
                        end: tok
                    });
                }
            }
            if (!token) {
                next();
            }
            ret.resolveType(S.in_scope);
            return ret;
        }
        function expr_atom(allow_calls) {
            var start, tmp_, ex, cls, func;
            if (is_("operator", "new")) {
                return new_();
            }
            start = S.token;
            if (is_("punc")) {
                tmp_ = start.value;
                if (tmp_ === "(") {
                    next();
                    ex = expression(true);
                    ex.start = start;
                    ex.end = S.token;
                    if (ex instanceof ast.SymbolRef) {
                        ex.parens = true;
                    }
                    expect(")");
                    return subscripts(ex, allow_calls);
                } else if (tmp_ === "[") {
                    return subscripts(array_(), allow_calls);
                } else if (tmp_ === "{") {
                    return subscripts(object_(), allow_calls);
                }
                unexpected();
            }
            if (is_("keyword", "class")) {
                next();
                cls = class_();
                cls.start = start;
                cls.end = prev();
                return subscripts(cls, allow_calls);
            }
            if (is_("keyword", "def")) {
                next();
                func = function_(false);
                func.start = start;
                func.end = prev();
                return subscripts(func, allow_calls);
            }
            if (ATOMIC_START_TOKEN[S.token.type]) {
                return subscripts(as_atom_node(), allow_calls);
            }
            unexpected();
        }
        function expr_list(closing, allow_trailing_comma, allow_empty, func_call) {
            var itr54, idx54, upk4;
            var first, a, saw_starargs, tmp, i, arg;
            first = true;
            a = [];
            saw_starargs = false;
            while (!is_("punc", closing)) {
                if (saw_starargs) {
                    token_error(prev(), "*args must be the last argument in a function call");
                }
                if (first) {
                    first = false;
                } else {
                    expect(",");
                }
                if (allow_trailing_comma && is_("punc", closing)) {
                    break;
                }
                if (is_("operator", "*") && func_call) {
                    saw_starargs = true;
                    next();
                }
                if (is_("punc", ",") && allow_empty) {
                    a.push(new ast.Hole({
                        start: S.token,
                        end: S.token
                    }));
                } else {
                    a.push(expression(false));
                }
            }
            if (func_call) {
                tmp = [];
                tmp.kwargs = [];
                itr54 = _Iterable(enumerate(a));
                for (idx54 = 0; idx54 < itr54.length; idx54++) {
                    upk4 = itr54[idx54];
                    i = upk4[0];
                    arg = upk4[1];
                    if (arg instanceof ast.Assign) {
                        ++BASELIB["kwargs"];
                        tmp.kwargs.push([ arg.left, arg.right ]);
                    } else {
                        tmp.push(arg);
                    }
                }
                a = tmp;
            }
            next();
            if (saw_starargs) {
                a.starargs = true;
            }
            return a;
        }
        function func_call_list() {
            var a, first, kwargs, arg;
            a = [];
            first = true;
            a.kwargs = [];
            a.kwarg_items = kwargs = [];
            a.starargs = false;
            while (!is_("punc", ")")) {
                if (first) {
                    first = false;
                } else {
                    expect(",");
                }
                if (is_("operator", "*")) {
                    next();
                    arg = expression(false);
                    arg.is_array = true;
                    a.push(arg);
                    a.starargs = true;
                } else if (is_("operator", "**")) {
                    ++BASELIB["kwargs"];
                    next();
                    kwargs.push(as_symbol(ast.SymbolVar, false));
                } else {
                    arg = expression(false);
                    if (arg instanceof ast.Assign) {
                        ++BASELIB["kwargs"];
                        a.kwargs.push([ arg.left, arg.right ]);
                    } else {
                        a.push(arg);
                    }
                }
            }
            next();
            return a;
        }
        function read_comprehension(object) {
            var terminator, forloop;
            terminator = object instanceof ast.DictComprehension ? "}" : "]";
            expect_token("keyword", "for");
            forloop = for_(true);
            ++BASELIB["iterable"];
            object.init = forloop.init;
            object.name = forloop.name;
            object.object = forloop.object;
            object.condition = is_("punc", terminator) ? null : (expect_token("keyword", "if"), 
            expression(true));
            expect(terminator);
            return object;
        }
        
        var array_ = (_119 = function array_() {
            var expr, ret;
            expect("[");
            expr = [];
            if (!is_("punc", "]")) {
                expr.push(expression(false));
                if (is_("keyword", "for")) {
                    return read_comprehension(new ast.ListComprehension({
                        statement: expr[0]
                    }));
                }
                if (is_("operator", "til")) {
                    ++BASELIB["range"];
                    next();
                    expr.push(expression(false));
                    ret = new ast.Range({
                        start: S.token,
                        left: expr[0],
                        operator: "til",
                        right: expr[1],
                        end: prev()
                    });
                    expect("]");
                    return ret;
                } else if (is_("operator", "to")) {
                    ++BASELIB["range"];
                    next();
                    expr.push(expression(false));
                    ret = new ast.Range({
                        start: S.token,
                        left: expr[0],
                        operator: "to",
                        right: expr[1],
                        end: prev()
                    });
                    expect("]");
                    return ret;
                } else if (!is_("punc", "]")) {
                    expect(",");
                }
            }
            return new ast.Array({
                elements: expr.concat(expr_list("]", !options.strict, true))
            });
        }, _119 = embed_tokens(_119), _119);
        
        var object_ = (_120 = function object_() {
            var maybe_dict_comprehension, first, a, start, type, computed, saw_starargs, key, name, ctx, orig, key_;
            maybe_dict_comprehension = false;
            expect("{");
            first = true;
            a = [];
            while (!is_("punc", "}")) {
                if (!first) {
                    expect(",");
                }
                if (!options.strict && is_("punc", "}")) {
                    break;
                }
                start = S.token;
                type = start.type;
                computed = false;
                saw_starargs = false;
                if (is_("operator", "*")) {
                    saw_starargs = true;
                    if (!options.es6) {
                        croak("Spread operator in object literals is only allowed in ES6 mode");
                    }
                    a.push(maybe_unary(true));
                } else if (first && peek().value !== ":") {
                    maybe_dict_comprehension = true;
                    key = expression(false);
                    name = null;
                } else {
                    ctx = S.input.context();
                    orig = ctx.expect_object_literal_key;
                    ctx.expect_object_literal_key = true;
                    if (is_("punc", "(")) {
                        if (!options.es6) {
                            croak("Computed properties are only allowed in ES6 mode");
                        }
                        expect("(");
                        key = expression(false);
                        expect(")");
                        computed = true;
                    } else {
                        key_ = as_property_name();
                        name = key_.value;
                        if (key_.type === "num") {
                            key = new ast.Number({
                                start: start,
                                value: name,
                                end: prev()
                            });
                        } else if (key_.type === "name" || key_.type === "keyword") {
                            if (_in(name, [ "True", "False" ])) {
                                key = new ast.Boolean({
                                    start: start,
                                    value: name,
                                    end: prev()
                                });
                            } else {
                                key = new ast.Identifier({
                                    start: start,
                                    value: name,
                                    end: prev()
                                });
                            }
                        } else {
                            key = new ast.String({
                                start: start,
                                value: name,
                                end: prev()
                            });
                        }
                    }
                    ctx.expect_object_literal_key = orig;
                    if (type === "name" && !is_("punc", ":")) {
                        a.push(accessor_(name, start, false));
                        continue;
                    }
                }
                if (!saw_starargs) {
                    expect(":");
                    a.push(new ast.ObjectKeyVal({
                        start: start,
                        key: key,
                        value: expression(false),
                        end: prev()
                    }));
                    if (a.length === 1 && is_("keyword", "for")) {
                        return read_comprehension(new ast.DictComprehension({
                            statement: maybe_dict_comprehension ? key : as_atom_node(a[0].start),
                            value_statement: a[0].value
                        }));
                    }
                }
                first = false;
            }
            next();
            return new ast.ObjectLiteral({
                properties: a
            });
        }, _120 = embed_tokens(_120), _120);
        function as_property_name() {
            var tmp, tmp_;
            tmp = S.token;
            next();
            tmp_ = tmp.type;
            if (tmp_ === "num" || tmp_ === "string" || tmp_ === "name" || tmp_ === "operator" || tmp_ === "keyword" || tmp_ === "atom") {
                return tmp;
            } else {
                unexpected();
            }
        }
        function as_name() {
            var tmp, tmp_;
            tmp = S.token;
            next();
            tmp_ = tmp.type;
            if (tmp_ === "name" || tmp_ === "operator" || tmp_ === "keyword" || tmp_ === "atom") {
                return tmp.value;
            } else {
                unexpected();
            }
        }
        function as_symbol(type, noerror, token) {
            var token_, name, sym;
            token_ = token || S.token;
            if (!tokenizer.is_token(token_, "name")) {
                if (!noerror) {
                    croak("Name expected");
                }
                return null;
            }
            name = token_.value;
            if (_in(name, tokenizer.JS_KEYWORDS)) {
                token_.value += "_";
            }
            sym = new (name === "this" ? ast.This : type)({
                name: String(token_.value),
                start: token_,
                end: token_
            });
            if (!token) {
                next();
            }
            return sym;
        }
        function new_symbol(type, name) {
            var sym;
            sym = new (name === "this" ? ast.This : type)({
                name: String(name),
                start: null,
                end: null
            });
            return sym;
        }
        function is_static_method(cls, method) {
            if (_in(method, COMMON_STATIC) || cls.static && _in(method, cls.static)) {
                return true;
            } else {
                return false;
            }
        }
        function mark_local_assignment(element, value) {
            var computedType, name;
            if (value) {
                computedType = typeof value === "string" ? value : value.resolveType(S.in_scope);
            } else {
                computedType = "?";
            }
            name = typeof element === "string" ? element : element.name;
            if (name) {
                if (_in(name, S.in_scope[S.in_scope.length-1].vars)) {
                    S.in_scope[S.in_scope.length-1].vars[name].push(computedType);
                } else {
                    S.in_scope[S.in_scope.length-1].vars[name] = [ computedType ];
                }
            }
        }
        function subscripts(expr, allow_calls) {
            var start, slice_bounds, is_slice, i, str_, ret, className, funcname, tmp_, args;
            start = expr.start;
            if (is_("punc", ".")) {
                next();
                return subscripts(new ast.Dot({
                    start: start,
                    expression: expr,
                    property: as_name(),
                    end: prev()
                }), allow_calls);
            }
            if (is_("punc", "[") && !S.token.newline_before) {
                next();
                slice_bounds = [];
                is_slice = false;
                if (is_("punc", ":")) {
                    slice_bounds.push(null);
                } else {
                    slice_bounds.push(expression(false));
                }
                if (is_("punc", ":")) {
                    is_slice = true;
                    next();
                    if (is_("punc", ":")) {
                        slice_bounds.push(null);
                    } else if (!is_("punc", "]")) {
                        slice_bounds.push(expression(false));
                    }
                }
                if (is_("punc", ":")) {
                    ++BASELIB["eslice"];
                    next();
                    if (is_("punc", "]")) {
                        unexpected();
                    } else {
                        slice_bounds.push(expression(false));
                    }
                }
                expect("]");
                if (is_slice) {
                    if (is_("operator") && S.token.value === "=") {
                        next();
                        return subscripts(new ast.Slice({
                            start: start,
                            expression: expr,
                            property: slice_bounds[0] || new ast.Number({
                                value: 0
                            }),
                            property2: slice_bounds[1],
                            assignment: expression(true),
                            end: prev()
                        }), allow_calls);
                    } else if (slice_bounds.length === 3) {
                        slice_bounds.unshift(slice_bounds.pop());
                        if (!slice_bounds[slice_bounds.length-1]) {
                            slice_bounds.pop();
                            if (!slice_bounds[slice_bounds.length-1]) {
                                slice_bounds.pop();
                            }
                        } else if (!slice_bounds[slice_bounds.length-2]) {
                            slice_bounds[slice_bounds.length-2] = new ast.Undefined();
                        }
                        return subscripts(new ast.Call({
                            start: start,
                            expression: new ast.SymbolRef({
                                name: "eslice"
                            }),
                            args: [ expr ].concat(slice_bounds),
                            end: prev()
                        }), allow_calls);
                    } else {
                        slice_bounds = (function() {
                            var idx55, itr55 = _Iterable(slice_bounds), res = [], i;
                            for (idx55 = 0; idx55 < itr55.length; idx55++) {
                                i = itr55[idx55];
                                res.push(i === null ? new ast.Number({
                                    value: 0
                                }) : i);
                            }
                            return res;
                        })();
                        return subscripts(new ast.Call({
                            start: start,
                            expression: new ast.Dot({
                                start: start,
                                expression: expr,
                                property: "slice",
                                end: prev()
                            }),
                            args: slice_bounds,
                            end: prev()
                        }), allow_calls);
                    }
                } else {
                    return subscripts(new ast.Sub({
                        start: start,
                        expression: expr,
                        property: slice_bounds[0] || new ast.Number({
                            value: 0
                        }),
                        end: prev()
                    }), allow_calls);
                }
            }
            if (allow_calls && is_("punc", "(") && !S.token.newline_before) {
                next();
                if (expr instanceof ast.SymbolRef && expr.name === "JS") {
                    str_ = expression(false);
                    if (!(str_ instanceof ast.String)) {
                        token_error(prev(), "Compile-time function JS() can't evaluate variables or expressions");
                    }
                    ret = new ast.Verbatim({
                        start: start,
                        value: str_.value,
                        end: prev()
                    });
                    expect(")");
                    return subscripts(ret, true);
                } else if (!expr.parens && get_class_in_scope(expr)) {
                    if (_in(expr.name, STDLIB)) {
                        ++BASELIB[expr.name];
                        if (/Error$/.test(expr.name)) {
                            ++BASELIB["extends"];
                        }
                    }
                    return subscripts(new ast.New({
                        start: start,
                        expression: expr,
                        args: func_call_list(),
                        end: prev()
                    }), true);
                } else {
                    if (expr instanceof ast.Dot) {
                        className = get_class_in_scope(expr.expression);
                    }
                    if (className) {
                        funcname = expr;
                        if (funcname.property === "__init__") {
                            funcname.property = "constructor";
                        }
                        S.in_scope[S.in_scope.length-1].callsSuper = S.in_scope.length > 1 && S.in_scope[S.in_scope.length-2].type === "class" && expr.expression.name === S.in_scope[S.in_scope.length-2].parent;
                        return validateCallArgs(subscripts(new ast.ClassCall({
                            start: start,
                            class: expr.expression,
                            method: funcname.property,
                            super: S.in_scope[S.in_scope.length-1].callsSuper,
                            static: is_static_method(className, funcname.property),
                            args: func_call_list(),
                            end: prev()
                        }), true));
                    } else if (expr instanceof ast.SymbolRef) {
                        tmp_ = expr.name;
                        if (_in(tmp_, STDLIB)) {
                            ++BASELIB[tmp_];
                        } else if (tmp_ === "isinstance") {
                            args = func_call_list();
                            if (args.length !== 2) {
                                croak("'isinstance' takes exactly 2 arguments");
                            }
                            return new ast.Binary({
                                start: start,
                                operator: "instanceof",
                                left: args[0],
                                right: args[1],
                                end: prev()
                            });
                        } else if (tmp_ === "super") {
                            S.in_scope[S.in_scope.length-1].callsSuper = true;
                        } else if (_in(tmp_, tokenizer.JS_KEYWORDS)) {
                            expr.name += "_";
                        }
                    }
                    return validateCallArgs(subscripts(new ast.Call({
                        start: start,
                        expression: expr,
                        args: func_call_list(),
                        end: prev()
                    }), true));
                }
            }
            return expr;
        }
        function keepDecoratorOrImport(expr, imp) {
            imp = imp === void 0 ? false : imp;
            var name;
            if (imp) {
                if (!options.dropImports.length) {
                    return true;
                }
            } else {
                if (!options.dropDecorators.length) {
                    return true;
                }
            }
            function stringifyName(expr) {
                if (expr instanceof ast.Dot) {
                    return stringifyName(expr.expression) + "." + expr.property;
                }
                return expr.name;
            }
            if (typeof expr === "string") {
                name = expr;
            } else if (expr instanceof ast.SymbolRef) {
                name = expr.name;
            } else if (expr instanceof ast.Dot) {
                name = stringifyName(expr);
            } else if (expr instanceof ast.Call) {
                name = stringifyName(expr.expression);
            } else {
                croak("Unsupported decorator");
            }
            if (imp) {
                return !(_in(name, options.dropImports));
            } else {
                return !(_in(name, options.dropDecorators));
            }
        }
        function maybe_unary(allow_calls) {
            var start, expr, ex, val;
            start = S.token;
            if (is_("operator", "@")) {
                if (S.in_decorator) {
                    croak("Nested decorators are not allowed");
                }
                next();
                S.in_decorator = true;
                expr = expression(true);
                S.in_decorator = false;
                if (keepDecoratorOrImport(expr)) {
                    S.decorators.push(expr);
                }
                return new ast.EmptyStatement({
                    stype: "@",
                    start: prev(),
                    end: prev()
                });
            }
            if (is_("operator") && UNARY_PREFIX(start.value)) {
                next();
                ex = make_unary(ast.UnaryPrefix, start.value, maybe_unary(allow_calls));
                ex.start = start;
                ex.end = prev();
                return ex;
            }
            val = expr_atom(allow_calls);
            while (is_("operator") && tokenizer.UNARY_POSTFIX(S.token.value) && !S.token.newline_before) {
                val = make_unary(ast.UnaryPostfix, S.token.value, val);
                val.start = start;
                val.end = S.token;
                next();
            }
            return val;
        }
        function make_unary(ctor, op, expr) {
            return validateUnary(new ctor({
                operator: op,
                expression: expr
            }));
        }
        function validateBinary(astElement) {
            var left, right, op;
            left = astElement.left.resolveType(S.in_scope);
            right = astElement.right.resolveType(S.in_scope);
            op = astElement.operator;
            if (!(_in(op, [ "in", "instanceof", "==", "!=", "===", "!==", "||", "&&", "=" ])) && (!(_in(left, [ "Number", "String", "Boolean", "?" ])) || !(_in(right, [ "Number", "String", "Boolean", "?" ])) || left === "String" && !(_in(op, [ "+", "+=" ])) || right === "String" && !(_in(op, [ "+", "+=" ])))) {
                if (left) {
                    if (left[0] === "[") {
                        left = "Array";
                    } else if (left[0] === "{") {
                        left = "Object";
                    }
                }
                if (right) {
                    if (right[0] === "[") {
                        right = "Array";
                    } else if (right[0] === "{") {
                        right = "Object";
                    }
                }
                throw croak("cannot perform binary '" + op + "' operation on incompatbile elements of type " + left + " and " + right + "");
            }
            return astElement;
        }
        function validateUnary(astElement) {
            var element, op;
            element = astElement.expression.resolveType(S.in_scope);
            op = astElement.operator;
            if (!(_in(element, [ "Number", "?" ])) && _in(op, [ "+", "-" ]) || !(_in(element[0], [ "[", "{", "?" ])) && op === "*") {
                if (element[0] === "[") {
                    element = "Array";
                } else if (element[0] === "{") {
                    element = "Object";
                }
                throw croak("cannot perform unary '" + op + "' operation on incompatbile element of type " + element);
            }
            return astElement;
        }
        function validateCallArgs(astElement) {
            var itr56, idx56, itr57, idx57, itr58, idx58, itr59, idx59, upk5;
            var name, found, scope, func, signature, variable, args, i, arg, expected, actual;
            if (astElement.expression instanceof ast.SymbolRef) {
                name = astElement.expression.name;
                found = false;
                itr56 = _Iterable(reversed(S.in_scope));
                for (idx56 = 0; idx56 < itr56.length; idx56++) {
                    scope = itr56[idx56];
                    itr57 = _Iterable(scope.functions);
                    for (idx57 = 0; idx57 < itr57.length; idx57++) {
                        func = itr57[idx57];
                        if (func === name) {
                            signature = scope.functions[func];
                            found = true;
                            break;
                        }
                    }
                    itr58 = _Iterable(scope.vars);
                    for (idx58 = 0; idx58 < itr58.length; idx58++) {
                        variable = itr58[idx58];
                        if (variable === name) {
                            signature = scope.vars[func];
                            found = true;
                            break;
                        }
                    }
                    if (found) {
                        break;
                    }
                }
                if (signature && signature.slice(0, 9) === "Function(") {
                    args = /\((.*)\)/.exec(signature)[1].split(",");
                    if (args.length === 1 && !args[0].length) {
                        args.pop();
                    }
                    if (args.length < astElement.args.length) {
                        croak("Function '" + name + "' takes " + args.length + " arguments, yet your call contains " + astElement.args.length + "");
                    }
                    itr59 = _Iterable(enumerate(astElement.args));
                    for (idx59 = 0; idx59 < itr59.length; idx59++) {
                        upk5 = itr59[idx59];
                        i = upk5[0];
                        arg = upk5[1];
                        expected = args[i].trim();
                        actual = arg.resolveType(S.in_scope);
                        if (expected !== "?" && !(_in(actual, [ expected, "?" ]))) {
                            croak("Function '" + name + "' expects argument " + i + " type of " + expected + ", but you're passing " + actual + "");
                        }
                    }
                }
            }
            return astElement;
        }
        function expr_op(left, min_prec, no_in) {
            var op, not_in, prec, right, ret;
            op = is_("operator") ? S.token.value : null;
            not_in = false;
            if (op === "!" && peek().type === "operator" && peek().value === "in") {
                next();
                op = "in";
                not_in = true;
            }
            if (op === "in") {
                if (no_in) {
                    op = null;
                } else {
                    ++BASELIB[op];
                }
            }
            prec = op !== null ? tokenizer.PRECEDENCE[op] : null;
            if (prec !== null && prec > min_prec) {
                next();
                right = expr_op(maybe_unary(true), prec, no_in);
                if (_in(op, [ "==", "!=" ])) {
                    ++BASELIB["eq"];
                    ret = new ast.DeepEquality({
                        start: left.start,
                        left: left,
                        operator: op,
                        right: right,
                        end: right.end
                    });
                } else {
                    ret = new ast.Binary({
                        start: left.start,
                        left: left,
                        operator: op,
                        right: right,
                        end: right.end
                    });
                    validateBinary(ret);
                }
                if (not_in) {
                    ret = new ast.UnaryPrefix({
                        start: left.start,
                        operator: "!",
                        expression: ret,
                        end: right.end
                    });
                }
                return expr_op(ret, min_prec, no_in);
            }
            return left;
        }
        function expr_ops(no_in) {
            return expr_op(maybe_unary(true), 0, no_in);
        }
        function maybe_conditional(no_in) {
            var start, expr, yes;
            start = S.token;
            expr = expr_ops(no_in);
            if (is_("operator", "?")) {
                next();
                yes = expression(false);
                expect(":");
                return new ast.Conditional({
                    start: start,
                    condition: expr,
                    consequent: yes,
                    alternative: expression(false, no_in),
                    end: peek()
                });
            }
            return expr;
        }
        function isAssignable(expr) {
            var itr60, idx60;
            var element;
            if (expr instanceof ast.SymbolRef || expr instanceof ast.PropAccess) {
                return true;
            }
            if (expr instanceof ast.Array) {
                itr60 = _Iterable(expr.elements);
                for (idx60 = 0; idx60 < itr60.length; idx60++) {
                    element = itr60[idx60];
                    if (!isAssignable(element)) {
                        return false;
                    }
                }
                return true;
            }
            if (expr instanceof ast.Seq) {
                if (isAssignable(expr.car) && isAssignable(expr.cdr)) {
                    return true;
                }
            }
            return false;
        }
        function maybe_assign(no_in) {
            var start, left, val, right;
            start = S.token;
            left = maybe_conditional(no_in);
            val = S.token.value;
            if (is_("operator") && ASSIGNMENT(val)) {
                if (isAssignable(left)) {
                    if (left instanceof ast.SymbolRef && val !== "=" && !(_in(left.name, S.in_scope[S.in_scope.length-1].vars)) && (!S.in_scope[S.in_scope.length-1].args || !(_in(left.name, S.in_scope[S.in_scope.length-1].args))) && !(_in(left.name, S.in_scope[S.in_scope.length-1].nonlocal))) {
                        croak("Attempting to increment/modify uninitialized variable '" + left.name + "', this can also occur if you're trying to shadow without initializing the variable in local scope.");
                    }
                    next();
                    right = maybe_assign(no_in);
                    if (!S.in_seq) {
                        mark_local_assignment(left, right);
                    }
                    return validateBinary(new ast.Assign({
                        start: start,
                        left: left,
                        operator: val,
                        right: right,
                        end: prev()
                    }));
                }
                croak("Invalid assignment");
            }
            return left;
        }
        function expression(commas, no_in) {
            var itr61, idx61, upk6, itr62, idx62, upk7;
            var start, expr, left, leftAst, right, index, element, seq;
            start = S.token;
            expr = maybe_assign(no_in);
            if (commas) {
                left = [ expr ];
                while (is_("punc", ",") && !peek().newline_before) {
                    S.in_seq = true;
                    next();
                    if (expr instanceof ast.Assign) {
                        left[left.length-1] = left[left.length-1].left;
                        if (left.length === 1) {
                            if (left[0] instanceof ast.Seq) {
                                leftAst = seq_to_array(left[0]);
                            } else {
                                leftAst = left[0];
                            }
                        } else {
                            leftAst = new ast.Array({
                                elements: left
                            });
                        }
                        right = seq_to_array(new ast.Seq({
                            car: expr.right,
                            cdr: expression(true, no_in)
                        }));
                        itr61 = _Iterable(enumerate(leftAst.elements));
                        for (idx61 = 0; idx61 < itr61.length; idx61++) {
                            upk6 = itr61[idx61];
                            index = upk6[0];
                            element = upk6[1];
                            mark_local_assignment(element, right.elements[index]);
                        }
                        return new ast.Assign({
                            start: start,
                            left: leftAst,
                            operator: expr.operator,
                            right: right,
                            end: peek()
                        });
                    }
                    expr = maybe_assign(no_in);
                    left.push(expr);
                }
                S.in_seq = false;
                if (expr instanceof ast.Assign && expr.left instanceof ast.Seq) {
                    expr.left = seq_to_array(expr.left);
                }
                if (left.length > 1 && left[left.length-1] instanceof ast.Assign) {
                    left[left.length-1] = left[left.length-1].left;
                    itr62 = _Iterable(enumerate(left));
                    for (idx62 = 0; idx62 < itr62.length; idx62++) {
                        upk7 = itr62[idx62];
                        index = upk7[0];
                        element = upk7[1];
                        mark_local_assignment(element, expr.right instanceof ast.Array ? expr.right.elements[index] : null);
                    }
                    return new ast.Assign({
                        start: start,
                        left: new ast.Array({
                            elements: left
                        }),
                        operator: expr.operator,
                        right: expr.right,
                        end: peek()
                    });
                }
                seq = function build_seq(a) {
                    var itr63, idx63, upk8;
                    var first, index, element;
                    first = a.shift();
                    if (first instanceof ast.Assign) {
                        if (first.left instanceof ast.Array) {
                            itr63 = _Iterable(enumerate(first.left.elements));
                            for (idx63 = 0; idx63 < itr63.length; idx63++) {
                                upk8 = itr63[idx63];
                                index = upk8[0];
                                element = upk8[1];
                                mark_local_assignment(element, first.right instanceof ast.Array ? first.right.elements[index] : null);
                            }
                        }
                    }
                    if (!a.length) {
                        return first;
                    }
                    return new ast.Seq({
                        start: start,
                        car: first,
                        cdr: build_seq(a),
                        end: peek()
                    });
                }(left);
                return seq;
            }
            return expr;
        }
        function in_loop(cont) {
            var ret;
            ++S.in_loop;
            ret = cont();
            --S.in_loop;
            return ret;
        }
        return function() {
            var itr64, idx64;
            var start, body, docstring, first_token, element, shebang, end, toplevel, assignments, callables, item;
            start = S.token;
            body = [];
            docstring = null;
            first_token = true;
            while (!is_("eof")) {
                element = statement();
                if (first_token && element instanceof ast.Directive && element.value.indexOf("#!") === 0) {
                    shebang = element.value;
                } else if (!body.length && is_docstring(element)) {
                    if (!options.dropDocstrings) {
                        docstring = format_docstring(element.value);
                    }
                } else {
                    body.push(element);
                }
                first_token = false;
            }
            end = prev();
            toplevel = options.toplevel;
            if (toplevel) {
                toplevel.body = toplevel.body.concat(body);
                toplevel.end = end;
            } else {
                toplevel = new ast.TopLevel({
                    start: start,
                    body: body,
                    strict: true,
                    shebang: shebang,
                    docstring: docstring,
                    end: end
                });
            }
            function uniq(element, index, arr) {
                return arr.lastIndexOf(element) === index;
            }
            toplevel.nonlocalvars = Object.keys(S.in_scope[S.in_scope.length-1].nonlocal);
            assignments = Object.keys(S.in_scope[S.in_scope.length-1].vars);
            callables = scan_for_top_level_callables(toplevel.body).filter(uniq);
            toplevel.localvars = [];
            itr64 = _Iterable(assignments);
            for (idx64 = 0; idx64 < itr64.length; idx64++) {
                item = itr64[idx64];
                if (!(_in(item, toplevel.nonlocalvars))) {
                    toplevel.localvars.push(new_symbol(ast.SymbolVar, item));
                }
            }
            toplevel.exports = toplevel.localvars.concat(callables).filter(uniq);
            toplevel.submodules = [];
            toplevel.classes = CLASS_MAP;
            toplevel.import_order = Object.keys(IMPORTED).length;
            toplevel.module_id = module_id;
            IMPORTED[module_id] = toplevel;
            toplevel.imports = IMPORTED;
            toplevel.baselib = BASELIB;
            IMPORTING[module_id] = false;
            return toplevel;
        }();
    }
    _modules["parser"]["NATIVE_CLASSES"] = NATIVE_CLASSES;

    _modules["parser"]["COMMON_STATIC"] = COMMON_STATIC;

    _modules["parser"]["CLASS_MAP"] = CLASS_MAP;

    _modules["parser"]["key"] = key;

    _modules["parser"]["BASELIB"] = BASELIB;

    _modules["parser"]["STDLIB"] = STDLIB;

    _modules["parser"]["UNARY_PREFIX"] = UNARY_PREFIX;

    _modules["parser"]["ASSIGNMENT"] = ASSIGNMENT;

    _modules["parser"]["STATEMENTS_WITH_LABELS"] = STATEMENTS_WITH_LABELS;

    _modules["parser"]["ATOMIC_START_TOKEN"] = ATOMIC_START_TOKEN;

    _modules["parser"]["array_to_hash"] = array_to_hash;

    _modules["parser"]["has_simple_decorator"] = has_simple_decorator;

    _modules["parser"]["parse"] = parse;
})();

(function(){
    var __name__ = "_baselib";
    var BASELIB;
    BASELIB = '"""\n**********************************************************************\n\n  A RapydScript to JavaScript compiler.\n  https://github.com/atsepkov/RapydScript\n\n  -------------------------------- (C) ---------------------------------\n\n                       Author: Alexander Tsepkov\n                         <atsepkov@pyjeon.com>\n                         http://www.pyjeon.com\n\n  Distributed under BSD license:\n    Copyright 2013 (c) Alexander Tsepkov <atsepkov@pyjeon.com>\n\n **********************************************************************\n"""\n\n\n# for convenience we\'ll use a convention here that will work as follows:\n#\n#   if function is named, assume we\'ll be outputting the function itself\n#   if the given baselib chunk is triggered\n#\n#   if function is unnamed, assume the function is a container for the logic\n#   to be output. We\'re basically ignoring the wrapper and dumping what\'s inside\n\n{\n"abs": def abs(n):\n    return Math.abs(n)\n,\n"all": def all(a):\n    for e in a:\n        if not e: return False\n    return True\n,\n"any": def any(a):\n    for e in a:\n        if e: return True\n    return False\n,\n"bin": def bin(a): return \'0b\' + (a >>> 0).toString(2)\n,\n"bind": def _bind(fn, thisArg):\n    if fn.orig: fn = fn.orig\n    if thisArg is False: return fn\n    ret = def():\n        return fn.apply(thisArg, arguments)\n    ret.orig = fn\n    return ret\n,\n"rebind_all": def _rebindAll(thisArg, rebind):\n    if rebind is undefined: rebind = True\n    for JS(\'var p in thisArg\'):\n        if thisArg[p] and thisArg[p].orig:\n            if rebind: thisArg[p] = bind(thisArg[p], thisArg)\n            else: thisArg[p] = thisArg[p].orig\n,\n"cmp": def cmp(a, b): return a < b ? -1 : a > b ? 1 : 0\n,\n"chr": def(): chr = String.fromCharCode\n,\n"dir": def dir(item):\n    # TODO: this isn\'t really representative of real Python\'s dir(), nor is it\n    # an intuitive replacement for "for ... in" loop, need to update this logic\n    # and introduce a different way of achieving "for ... in"\n    arr = []\n    for JS(\'var i in item\'): arr.push(i)\n    return arr\n,\n"enumerate": def enumerate(item):\n    arr = []\n    iter = _Iterable(item)\n    for i in range(iter.length):\n        arr[arr.length] = [i, item[i]]\n    return arr\n,\n"eslice": def _eslice(arr, step, start, end):\n    arr = arr[:]\n    if JS(\'typeof arr\') is \'string\' or isinstance(arr, String):\n        isString = True\n        arr = arr.split(\'\')\n\n    if step < 0:\n        step = -step\n        arr.reverse()\n        if JS(\'typeof start\') is not "undefined": start = arr.length - start - 1\n        if JS(\'typeof end\') is not "undefined": end = arr.length - end - 1\n    if JS(\'typeof start\') is "undefined": start = 0\n    if JS(\'typeof end\') is "undefined": end = arr.length\n\n    arr = arr.slice(start, end).filter(def(e, i): return i % step is 0;)\n    return isString ? arr.join(\'\') : arr\n,\n"extends": def _extends(child, parent):\n    child.prototype = Object.create(parent.prototype)\n    child.prototype.__base__ = parent     # since we don\'t support multiple inheritance, __base__ seemed more appropriate than __bases__ array of 1\n    child.prototype.constructor = child\n,\n"filter": def filter(oper, arr):\n    return arr.filter(oper)\n,\n"hex": def hex(a): return \'0x\' + (a >>> 0).toString(16)\n,\n"in": def _in(val, arr):\n    if JS(\'typeof arr.indexOf\') is \'function\': return arr.indexOf(val) is not -1\n    return arr.hasOwnProperty(val)\n,\n"iterable": def _Iterable(iterable):\n    # can\'t use Symbol.iterator yet since it\'s not supported on all platforms until ES6 (i.e. mobile browsers don\'t have it)\n    if iterable.constructor is [].constructor\n    or iterable.constructor is \'\'.constructor\n    or (tmp = Array.prototype.slice.call(iterable)).length:\n        return tmp or iterable\n    return Object.keys(iterable)    # so we can use \'for ... in\' syntax with hashes\n,\n"len": def len(obj):\n    # can\'t use Symbol.iterator yet since it\'s not supported on all platforms until ES6 (i.e. mobile browsers don\'t have it)\n    if obj.constructor is [].constructor\n    or obj.constructor is \'\'.constructor\n    or (tmp = Array.prototype.slice.call(obj)).length:\n        return (tmp or obj).length\n    return Object.keys(obj).length\n,\n"map": def map(oper, arr):\n    return arr.map(oper)\n,\n"max": def max(a):\n    return Math.max.apply(null, Array.isArray(a) ? a : arguments)\n,\n"min": def min(a):\n    return Math.min.apply(null, Array.isArray(a) ? a : arguments)\n,\n"merge": def _merge(target, source, overwrite):\n    for JS(\'var i in source\'):\n        # instance variables\n        if source.hasOwnProperty(i) and (overwrite or JS(\'typeof target[i]\') is \'undefined\'): target[i] = source[i]\n    for prop in Object.getOwnPropertyNames(source.prototype):\n        # methods\n        if overwrite or JS(\'typeof target.prototype[prop]\') is \'undefined\': target.prototype[prop] = source.prototype[prop]\n,\n"mixin": def _mixin(*classes):\n    return def(baseClass):\n        for cls in classes:\n            for key in Object.getOwnPropertyNames(cls.prototype):\n                if key not in baseClass.prototype:\n                    baseClass.prototype[key] = cls.prototype[key]\n        return baseClass\n\n,\n"print": def _print():\n    if JS(\'typeof console\') is \'object\': console.log.apply(console, arguments)\n,\n"range": def range(start, stop, step):\n    if arguments.length <= 1:\n        stop = start or 0\n        start = 0\n    step = arguments[2] or 1\n\n    length = Math.max(Math.ceil((stop - start) / step), 0)\n    idx = 0\n    range = Array(length)\n\n    while idx < length:\n        range[JS(\'idx++\')] = start\n        start += step\n    return range\n,\n"reduce": def reduce(f, a): return Array.reduce(a, f)\n,\n"reversed": def reversed(arr):\n    tmp = arr[:]\n    return tmp.reverse()\n,\n"sorted": def sorted(arr):\n    tmp = arr[:]\n    return tmp.sort()\n,\n"sum": def sum(arr, start=0):\n    return arr.reduce(\n        def(prev, cur): return prev+cur\n        ,\n        start\n    )\n,\n"type": def _type(obj):\n    return obj and obj.constructor and obj.constructor.name ? obj.constructor.name : Object.prototype.toString.call(obj).slice(8, -1)\n,\n"zip": def zip(a, b):\n    return [[a[i], b[i]] for i in range(Math.min(a.length, b.length))]\n,\n"getattr": def getattr(obj, name):\n    return obj[name]\n,\n"setattr": def setattr(obj, name, value):\n    obj[name] = value\n,\n"hasattr": def hasattr(obj, name):\n    return JS(\'name in obj\')\n,\n"eq": def _eq(a, b):\n    """\n    Equality comparison that works with all data types, returns true if structure and\n    contents of first object equal to those of second object\n\n    Arguments:\n        a: first object\n        b: second object\n    """\n    if a is b:\n        # simple object\n        return True\n\n    if (Array.isArray(a) and Array.isArray(b)) or (isinstance(a, Object) and isinstance(b, Object)):\n        # if length ot type doesn\'t match, they can\'t be equal\n        if a.constructor is not b.constructor or a.length is not b.length:\n            return False\n\n        if Array.isArray(a):\n            # arrays\n            for i in range(a.length):\n                if not _eq(a[i], b[i]):\n                    return False\n        else:\n            # hashes\n            # compare individual properties (order doesn\'t matter if it\'s a hash)\n            if Object.keys(a).length is not Object.keys(b).length: return False\n            for i in a:\n                # recursively test equality of object children\n                if not _eq(a[i], b[i]):\n                    return False\n        return True\n    return False\n,\n"kwargs": def():\n    # WARNING: when using this function decorator, you will not be able to use obfuscators that rename local variables\n    def kwargs(f):\n        argNames = f.toString().match(/\\(([^\\)]+)/)[1]\n        if not kwargs.memo[argNames]:\n            kwargs.memo[argNames] = argNames ? argNames.split(\',\').map(def(s): return s.trim();) : []\n        argNames = kwargs.memo[argNames]\n        return def():\n            args = [].slice.call(arguments)\n            if args.length:\n                kw = args[-1]\n                if JS(\'typeof kw\') is \'object\':\n                    for i in range(argNames.length):\n                        if argNames[i] in kw:\n                            args[i] = kw[argNames[i]]\n                else:\n                    args.push(kw)\n\n            # This logic is very fragile and very subtle, it needs to work both in ES6 and ES5, don\'t try to optimize the\n            # apply away into *args because having it in this format ensures correct \'this\' context, otherwise the function\n            # ends up unbound. Similarly, the fallthrough to except handles class creation in ES6.\n            try:\n                return f.apply(this, args)\n            except as e:\n                if /Class constructor \\w+ cannot be invoked without \'new\'/.test(e):\n                    return new f(*args)\n                raise\n    kwargs.memo = {}\n,\n\n# Errors\n# temporarily implemented via a wrapper pattern since there is no mechanism for assigning\n# classes to dictionary keys yet\n"AssertionError": def():\n    class AssertionError(Error):\n        def __init__(self, message):\n            self.name = "AssertionError"\n            self.message = message\n,\n"IndexError": def():\n    class IndexError(Error):\n        def __init__(self, message):\n            self.name = "IndexError"\n            self.message = message\n,\n"KeyError": def():\n    class KeyError(Error):\n        def __init__(self, message):\n            self.name = "KeyError"\n            self.message = message\n,\n"TypeError": def():\n    class TypeError(Error):\n        def __init__(self, message):\n            self.name = "TypeError"\n            self.message = message\n,\n"ValueError": def():\n    class ValueError(Error):\n        def __init__(self, message):\n            self.name = "ValueError"\n            self.message = message\n,\n}\n';
    _modules["_baselib"]["BASELIB"] = BASELIB;
})();

(function(){
    var __name__ = "output";
    var makePredicate = _modules["utils"].makePredicate;
    var noop = _modules["utils"].noop;
    var defaults = _modules["utils"].defaults;
    var repeat_string = _modules["utils"].repeat_string;
    var RAPYD_PREFIX = _modules["utils"].RAPYD_PREFIX;
    
    var is_identifier_char = _modules["tokenizer"].is_identifier_char;
    var PRECEDENCE = _modules["tokenizer"].PRECEDENCE;
    
    var ast = _modules["ast"];
    
    var _baselib = _modules["_baselib"];
    
    var parser = _modules["parser"];
    
    function Stream(options) {
        var options, indentation, current_col, current_line, current_pos, BUFFERS, IMPORTED, might_need_space, might_need_semicolon, last, requireSemicolonChars, space, indent, with_indent, newline, semicolon, add_mapping, tmpIndex, stack, baselibCache;
        options = defaults(options, {
            indent_start: 0,
            indent_level: 4,
            quote_keys: false,
            space_colon: true,
            ascii_only: false,
            inline_script: false,
            width: 80,
            max_line_len: 32e3,
            es6: false,
            beautify: false,
            source_map: null,
            bracketize: false,
            semicolons: true,
            comments: false,
            preserve_line: false,
            omit_baselib: false,
            baselib: null,
            private_scope: true,
            auto_bind: false,
            write_name: true
        });
        indentation = 0;
        current_col = 0;
        current_line = 1;
        current_pos = 0;
        BUFFERS = [ {
            vars: [],
            output: "",
            baselib: {}
        } ];
        IMPORTED = {};
        function to_ascii(str_, identifier) {
            return str_.replace(/[\u0080-\uffff]/g, function(ch) {
                var code;
                code = ch.charCodeAt(0).toString(16);
                if (code.length <= 2 && !identifier) {
                    while (code.length < 2) {
                        code = "0" + code;
                    }
                    return "\\x" + code;
                } else {
                    while (code.length < 4) {
                        code = "0" + code;
                    }
                    return "\\u" + code;
                }
            });
        }
        function make_string(str_, quotes) {
            var dq, sq, str_;
            dq = 0;
            sq = 0;
            str_ = str_.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s) {
                var tmp_;
                tmp_ = s;
                if (tmp_ === "\\") {
                    return "\\\\";
                } else if (tmp_ === "\b") {
                    return "\\b";
                } else if (tmp_ === "\f") {
                    return "\\f";
                } else if (tmp_ === "\n") {
                    return "\\n";
                } else if (tmp_ === "\t") {
                    return "\\t";
                } else if (tmp_ === "\r") {
                    return "\\r";
                } else if (tmp_ === "\u2028") {
                    return "\\u2028";
                } else if (tmp_ === "\u2029") {
                    return "\\u2029";
                } else if (tmp_ === '"') {
                    ++dq;
                    return '"';
                } else if (tmp_ === "'") {
                    ++sq;
                    return "'";
                } else if (tmp_ === "\0") {
                    return "\\0";
                }
                return s;
            });
            if (options.ascii_only) {
                str_ = to_ascii(str_);
            }
            if (quotes) {
                if (dq > sq) {
                    return "'" + str_.replace(/\x27/g, "\\'") + "'";
                } else {
                    return '"' + str_.replace(/\x22/g, '\\"') + '"';
                }
            } else {
                return str_;
            }
        }
        function encode_string(str_, quotes) {
            var ret;
            ret = make_string(str_, quotes);
            if (options.inline_script) {
                ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
            }
            return ret;
        }
        function make_name(name) {
            var name;
            name = name.toString();
            if (options.ascii_only) {
                name = to_ascii(name, true);
            }
            return name;
        }
        function make_indent(back) {
            return repeat_string(" ", options.indent_start + indentation - back * options.indent_level);
        }
        might_need_space = false;
        might_need_semicolon = false;
        last = null;
        function last_char() {
            return last.charAt(last.length - 1);
        }
        function maybe_newline() {
            if (options.max_line_len && current_col > options.max_line_len) {
                print_("\n");
            }
        }
        requireSemicolonChars = makePredicate("( [ + * / - , .");
        function print_(str_) {
            var str_, ch, target_line, prev, a, n;
            str_ = String(str_);
            ch = str_.charAt(0);
            if (might_need_semicolon) {
                if ((!ch || !(_in(ch, ";}"))) && !/[;]$/.test(last)) {
                    if (options.semicolons || requireSemicolonChars(ch)) {
                        BUFFERS[BUFFERS.length-1].output += ";";
                        ++current_col;
                        ++current_pos;
                    } else {
                        BUFFERS[BUFFERS.length-1].output += "\n";
                        ++current_pos;
                        ++current_line;
                        current_col = 0;
                    }
                    if (!options.beautify) {
                        might_need_space = false;
                    }
                }
                might_need_semicolon = false;
                maybe_newline();
            }
            if (!options.beautify && options.preserve_line && stack[stack.length - 1]) {
                target_line = stack[stack.length - 1].start.line;
                while (current_line < target_line) {
                    BUFFERS[BUFFERS.length-1].output += "\n";
                    ++current_pos;
                    ++current_line;
                    current_col = 0;
                    might_need_space = false;
                }
            }
            if (might_need_space) {
                prev = last_char();
                if (is_identifier_char(prev) && (is_identifier_char(ch) || ch === "\\") || /^[\+\-\/]$/.test(ch) && ch === prev) {
                    BUFFERS[BUFFERS.length-1].output += " ";
                    ++current_col;
                    ++current_pos;
                }
                might_need_space = false;
            }
            a = str_.split(/\r?\n/);
            n = a.length - 1;
            current_line += n;
            if (n === 0) {
                current_col += a[n].length;
            } else {
                current_col = a[n].length;
            }
            current_pos += str_.length;
            last = str_;
            BUFFERS[BUFFERS.length-1].output += str_;
        }
        space = options.beautify ? function() {
            print_(" ");
        } : function() {
            might_need_space = true;
        };
        indent = options.beautify ? function(half) {
            if (options.beautify) {
                print_(make_indent(half ? .5 : 0));
            }
        } : noop;
        with_indent = options.beautify ? function(col, cont) {
            var col, save_indentation, ret;
            if (col === true) {
                col = next_indent();
            }
            save_indentation = indentation;
            indentation = col;
            ret = cont();
            indentation = save_indentation;
            return ret;
        } : function(col, cont) {
            return cont();
        };
        newline = options.beautify ? function() {
            print_("\n");
        } : noop;
        semicolon = options.beautify ? function() {
            print_(";");
        } : function() {
            might_need_semicolon = true;
        };
        function force_semicolon() {
            might_need_semicolon = false;
            print_(";");
        }
        function next_indent() {
            return indentation + options.indent_level;
        }
        function spaced() {
            var itr65, idx65, upk9;
            var i, x;
            itr65 = _Iterable(enumerate(arguments));
            for (idx65 = 0; idx65 < itr65.length; idx65++) {
                upk9 = itr65[idx65];
                i = upk9[0];
                x = upk9[1];
                if (i > 0) {
                    space();
                }
                if (x.print) {
                    x.print(this);
                } else {
                    print_(x);
                }
            }
        }
        function addProperty(prop, val) {
            return function(obj) {
                var output;
                output = this;
                output.print("Object.defineProperty(");
                output.print(obj);
                output.comma();
                output.print_string(prop);
                output.comma();
                output.with_block(function() {
                    output.indent();
                    output.print("value");
                    output.colon();
                    output.print_string(val);
                    output.newline();
                });
                output.print(")");
            };
        }
        function addProperties(subattr, props) {
            return function(obj) {
                var output;
                output = this;
                output.print("Object.defineProperties(");
                output.print(obj);
                if (subattr) {
                    output.print("." + subattr);
                }
                output.comma();
                output.with_block(function() {
                    Object.keys(props).forEach(function(key, i) {
                        if (i) {
                            output.print(",");
                            output.newline();
                        }
                        output.indent();
                        output.print(key);
                        output.colon();
                        output.with_block(function() {
                            var itr66, idx66;
                            var attr;
                            itr66 = _Iterable([ "enumerable", "writable" ]);
                            for (idx66 = 0; idx66 < itr66.length; idx66++) {
                                attr = itr66[idx66];
                                output.indent();
                                output.print(attr);
                                output.colon();
                                output.print("true");
                                output.comma();
                                output.newline();
                            }
                            output.indent();
                            output.print("value");
                            output.colon();
                            props[key](output);
                        });
                    });
                    output.newline();
                });
                output.print(")");
            };
        }
        function end_statement() {
            semicolon();
            newline();
        }
        function with_block(cont) {
            var ret;
            ret = null;
            print_("{");
            newline();
            with_indent(next_indent(), function() {
                ret = cont();
            });
            indent();
            print_("}");
            return ret;
        }
        function with_parens(cont) {
            var ret;
            print_("(");
            ret = cont();
            print_(")");
            return ret;
        }
        function with_square(cont) {
            var ret;
            print_("[");
            ret = cont();
            print_("]");
            return ret;
        }
        function comma() {
            print_(",");
            space();
        }
        function colon() {
            print_(":");
            if (options.space_colon) {
                space();
            }
        }
        add_mapping = options.source_map ? function(token, name) {
            try {
                if (token) {
                    options.source_map.add(token.file || "?", current_line, current_col, token.line, token.col, !name && token.type === "name" ? token.value : name);
                }
            } catch (_Exception) {
                var ex = _Exception;
                ast.Node.warn("Couldn't figure out mapping for {file}:{line},{col}  {cline},{ccol} [{name}]", {
                    file: token.file,
                    line: token.line,
                    col: token.col,
                    cline: current_line,
                    ccol: current_col,
                    name: name || ""
                });
            }
        } : noop;
        function get_() {
            var output, out;
            if (BUFFERS.len > 1) {
                throw new Error("Something went wrong, output generator didn't exit all of its scopes properly.");
            }
            output = this;
            if (BUFFERS[0].vars.length) {
                BUFFERS.unshift({
                    vars: [],
                    output: ""
                });
                endLocalBuffer();
            }
            out = BUFFERS[0].output;
            BUFFERS[0].output = "";
            if (options.private_scope) {
                output.with_parens(function() {
                    output.print("function()");
                    output.with_block(function() {
                        output.print('"use strict"');
                        output.end_statement();
                        output.print(out);
                    });
                });
                output.print("();");
                output.newline();
            } else {
                output.print(out);
            }
            return BUFFERS[BUFFERS.length-1].output;
        }
        function assign_var(name) {
            if (typeof name === "string") {
                print_(name);
            } else {
                name.print(this);
            }
            space();
            print_("=");
            space();
        }
        tmpIndex = {
            "itr": 0,
            "idx": 0,
            "upk": 0,
            "_": 0
        };
        function newTemp(subtype, buffer) {
            subtype = subtype === void 0 ? "_" : subtype;
            buffer = buffer === void 0 ? true : buffer;
            var tmp;
            ++tmpIndex[subtype];
            tmp = RAPYD_PREFIX + subtype + tmpIndex[subtype];
            if (buffer) {
                BUFFERS[BUFFERS.length-1].vars.push(tmp);
            }
            return tmp;
        }
        function prevTemp(subtype) {
            subtype = subtype === void 0 ? "_" : subtype;
            return RAPYD_PREFIX + subtype + tmpIndex[subtype];
        }
        function startLocalBuffer() {
            BUFFERS.push({
                vars: [],
                output: ""
            });
        }
        function endLocalBuffer(baselib) {
            baselib = baselib === void 0 ? false : baselib;
            var localBuffer;
            localBuffer = BUFFERS.pop();
            if (localBuffer.vars.length) {
                indent();
                print_("var ");
                localBuffer.vars.forEach(function(local, i) {
                    if (i) {
                        comma();
                    }
                    print_(local);
                });
                force_semicolon();
                newline();
            }
            if (baselib) {
                BUFFERS[BUFFERS.length-1].output = localBuffer.output + BUFFERS[BUFFERS.length-1].output;
            } else {
                BUFFERS[BUFFERS.length-1].output += localBuffer.output;
            }
        }
        stack = [];
        baselibCache = {};
        return {
            get: get_,
            toString: get_,
            indent: indent,
            indentation: function() {
                return indentation;
            },
            current_width: function() {
                return current_col - indentation;
            },
            should_break: function() {
                return options.width && this.current_width() >= options.width;
            },
            newline: newline,
            print: print_,
            space: space,
            comma: comma,
            colon: colon,
            last: function() {
                return last;
            },
            semicolon: semicolon,
            force_semicolon: force_semicolon,
            to_ascii: to_ascii,
            print_name: function(name) {
                print_(make_name(name));
            },
            print_string: function(str_, quotes) {
                quotes = quotes === void 0 ? true : quotes;
                print_(encode_string(str_, quotes));
            },
            next_indent: next_indent,
            with_indent: with_indent,
            with_block: with_block,
            with_parens: with_parens,
            spaced: spaced,
            end_statement: end_statement,
            addProperty: addProperty,
            startLocalBuffer: startLocalBuffer,
            endLocalBuffer: endLocalBuffer,
            addProperties: addProperties,
            with_square: with_square,
            add_mapping: add_mapping,
            assign: assign_var,
            print_baselib: function(key) {
                var itr67, idx67;
                var baselibAst, hash, data, item, key_, value;
                if (!options.omit_baselib) {
                    if (!Object.keys(baselibCache).length) {
                        baselibAst = parser.parse(_baselib.BASELIB, {
                            readfile: null,
                            dropDocstrings: true,
                            filename: "_baselib.pyj"
                        });
                        hash = baselibAst.body[baselibAst.body.length-1];
                        data = hash.body.properties;
                        itr67 = _Iterable(data);
                        for (idx67 = 0; idx67 < itr67.length; idx67++) {
                            item = itr67[idx67];
                            key_ = item.key.value;
                            value = item.value.name ? [ item.value ] : item.value.body;
                            baselibCache[key_] = splatBaselib(key_, value);
                        }
                    }
                    baselibCache[key].print(this);
                }
                return null;
            },
            import: function(key) {
                if (!IMPORTED.hasOwnProperty(key)) {
                    IMPORTED[key] = key;
                    return true;
                }
                return false;
            },
            is_main: function() {
                return BUFFERS.length === 1 && BUFFERS[BUFFERS.length-1].output.length === 0;
            },
            option: function(opt) {
                return options[opt];
            },
            line: function() {
                return current_line;
            },
            col: function() {
                return current_col;
            },
            pos: function() {
                return current_pos;
            },
            push_node: function(node) {
                stack.push(node);
            },
            pop_node: function() {
                return stack.pop();
            },
            stack: function() {
                return stack;
            },
            newTemp: newTemp,
            prevTemp: prevTemp,
            parent: function(n) {
                return stack[stack.length - 2 - (n || 0)];
            }
        };
    }
    (function() {
        var SPECIAL_METHODS, BASELIB, CREATION;
        SPECIAL_METHODS = {
            "bind": "_bind",
            "rebind_all": "_rebindAll",
            "bool": "!!",
            "float": "parseFloat",
            "int": "parseInt",
            "mixin": "_mixin",
            "merge": "_merge",
            "print": "_print",
            "eslice": "_eslice",
            "type": "_type"
        };
        function unify(output, assign) {
            var args = [].slice.call(arguments, 2);
            var args;
            args = args.filter(function(i) {
                return i !== null;
            });
            return function(baseFn) {
                if (args.length) {
                    return function() {
                        var tmp;
                        tmp = output.newTemp();
                        if (assign) {
                            output.assign(assign);
                        }
                        output.with_parens(function() {
                            var itr68, idx68;
                            var arg;
                            output.assign(tmp);
                            baseFn();
                            output.comma();
                            itr68 = _Iterable(args);
                            for (idx68 = 0; idx68 < itr68.length; idx68++) {
                                arg = itr68[idx68];
                                if (!(_in(arg, [ null, void 0 ]))) {
                                    arg.call(output, tmp);
                                    output.comma();
                                }
                            }
                            output.print(tmp);
                        });
                        if (assign) {
                            output.semicolon();
                        }
                    };
                } else {
                    return function() {
                        baseFn();
                    };
                }
            };
        }
        function DEFPRINT(nodetype, generator) {
            nodetype.prototype._codegen = generator;
        }
        ast.Node.prototype.print = function(stream, force_parens) {
            var self, generator;
            self = this;
            generator = self._codegen;
            stream.push_node(self);
            if (force_parens || self.needs_parens(stream)) {
                stream.with_parens(function() {
                    self.add_comments(stream);
                    self.add_source_map(stream);
                    generator(self, stream);
                });
            } else {
                self.add_comments(stream);
                self.add_source_map(stream);
                generator(self, stream);
            }
            stream.pop_node();
        };
        ast.Node.prototype.print_to_string = function(options) {
            var s;
            s = Stream(options);
            this.print(s);
            return s.get();
        };
        ast.Node.prototype.add_comments = function(output) {
            var itr69, idx69;
            var c, self, start, comments;
            c = output.option("comments");
            self = this;
            if (c) {
                start = self.start;
                if (start && !start._comments_dumped) {
                    start._comments_dumped = true;
                    comments = start.comments_before;
                    if (self instanceof ast.Exit && self.value && self.value.start.comments_before.length > 0) {
                        comments = (comments || []).concat(self.value.start.comments_before);
                        self.value.start.comments_before = [];
                    }
                    if (c.test) {
                        comments = comments.filter(function(comment) {
                            return c.test(comment.value);
                        });
                    } else if (typeof c === "function") {
                        comments = comments.filter(function(comment) {
                            return c(self, comment);
                        });
                    }
                    itr69 = _Iterable(comments);
                    for (idx69 = 0; idx69 < itr69.length; idx69++) {
                        c = itr69[idx69];
                        if (c.type === "comment:line") {
                            output.print("//" + c.value + "\n");
                            output.indent();
                        } else if (c.type === "comment:multiline") {
                            output.print("/*" + c.value + "*/");
                            if (start.newline_before) {
                                output.print("\n");
                                output.indent();
                            } else {
                                output.space();
                            }
                        }
                    }
                }
            }
        };
        function PARENS(nodetype, func) {
            nodetype.prototype.needs_parens = func;
        }
        PARENS(ast.Node, function() {
            return false;
        });
        PARENS(ast.Function, function(output) {
            return first_in_statement(output);
        });
        PARENS(ast.ObjectLiteral, function(output) {
            return first_in_statement(output);
        });
        PARENS(ast.Unary, function(output) {
            var p;
            p = output.parent();
            return p instanceof ast.PropAccess && p.expression === this;
        });
        PARENS(ast.Seq, function(output) {
            var p;
            p = output.parent();
            return p instanceof ast.Unary || p instanceof ast.VarDef || p instanceof ast.Dot || p instanceof ast.ObjectProperty || p instanceof ast.Conditional;
        });
        PARENS(ast.Range, function(output) {
            return false;
        });
        PARENS(ast.Binary, function(output) {
            var p, po, pp, so, sp;
            p = output.parent();
            if (p instanceof ast.BaseCall && p.expression === this) {
                return true;
            }
            if (p instanceof ast.Unary) {
                return true;
            }
            if (p instanceof ast.PropAccess && p.expression === this) {
                return true;
            }
            if (p instanceof ast.Binary) {
                po = p.operator;
                pp = PRECEDENCE[po];
                so = this.operator;
                sp = PRECEDENCE[so];
                if (pp > sp || pp === sp && this === p.right && !(so === po && (so === "*" || so === "&&" || so === "||"))) {
                    return true;
                }
            }
        });
        PARENS(ast.PropAccess, function(output) {
            var p;
            p = output.parent();
            if (p instanceof ast.New && p.expression === this) {
                try {
                    this.walk(new ast.TreeWalker(function(node) {
                        if (node instanceof ast.BaseCall) {
                            throw p;
                        }
                    }));
                } catch (_Exception) {
                    var ex = _Exception;
                    if (ex !== p) {
                        throw ex;
                    }
                    return true;
                }
            }
        });
        PARENS(ast.BaseCall, function(output) {
            var p;
            p = output.parent();
            return p instanceof ast.New && p.expression === this;
        });
        PARENS(ast.New, function(output) {
            var p;
            p = output.parent();
            if (no_constructor_parens(this, output) && (p instanceof ast.PropAccess || p instanceof ast.BaseCall && p.expression === this)) {
                return true;
            }
        });
        PARENS(ast.Number, function(output) {
            var p;
            p = output.parent();
            if (this.getValue() < 0 && p instanceof ast.PropAccess && p.expression === this) {
                return true;
            }
        });
        PARENS(ast.NotANumber, function(output) {
            var p;
            p = output.parent();
            if (p instanceof ast.PropAccess && p.expression === this) {
                return true;
            }
        });
        function assign_and_conditional_paren_rules(output) {
            var p;
            p = output.parent();
            if (p instanceof ast.Unary) {
                return true;
            }
            if (p instanceof ast.Binary && !(p instanceof ast.Assign)) {
                return true;
            }
            if (p instanceof ast.BaseCall && p.expression === this) {
                return true;
            }
            if (p instanceof ast.Conditional && p.condition === this) {
                return true;
            }
            if (p instanceof ast.PropAccess && p.expression === this) {
                return true;
            }
        }
        PARENS(ast.Assign, assign_and_conditional_paren_rules);
        PARENS(ast.Conditional, assign_and_conditional_paren_rules);
        DEFPRINT(ast.Directive, function(self, output) {
            output.print_string(self.value);
            output.semicolon();
        });
        DEFPRINT(ast.Debugger, function(self, output) {
            output.print("debugger");
            output.semicolon();
        });
        function display_body(body, is_toplevel, output) {
            var last;
            last = body.length - 1;
            body.forEach(function(stmt, i) {
                if (!(stmt instanceof ast.EmptyStatement) && !(stmt instanceof ast.Definitions)) {
                    output.indent();
                    stmt.print(output);
                    if (!(i === last && is_toplevel)) {
                        output.newline();
                    }
                }
            });
        }
        function bind_methods(methods, output) {
            var arg;
            for (arg in methods) {
                output.indent();
                output.print("this.");
                output.assign(arg);
                output.print("_bind");
                output.with_parens(function() {
                    output.print("this." + arg);
                    output.comma();
                    output.print("this");
                });
                output.end_statement();
            }
        }
        function write_imports(module_, output) {
            var itr70, idx70, itr71, idx71, itr72, idx72, itr73, idx73, itr74, idx74;
            var imports, import_id, nonlocalvars, module_, name;
            imports = [];
            itr70 = _Iterable(Object.keys(module_.imports));
            for (idx70 = 0; idx70 < itr70.length; idx70++) {
                import_id = itr70[idx70];
                imports.push(module_.imports[import_id]);
            }
            imports.sort(function(a, b) {
                var upk10;
                var a, b;
                upk10 = [ a.import_order, b.import_order ];
                a = upk10[0];
                b = upk10[1];
                return a < b ? -1 : a > b ? 1 : 0;
            });
            if (imports.length > 1) {
                output.indent();
                output.spaced("var _modules", "=", "{};");
                output.newline();
            }
            nonlocalvars = {};
            itr71 = _Iterable(imports);
            for (idx71 = 0; idx71 < itr71.length; idx71++) {
                module_ = itr71[idx71];
                itr72 = _Iterable(module_.nonlocalvars);
                for (idx72 = 0; idx72 < itr72.length; idx72++) {
                    name = itr72[idx72];
                    nonlocalvars[name] = true;
                }
            }
            nonlocalvars = Object.getOwnPropertyNames(nonlocalvars).join(", ");
            if (nonlocalvars.length) {
                output.indent();
                output.print("var " + nonlocalvars);
                output.end_statement();
            }
            itr73 = _Iterable(imports);
            for (idx73 = 0; idx73 < itr73.length; idx73++) {
                module_ = itr73[idx73];
                if (module_.module_id !== "__main__") {
                    output.indent();
                    output.assign('_modules["' + module_.module_id + '"]');
                    output.print("{}");
                    output.end_statement();
                }
            }
            itr74 = _Iterable(imports);
            for (idx74 = 0; idx74 < itr74.length; idx74++) {
                module_ = itr74[idx74];
                if (module_.module_id !== "__main__") {
                    print_module(module_, output);
                }
            }
        }
        function write_main_name(output) {
            if (output.option("write_name")) {
                output.newline();
                output.indent();
                output.spaced("var __name__", "=", '"__main__"');
                output.end_statement();
            }
        }
        function display_complex_body(node, is_toplevel, output) {
            var offset, needsSuper, delaySelfAssignment, arg;
            output.startLocalBuffer();
            offset = 0;
            needsSuper = false;
            delaySelfAssignment = false;
            if (output.option("es6") && node instanceof ast.Constructor && node.parent) {
                if (node.callsSuper) {
                    delaySelfAssignment = true;
                } else {
                    needsSuper = true;
                }
            }
            if (node instanceof ast.Method && !node.static && !delaySelfAssignment) {
                if (needsSuper) {
                    output.indent();
                    output.print("super()");
                    output.end_statement();
                }
                output.indent();
                output.spaced("var", node.argnames[0], "=", "this");
                output.end_statement();
                ++offset;
            }
            if (node instanceof ast.Scope) {
                if (node.argnames) {
                    if (node.argnames.starargs) {
                        output.indent();
                        output.spaced("var", node.argnames.starargs, "=", "[].slice.call");
                        output.with_parens(function() {
                            output.print("arguments");
                            output.comma();
                            output.print(node.argnames.length - offset);
                        });
                        output.end_statement();
                    }
                    if (!output.option("es6")) {
                        for (arg in node.argnames.defaults) {
                            output.indent();
                            output.spaced(arg, "=", arg, "===", "void 0", "?");
                            output.space();
                            force_statement(node.argnames.defaults[arg], output);
                            output.space();
                            output.colon();
                            output.print(arg);
                            output.end_statement();
                        }
                    }
                }
                if (output.option("auto_bind") && node.name && node.name.name === "__init__") {
                    output.indent();
                    output.print("_rebindAll");
                    output.with_parens(function() {
                        output.print("this");
                        output.comma();
                        output.print("true");
                    });
                    output.end_statement();
                    bind_methods(node.bound, output);
                }
                declare_vars(node.localvars, output);
            } else if (node instanceof ast.Except) {
                if (node.argname) {
                    output.indent();
                    output.print("var ");
                    output.assign(node.argname);
                    output.print("_Exception");
                    output.end_statement();
                }
            }
            display_body(node.body, is_toplevel, output);
            output.endLocalBuffer();
        }
        function declare_vars(vars, output) {
            if (vars.length) {
                output.indent();
                output.print("var ");
                vars.forEach(function(arg, i) {
                    if (i) {
                        output.comma();
                    }
                    arg.print(output);
                });
                output.end_statement();
            }
        }
        function declare_exports(module_id, exports, submodules, output) {
            var itr75, idx75, itr76, idx76;
            var seen, symbol, sub_module_id, key;
            seen = {};
            itr75 = _Iterable(exports);
            for (idx75 = 0; idx75 < itr75.length; idx75++) {
                symbol = itr75[idx75];
                output.newline();
                output.indent();
                output.print('_modules["' + module_id + '"]["' + symbol.name + '"] = ' + symbol.name);
                seen[symbol.name] = true;
                output.end_statement();
            }
            itr76 = _Iterable(submodules);
            for (idx76 = 0; idx76 < itr76.length; idx76++) {
                sub_module_id = itr76[idx76];
                if (!seen.hasOwnProperty(module_id)) {
                    key = sub_module_id.split(".")[sub_module_id.split(".").length-1];
                    output.newline();
                    output.indent();
                    output.print('_modules["' + module_id + '"]["' + key + '"] = ');
                    output.print('_modules["' + sub_module_id + '"]');
                    output.end_statement();
                }
            }
        }
        function unpack_tuple(tuple, output, in_statement) {
            tuple.elements.forEach(function(elem, i) {
                output.indent();
                output.assign(elem);
                output.print(output.prevTemp("upk"));
                output.with_square(function() {
                    output.print(i);
                });
                if (!in_statement || i < tuple.elements.length - 1) {
                    output.end_statement();
                }
            });
        }
        function cacheBubble(operand, output) {
            var tmp;
            if (!(operand instanceof ast.SymbolRef || operand instanceof ast.SymbolClassRef)) {
                tmp = output.newTemp();
                output.with_parens(function() {
                    output.spaced(tmp, "=", operand);
                });
                return {
                    print: function(output) {
                        output.print(tmp);
                    }
                };
            }
            operand.print(output);
            return operand;
        }
        ast.StatementWithBody.prototype._do_print_body = function(output) {
            force_statement(this.body, output);
        };
        DEFPRINT(ast.Statement, function(self, output) {
            self.body.print(output);
            output.semicolon();
        });
        BASELIB = {};
        DEFPRINT(ast.TopLevel, function(self, output) {
            var is_main;
            is_main = output.is_main();
            BASELIB = self.baselib;
            if (output.option("private_scope") && is_main) {
                write_imports(self, output);
                output.newline();
                output.with_parens(function() {
                    output.print("function()");
                    output.with_block(function() {
                        write_main_name(output);
                        output.newline();
                        display_complex_body(self, true, output);
                        output.newline();
                    });
                });
                output.print("();");
                output.newline();
            } else {
                if (is_main) {
                    write_imports(self, output);
                    write_main_name(output);
                }
                if (self.strict) {
                    declare_vars(self.localvars, output);
                }
                display_body(self.body, true, output);
            }
            if (is_main) {
                output.startLocalBuffer();
                Object.keys(BASELIB).filter(function(a) {
                    return self.baselib[a] > 0;
                }).forEach(function(key) {
                    output.print_baselib(key);
                });
                output.endLocalBuffer(true);
            }
        });
        function print_module(self, output) {
            output.newline();
            output.indent();
            output.with_parens(function() {
                output.print("function()");
                output.with_block(function() {
                    output.indent();
                    output.assign("var __name__");
                    output.print('"' + self.module_id + '"');
                    output.end_statement();
                    declare_vars(self.localvars, output);
                    display_body(self.body, true, output);
                    declare_exports(self.module_id, self.exports, self.submodules, output);
                });
            });
            output.print("()");
            output.end_statement();
        }
        DEFPRINT(ast.Splat, function(self, output) {
            if (output.import(self.module.name)) {
                display_body(self.body.body, true, output);
                output.newline();
            }
        });
        DEFPRINT(ast.Imports, function(container, output) {
            var itr77, idx77, itr78, idx78;
            var self, argname, alias, bound_name;
            function add_aname(aname, key, from_import) {
                output.assign("var " + aname);
                output.print('_modules["' + key + '"]');
                if (from_import) {
                    output.print("." + from_import);
                }
                output.end_statement();
                output.indent();
            }
            itr77 = _Iterable(container.imports);
            for (idx77 = 0; idx77 < itr77.length; idx77++) {
                self = itr77[idx77];
                output.import(self.module.name);
                if (self.argnames) {
                    itr78 = _Iterable(self.argnames);
                    for (idx78 = 0; idx78 < itr78.length; idx78++) {
                        argname = itr78[idx78];
                        alias = argname.alias ? argname.alias.name : argname.name;
                        add_aname(alias, self.key, argname.name);
                    }
                } else {
                    if (self.alias) {
                        add_aname(self.alias.name, self.key, false);
                    } else {
                        bound_name = self.key.split(".", 1)[0];
                        add_aname(bound_name, bound_name, false);
                    }
                }
            }
        });
        DEFPRINT(ast.LabeledStatement, function(self, output) {
            self.label.print(output);
            output.colon();
            self.body.print(output);
        });
        DEFPRINT(ast.SimpleStatement, function(self, output) {
            if (!(self.body instanceof ast.EmptyStatement)) {
                self.body.print(output);
                output.semicolon();
            }
        });
        function print_bracketed(node, output, complex) {
            if (node.body.length) {
                output.with_block(function() {
                    if (complex) {
                        display_complex_body(node, false, output);
                    } else {
                        display_body(node.body, false, output);
                    }
                });
            } else {
                output.print("{}");
            }
        }
        DEFPRINT(ast.BlockStatement, function(self, output) {
            print_bracketed(self, output);
        });
        DEFPRINT(ast.EmptyStatement, function(self, output) {
        });
        DEFPRINT(ast.Do, function(self, output) {
            output.print("do");
            output.space();
            self._do_print_body(output);
            output.space();
            output.print("while");
            output.space();
            output.with_parens(function() {
                self.condition.print(output);
            });
            output.semicolon();
        });
        DEFPRINT(ast.While, function(self, output) {
            output.print("while");
            output.space();
            output.with_parens(function() {
                self.condition.print(output);
            });
            output.space();
            self._do_print_body(output);
        });
        function is_simple_for_in(self) {
            if (self.object instanceof ast.BaseCall && self.object.expression instanceof ast.SymbolRef && self.object.expression.name === "dir" && self.object.args.length === 1) {
                return true;
            }
            return false;
        }
        function is_simple_for(self) {
            if (self.object instanceof ast.BaseCall && self.object.expression instanceof ast.SymbolRef && self.object.expression.name === "range" && !(self.init instanceof ast.Array) && (self.object.args.length < 3 || self.object.args[self.object.args.length-1][0] instanceof ast.Number || self.object.args[self.object.args.length-1][0] instanceof ast.Unary && self.object.args[self.object.args.length-1][0].operator === "-" && self.object.args[self.object.args.length-1][0].expression instanceof ast.Number)) {
                return true;
            }
            return false;
        }
        ast.ForIn.prototype._do_print_body = function(output) {
            var self;
            self = this;
            output.with_block(function() {
                var iterator, index, unpack;
                if (!(is_simple_for(self) || is_simple_for_in(self))) {
                    output.indent();
                    iterator = output.prevTemp("itr");
                    index = output.prevTemp("idx");
                    if (self.init instanceof ast.Array) {
                        if (output.option("es6")) {
                            output.with_square(function() {
                                self.init.elements.forEach(function(element, index) {
                                    if (index) output.comma();
                                    element.print(output);
                                });
                            });
                            output.space();
                            output.print("=");
                            output.space();
                            output.print(iterator + "[" + index + "];");
                            output.newline();
                        } else {
                            unpack = output.newTemp("upk");
                            output.assign(unpack);
                            output.print(iterator + "[" + index + "];");
                            output.newline();
                            unpack_tuple(self.init, output);
                        }
                    } else {
                        output.assign(self.init);
                        output.print(iterator + "[" + index + "];");
                        output.newline();
                    }
                }
                self.body.body.forEach(function(stmt, i) {
                    output.indent();
                    stmt.print(output);
                    output.newline();
                });
            });
        };
        DEFPRINT(ast.ForIn, function(self, output) {
            var increment, args, tmp_, start, end, iterator;
            if (is_simple_for(self)) {
                increment = null;
                args = self.object.args;
                tmp_ = args.length;
                if (tmp_ === 1) {
                    start = 0;
                    end = args[0];
                } else if (tmp_ === 2) {
                    start = args[0];
                    end = args[1];
                } else if (tmp_ === 3) {
                    start = args[0];
                    end = args[1];
                    increment = args[2];
                }
                output.print("for");
                output.space();
                output.with_parens(function() {
                    output.assign(self.init);
                    start.print ? start.print(output) : output.print(start);
                    output.semicolon();
                    output.space();
                    self.init.print(output);
                    output.space();
                    increment instanceof ast.Unary ? output.print(">") : output.print("<");
                    output.space();
                    end.print(output);
                    output.semicolon();
                    output.space();
                    self.init.print(output);
                    if (increment && (!(increment instanceof ast.Unary) || increment.expression.value !== "1")) {
                        if (increment instanceof ast.Unary) {
                            output.print("-=");
                            increment.expression.print(output);
                        } else {
                            output.print("+=");
                            increment.print(output);
                        }
                    } else {
                        if (increment instanceof ast.Unary) {
                            output.print("--");
                        } else {
                            output.print("++");
                        }
                    }
                });
            } else if (is_simple_for_in(self)) {
                output.print("for");
                output.space();
                output.with_parens(function() {
                    output.spaced(self.init, "in", self.object.args[0]);
                });
            } else {
                iterator = output.newTemp("itr");
                output.assign(iterator);
                output.print("_Iterable");
                output.with_parens(function() {
                    self.object.print(output);
                });
                output.end_statement();
                output.indent();
                output.print("for");
                output.space();
                output.with_parens(function() {
                    var index;
                    index = output.newTemp("idx");
                    output.assign(index);
                    output.print("0");
                    output.semicolon();
                    output.space();
                    output.spaced(index, "<", iterator + ".length");
                    output.semicolon();
                    output.space();
                    output.print(index + "++");
                });
            }
            output.space();
            self._do_print_body(output);
        });
        ast.ForJS.prototype._do_print_body = function(output) {
            var self;
            self = this;
            output.with_block(function() {
                self.body.body.forEach(function(stmt, i) {
                    output.indent();
                    stmt.print(output);
                    output.newline();
                });
            });
        };
        DEFPRINT(ast.ForJS, function(self, output) {
            output.print("for");
            output.space();
            output.with_parens(function() {
                self.condition.print(output);
            });
            output.space();
            self._do_print_body(output);
        });
        DEFPRINT(ast.ListComprehension, function(self, output) {
            var constructor, iterator, index, result, add_entry;
            constructor = {
                ListComprehension: "[]",
                DictComprehension: "{}"
            }[_type(self)];
            iterator = output.newTemp("itr", false);
            index = output.newTemp("idx", false);
            result = RAPYD_PREFIX + "res";
            if (self instanceof ast.DictComprehension) {
                add_entry = function() {
                    output.indent();
                    output.print(result);
                    output.with_square(function() {
                        self.statement.print(output);
                    });
                    output.assign("");
                    self.value_statement.print(output);
                    output.end_statement();
                };
            } else {
                add_entry = function() {
                    output.indent();
                    output.print(result + ".push");
                    output.with_parens(function() {
                        self.statement.print(output);
                    });
                    output.end_statement();
                };
            }
            output.with_parens(function() {
                output.print("function");
                output.print("()");
                output.space();
                output.with_block(function() {
                    output.indent();
                    output.print("var " + index);
                    output.comma();
                    output.assign(iterator);
                    output.print("_Iterable");
                    output.with_parens(function() {
                        self.object.print(output);
                    });
                    output.comma();
                    output.assign(result);
                    output.print(constructor);
                    if (self.init instanceof ast.Array) {
                        self.init.elements.forEach(function(i) {
                            output.comma();
                            i.print(output);
                        });
                    } else {
                        output.comma();
                        self.init.print(output);
                    }
                    output.semicolon();
                    output.newline();
                    output.indent();
                    output.print("for");
                    output.space();
                    output.with_parens(function() {
                        output.spaced(index, "=", "0");
                        output.semicolon();
                        output.space();
                        output.spaced(index, "<", iterator + ".length");
                        output.semicolon();
                        output.space();
                        output.print(index + "++");
                    });
                    output.space();
                    output.with_block(function() {
                        output.indent();
                        if (self.init instanceof ast.Array) {
                            if (output.option("es6")) {
                                output.with_square(function() {
                                    self.init.elements.forEach(function(element, index) {
                                        if (index) output.comma();
                                        element.print(output);
                                    });
                                });
                                output.space();
                                output.print("=");
                                output.space();
                            } else {
                                output.assign(output.newTemp("upk"));
                            }
                            output.print(iterator + "[" + index + "];");
                            output.newline();
                            if (!output.option("es6")) {
                                unpack_tuple(self.init, output);
                            }
                        } else {
                            output.assign(self.init);
                            output.print(iterator + "[" + index + "];");
                            output.newline();
                        }
                        if (self.condition) {
                            output.indent();
                            output.print("if");
                            output.space();
                            output.with_parens(function() {
                                self.condition.print(output);
                            });
                            output.space();
                            output.with_block(function() {
                                add_entry();
                            });
                            output.newline();
                        } else {
                            add_entry();
                        }
                    });
                    output.newline();
                    output.indent();
                    output.print("return " + result);
                    output.end_statement();
                });
            });
            output.print("()");
        });
        DEFPRINT(ast.With, function(self, output) {
            output.print("with");
            output.space();
            output.with_parens(function() {
                self.expression.print(output);
            });
            output.space();
            self._do_print_body(output);
        });
        function decorate(decorators, output, internalsub) {
            var pos, wrap;
            pos = 0;
            wrap = function() {
                if (pos < decorators.length) {
                    decorators[pos].expression.print(output);
                    ++pos;
                    output.with_parens(function() {
                        wrap();
                    });
                } else {
                    internalsub();
                }
            };
            wrap();
        }
        function decorated(decorators, output) {
            return function(baseFn) {
                return function() {
                    decorate(decorators, output, baseFn);
                };
            };
        }
        ast.Lambda.prototype._do_print = function(output, nokeyword) {
            var _121;
            var self, name;
            self = this;
            function addDecorators() {
                if (self.decorators && self.decorators.length) {
                    return function(obj) {
                        var output;
                        output = this;
                        output.assign(obj);
                        decorate(self.decorators, output, function() {
                            output.print(obj);
                        });
                    };
                }
                return null;
            }
            function addDocstring() {
                if (self.docstring) {
                    return function(obj) {
                        var output;
                        output = this;
                        output.addProperty("__doc__", self.docstring).call(output, obj);
                    };
                }
                return null;
            }
            name = null;
            if (self.name) {
                name = "var " + self.name.name;
            }
            
            var internalsub = (_121 = function internalsub() {
                if (!nokeyword) {
                    output.print("function");
                    if (self.generator) {
                        output.print("*");
                    }
                }
                if (self.name) {
                    output.space();
                    self.name.print(output);
                }
                output.with_parens(function() {
                    self.argnames.forEach(function(arg, i) {
                        if (i) {
                            output.comma();
                        }
                        arg.print(output);
                        if (output.option("es6") && self.argnames.defaults[arg.name]) {
                            output.print("=");
                            self.argnames.defaults[arg.name].print(output);
                        }
                    });
                    if (self.kwargs) {
                        if (self.argnames.length) {
                            output.comma();
                        }
                        output.print("_kw");
                    }
                });
                output.space();
                print_bracketed(self, output, true);
            }, _121 = unify(output, name, addDecorators(), addDocstring())(_121), _121);
            internalsub();
        };
        DEFPRINT(ast.Lambda, function(self, output) {
            self._do_print(output);
        });
        ast.Class.prototype._do_print = function(output) {
            var self, name, generateClass;
            self = this;
            if (self.external) {
                return;
            }
            function addDecorators() {
                if (self.decorators && self.decorators.length) {
                    return function(obj) {
                        var itr79, idx79;
                        var output, stmt, funcName;
                        output = this;
                        output.assign(obj);
                        decorate(self.decorators, output, function() {
                            output.print(obj);
                        });
                        if (output.option("es6")) {
                            itr79 = _Iterable(self.body);
                            for (idx79 = 0; idx79 < itr79.length; idx79++) {
                                stmt = itr79[idx79];
                                if (stmt instanceof ast.Lambda && stmt.decorators && stmt.decorators.length) {
                                    funcName = obj + ".prototype." + stmt.name.name;
                                    output.comma();
                                    output.assign(funcName);
                                    decorate(stmt.decorators, output, function() {
                                        output.print(funcName);
                                    });
                                }
                            }
                        }
                    };
                }
                return null;
            }
            name = null;
            if (self.name) {
                name = "var " + self.name.name;
            }
            function outputEs6() {
                var _122;
                function addClassVariables() {
                    var properties;
                    properties = {};
                    if (self.docstring) {
                        properties["__doc__"] = function(output) {
                            output.print_string(self.docstring);
                        };
                    }
                    self.body.forEach(function(stmt, i) {
                        if (stmt instanceof ast.SimpleStatement && stmt.body instanceof ast.Assign && stmt.body.operator === "=") {
                            properties[stmt.body.left.name] = function(output) {
                                stmt.body.right.print(output);
                                output.newline();
                            };
                        }
                    });
                    if (Object.keys(properties).length) {
                        return output.addProperties("prototype", properties);
                    }
                    return null;
                }
                
                var generateClass = (_122 = function generateClass() {
                    output.print("class");
                    if (self.name) {
                        output.space();
                        self.name.print(output);
                    }
                    if (self.parent) {
                        output.space();
                        output.print("extends");
                        output.space();
                        self.parent.print(output);
                    }
                    output.space();
                    output.with_block(function() {
                        self.body.forEach(function(stmt, i) {
                            if (stmt instanceof ast.Lambda) {
                                output.indent();
                                if (stmt.static) {
                                    output.print("static");
                                    output.space();
                                }
                                if (stmt.name.name === "__init__") {
                                    output.print("constructor");
                                } else {
                                    if (stmt instanceof ast.ObjectGetter) {
                                        output.print("get ");
                                    } else if (stmt instanceof ast.ObjectSetter) {
                                        output.print("set ");
                                    }
                                    stmt.name.print(output);
                                }
                                output.space();
                                output.with_parens(function() {
                                    stmt.argnames.forEach(function(arg, i) {
                                        var i;
                                        if (_in(name, self.static)) {
                                            ++i;
                                        }
                                        if (i > 1) {
                                            output.comma();
                                        }
                                        if (i) {
                                            arg.print(output);
                                        }
                                        if (stmt.argnames.defaults[arg.name]) {
                                            output.print("=");
                                            stmt.argnames.defaults[arg.name].print(output);
                                        }
                                    });
                                    if (self.kwargs) {
                                        if (self.argnames.length) {
                                            output.comma();
                                        }
                                        output.print("_kw");
                                    }
                                });
                                output.space();
                                print_bracketed(stmt, output, true);
                                output.newline();
                            }
                        });
                    });
                }, _122 = unify(output, name, addDecorators(), addClassVariables())(_122), _122);
                return generateClass;
            }
            function outputEs5() {
                var upk11, _123;
                var methodsAndVars, staticmethods;
                function define_method(stmt) {
                    return function(output) {
                        var name;
                        name = stmt.name.name;
                        function internalsub() {
                            output.print("function");
                            output.space();
                            output.print(name);
                            output.with_parens(function() {
                                stmt.argnames.forEach(function(arg, i) {
                                    var i;
                                    if (_in(name, self.static)) {
                                        ++i;
                                    }
                                    if (i > 1) {
                                        output.comma();
                                    }
                                    if (i) {
                                        arg.print(output);
                                    }
                                });
                                if (self.kwargs) {
                                    if (self.argnames.length) {
                                        output.comma();
                                    }
                                    output.print("_kw");
                                }
                            });
                            print_bracketed(stmt, output, true);
                        }
                        if (stmt.decorators && stmt.decorators.length) {
                            decorate(stmt.decorators, output, internalsub);
                        } else {
                            internalsub();
                        }
                        output.newline();
                    };
                }
                function addInheritance() {
                    if (self.parent) {
                        return function(obj) {
                            var output;
                            output = this;
                            output.print("_extends");
                            output.with_parens(function() {
                                output.print(obj);
                                output.comma();
                                self.parent.print(output);
                            });
                        };
                    }
                    return null;
                }
                function addMethods() {
                    var methodsAndVars, staticMethods, methodAndOutput, methodAndVarOutput, staticMethodOutput;
                    methodsAndVars = {};
                    staticMethods = {};
                    if (self.docstring) {
                        methodsAndVars["__doc__"] = function(output) {
                            output.print_string(self.docstring);
                        };
                    }
                    self.body.forEach(function(stmt, i) {
                        if (stmt instanceof ast.Method) {
                            if (stmt.static) {
                                staticMethods[stmt.name.name] = define_method(stmt);
                            } else {
                                methodsAndVars[stmt.name.name] = define_method(stmt);
                            }
                        } else if (stmt instanceof ast.SimpleStatement && stmt.body instanceof ast.Assign && stmt.body.operator === "=") {
                            methodsAndVars[stmt.body.left.name] = function(output) {
                                stmt.body.right.print(output);
                            };
                        } else if (stmt instanceof ast.Class) {
                            console.error("Nested classes aren't supported yet");
                        }
                    });
                    methodAndOutput = null;
                    if (Object.keys(methodsAndVars).length) {
                        methodAndVarOutput = output.addProperties("prototype", methodsAndVars);
                    }
                    staticMethodOutput = null;
                    if (Object.keys(staticMethods).length) {
                        staticMethodOutput = output.addProperties(null, staticMethods);
                    }
                    return [methodAndVarOutput, staticMethodOutput];
                }
                upk11 = addMethods();
                methodsAndVars = upk11[0];
                staticmethods = upk11[1];
                
                var generateClass = (_123 = function generateClass() {
                    if (self.init || self.parent || self.statements.length) {
                        output.print("function");
                        output.space();
                        self.name.print(output);
                        output.print("()");
                        output.space();
                        output.with_block(function() {
                            var cname;
                            bind_methods(self.bound, output);
                            if (self.init || self.parent) {
                                output.indent();
                                cname = self.init ? self.name : self.parent;
                                cname.print(output);
                                output.print(".prototype.__init__.apply");
                                output.with_parens(function() {
                                    output.print("this");
                                    output.comma();
                                    output.print("arguments");
                                });
                                output.end_statement();
                            }
                        });
                    } else {
                        output.print("function");
                        output.space();
                        self.name.print(output);
                        output.print("()");
                        output.space();
                        output.with_block(function() {
                            bind_methods(self.bound, output);
                        });
                    }
                }, _123 = unify(output, name, addInheritance(), addDecorators(), methodsAndVars, staticmethods)(_123), _123);
                return generateClass;
            }
            if (output.option("es6")) {
                generateClass = outputEs6();
            } else {
                generateClass = outputEs5();
            }
            generateClass();
        };
        DEFPRINT(ast.Class, function(self, output) {
            self._do_print(output);
        });
        DEFPRINT(ast.SymbolClassRef, function(self, output) {
            self.class.print(output);
            output.print(".prototype." + self.name);
        });
        ast.Exit.prototype._do_print = function(output, kind) {
            var self;
            self = this;
            output.print(kind);
            if (self.value) {
                output.space();
                self.value.print(output);
            }
            output.semicolon();
        };
        DEFPRINT(ast.Return, function(self, output) {
            self._do_print(output, "return");
        });
        DEFPRINT(ast.Yield, function(self, output) {
            self._do_print(output, "yield");
        });
        DEFPRINT(ast.Throw, function(self, output) {
            self._do_print(output, "throw");
        });
        ast.LoopControl.prototype._do_print = function(output, kind) {
            output.print(kind);
            if (this.label) {
                output.space();
                this.label.print(output);
            }
            output.semicolon();
        };
        DEFPRINT(ast.Break, function(self, output) {
            self._do_print(output, "break");
        });
        DEFPRINT(ast.Continue, function(self, output) {
            self._do_print(output, "continue");
        });
        function make_then(self, output) {
            var body;
            if (output.option("bracketize")) {
                make_block(self.body, output);
                return;
            }
            if (!self.body) {
                return output.force_semicolon();
            }
            body = self.body;
            while (true) {
                if (body instanceof ast.If) {
                    if (!body.alternative) {
                        make_block(self.body, output);
                        return;
                    }
                    body = body.alternative;
                } else if (body instanceof ast.StatementWithBody) {
                    body = body.body;
                } else {
                    break;
                }
            }
            force_statement(self.body, output);
        }
        DEFPRINT(ast.If, function(self, output) {
            output.print("if");
            output.space();
            output.with_parens(function() {
                self.condition.print(output);
            });
            output.space();
            if (self.alternative) {
                make_then(self, output);
                output.space();
                output.print("else");
                output.space();
                force_statement(self.alternative, output);
            } else {
                self._do_print_body(output);
            }
        });
        DEFPRINT(ast.Switch, function(self, output) {
            output.print("switch");
            output.space();
            output.with_parens(function() {
                self.expression.print(output);
            });
            output.space();
            if (self.body.length > 0) {
                output.with_block(function() {
                    self.body.forEach(function(stmt, i) {
                        if (i) {
                            output.newline();
                        }
                        output.indent(true);
                        stmt.print(output);
                    });
                });
            } else {
                output.print("{}");
            }
        });
        ast.SwitchBranch.prototype._do_print_body = function(output) {
            if (this.body.length > 0) {
                output.newline();
                this.body.forEach(function(stmt) {
                    output.indent();
                    stmt.print(output);
                    output.newline();
                });
            }
        };
        DEFPRINT(ast.Default, function(self, output) {
            output.print("default:");
            self._do_print_body(output);
        });
        DEFPRINT(ast.Case, function(self, output) {
            output.print("case");
            output.space();
            self.expression.print(output);
            output.print(":");
            self._do_print_body(output);
        });
        DEFPRINT(ast.Try, function(self, output) {
            output.print("try");
            output.space();
            print_bracketed(self, output);
            if (self.bcatch) {
                output.space();
                self.bcatch.print(output);
            }
            if (self.bfinally) {
                output.space();
                self.bfinally.print(output);
            }
        });
        DEFPRINT(ast.Catch, function(self, output) {
            output.print("catch");
            output.space();
            output.with_parens(function() {
                output.print("_Exception");
            });
            output.space();
            if (self.body.length > 1 || self.body[0].errors.length) {
                output.with_block(function() {
                    var no_default;
                    output.indent();
                    no_default = true;
                    self.body.forEach(function(exception, i) {
                        var no_default;
                        if (i) {
                            output.print("else ");
                        }
                        if (exception.errors.length) {
                            output.print("if");
                            output.space();
                            output.with_parens(function() {
                                exception.errors.forEach(function(err, i) {
                                    if (i) {
                                        output.newline();
                                        output.indent();
                                        output.print("||");
                                        output.space();
                                    }
                                    output.spaced("_Exception", "instanceof", err);
                                });
                            });
                            output.space();
                        } else {
                            no_default = false;
                        }
                        print_bracketed(exception, output, true);
                        output.space();
                    });
                    if (no_default) {
                        output.print("else");
                        output.space();
                        output.with_block(function() {
                            output.indent();
                            output.spaced("throw", "_Exception");
                            output.end_statement();
                        });
                    }
                    output.newline();
                });
            } else {
                print_bracketed(self.body[0], output, true);
            }
        });
        DEFPRINT(ast.Finally, function(self, output) {
            output.print("finally");
            output.space();
            print_bracketed(self, output);
        });
        ast.Definitions.prototype._do_print = function(output, kind) {
            var p, in_for, avoid_semicolon;
            output.print(kind);
            output.space();
            this.definitions.forEach(function(def_, i) {
                if (i) {
                    output.comma();
                }
                def_.print(output);
            });
            p = output.parent();
            in_for = p instanceof ast.ForIn;
            avoid_semicolon = in_for && p.init === this;
            if (!avoid_semicolon) {
                output.semicolon();
            }
        };
        DEFPRINT(ast.Var, function(self, output) {
            self._do_print(output, "var");
        });
        DEFPRINT(ast.Const, function(self, output) {
            self._do_print(output, "const");
        });
        function parenthesize_for_noin(node, output, noin) {
            if (!noin) {
                node.print(output);
            } else {
                try {
                    node.walk(new ast.TreeWalker(function(node) {
                        if (node instanceof ast.Binary && node.operator === "in") {
                            throw output;
                        }
                    }));
                    node.print(output);
                } catch (_Exception) {
                    var ex = _Exception;
                    if (ex !== output) {
                        throw ex;
                    }
                    node.print(output, true);
                }
            }
        }
        DEFPRINT(ast.VarDef, function(self, output) {
            self.name.print(output);
            if (self.value) {
                output.assign("");
                parenthesize_for_noin(self.value, output, output.parent(1) instanceof ast.ForIn);
            }
        });
        CREATION = [];
        DEFPRINT(ast.BaseCall, function(self, output) {
            var selfArg, object, has_kwarg_items, has_kwarg_formals, has_kwargs, obj, output_kwargs;
            selfArg = null;
            function call_format() {
                var rename;
                if (self instanceof ast.ClassCall) {
                    if (self.static) {
                        self.class.print(output);
                        output.print("." + self.method);
                    } else if (output.option("es6") && self.super) {
                        output.print("super");
                        if (self.method !== "constructor") {
                            output.print("." + self.method);
                        }
                        selfArg = self.args.shift();
                    } else {
                        self.class.print(output);
                        output.print(".prototype." + self.method + ".call");
                    }
                } else {
                    rename = _in(self.expression.name, SPECIAL_METHODS) ? SPECIAL_METHODS[self.expression.name] : void 0;
                    if (rename) {
                        output.print(rename);
                    } else {
                        self.expression.print(output);
                    }
                }
            }
            if (self instanceof ast.New) {
                object = CREATION.pop();
                if (no_constructor_parens(self, output)) {
                    call_format();
                    return;
                }
            }
            has_kwarg_items = self.args.kwarg_items && self.args.kwarg_items.length;
            has_kwarg_formals = self.args.kwargs && self.args.kwargs.length;
            has_kwargs = has_kwarg_items || has_kwarg_formals;
            if (self.args.starargs || has_kwargs) {
                obj = self instanceof ast.New ? object : self.expression.expression ? self.expression.expression : new ast.This();
                if (output.option("es6")) {
                    if (has_kwargs) {
                        output.print("kwargs");
                        output.with_parens(function() {
                            call_format();
                        });
                    } else {
                        call_format();
                    }
                } else {
                    if (self instanceof ast.New) {
                        call_format();
                        output.semicolon();
                        output.newline();
                        output.indent();
                        if (has_kwargs) {
                            output.print("kwargs");
                            output.with_parens(function() {
                                object.print(output);
                                output.print(".__init__");
                            });
                        } else {
                            object.print(output);
                            output.print(".__init__");
                        }
                    } else if (has_kwargs) {
                        output.print("kwargs");
                        output.with_parens(function() {
                            call_format();
                        });
                    } else {
                        call_format();
                    }
                }
            } else {
                call_format();
            }
            output_kwargs = function() {
                if (has_kwarg_items) {
                    self.args.kwarg_items.forEach(function(kwname, i) {
                        if (i > 0) {
                            output.print(",");
                            output.space();
                        }
                        kwname.print(output);
                    });
                    if (has_kwarg_formals) {
                        output.print(",");
                        output.space();
                    }
                }
                if (has_kwarg_formals) {
                    output.print("{");
                    self.args.kwargs.forEach(function(pair, i) {
                        if (i) {
                            output.comma();
                        }
                        pair[0].print(output);
                        output.print(":");
                        output.space();
                        pair[1].print(output);
                    });
                    output.print("}");
                }
            };
            if (output.option("es6") && self.args.starargs) {
                output.with_parens(function() {
                    self.args.forEach(function(expr, i) {
                        if (i) {
                            output.comma();
                        }
                        if (self.args.starargs && i === self.args.length - 1) {
                            output.print("...");
                        }
                        expr.print(output);
                    });
                });
            } else if (self.args.starargs) {
                output.print(".apply");
                output.with_parens(function() {
                    obj.print(output);
                    output.comma();
                    if (self.args.length > 1) {
                        output.with_square(function() {
                            self.args.slice(0, -1).forEach(function(expr, i) {
                                if (i) {
                                    output.comma();
                                }
                                expr.print(output);
                            });
                        });
                    } else {
                        self.args[0].print(output);
                    }
                    if (has_kwargs || self.args.length > 1) {
                        output.print(".concat");
                        output.with_parens(function() {
                            if (self.args.length > 1) {
                                self.args[self.args.length-1].print(output);
                                if (has_kwargs) {
                                    output.comma();
                                }
                            }
                            output_kwargs();
                        });
                    }
                });
            } else if (has_kwargs && (self instanceof ast.New || self.expression && self.expression.expression)) {
                output.print(".call");
                output.with_parens(function() {
                    var itr80, idx80;
                    var arg;
                    obj.print(output);
                    itr80 = _Iterable(self.args);
                    for (idx80 = 0; idx80 < itr80.length; idx80++) {
                        arg = itr80[idx80];
                        output.comma();
                        arg.print(output);
                    }
                    output.comma();
                    output_kwargs();
                });
            } else {
                output.with_parens(function() {
                    self.args.forEach(function(expr, i) {
                        if (i) {
                            output.comma();
                        }
                        expr.print(output);
                    });
                    if (has_kwargs) {
                        if (self.args.length) {
                            output.comma();
                        }
                        output_kwargs();
                    }
                });
            }
            if (output.option("es6") && self instanceof ast.ClassCall && self.super) {
                output.end_statement();
                output.indent();
                output.spaced("var", selfArg, "=", "this");
            }
        });
        DEFPRINT(ast.New, function(self, output) {
            output.print("new");
            output.space();
            ast.BaseCall.prototype._codegen(self, output);
        });
        ast.Seq.prototype._do_print = function(output) {
            var self, p, print_seq;
            self = this;
            p = output.parent();
            print_seq = function() {
                self.car.print(output);
                if (self.cdr) {
                    output.comma();
                    if (output.should_break()) {
                        output.newline();
                        output.indent();
                    }
                    self.cdr.print(output);
                }
            };
            if (p instanceof ast.Binary || p instanceof ast.Return || p instanceof ast.Array || p instanceof ast.BaseCall || p instanceof ast.SimpleStatement) {
                output.with_square(print_seq);
            } else {
                print_seq();
            }
        };
        DEFPRINT(ast.Seq, function(self, output) {
            self._do_print(output);
        });
        DEFPRINT(ast.Dot, function(self, output) {
            var expr;
            expr = self.expression;
            expr.print(output);
            if (expr instanceof ast.Number && expr.getValue() >= 0) {
                if (!/[xa-f.]/i.test(output.last())) {
                    output.print(".");
                }
            }
            output.print(".");
            output.add_mapping(self.end);
            output.print_name(self.property);
        });
        DEFPRINT(ast.Sub, function(self, output) {
            self.expression.print(output);
            output.print("[");
            if (self.property instanceof ast.Unary && self.property.operator === "-" && self.property.expression instanceof ast.Number) {
                self.expression.print(output);
                output.print(".length");
            }
            self.property.print(output);
            output.print("]");
        });
        DEFPRINT(ast.Slice, function(self, output) {
            output.print("[].splice.apply");
            output.with_parens(function() {
                self.expression.print(output);
                output.comma();
                output.with_square(function() {
                    self.property.print(output);
                    output.comma();
                    self.property2.print(output);
                    output.print("-");
                    self.property.print(output);
                });
                output.print(".concat");
                output.with_parens(function() {
                    self.assignment.print(output);
                });
            });
        });
        DEFPRINT(ast.UnaryPrefix, function(self, output) {
            var op;
            op = self.operator;
            if (op === "*") {
                if (output.option("es6")) {
                    op = "...";
                } else {
                    op = "";
                }
            }
            output.print(op);
            if (/^[a-z]/i.test(op)) {
                output.space();
            }
            self.expression.print(output);
        });
        DEFPRINT(ast.UnaryPostfix, function(self, output) {
            self.expression.print(output);
            output.print(self.operator);
        });
        DEFPRINT(ast.Binary, function(self, output) {
            var comparators, function_ops, normalize, operator, leftvar;
            comparators = {
                "<": true,
                ">": true,
                "<=": true,
                ">=": true,
                "==": true,
                "!=": true
            };
            function_ops = {
                "in": "_in",
                "**": "Math.pow",
                "//": "Math.floor"
            };
            normalize = function(op) {
                if (op === "==") {
                    return "===";
                } else if (op === "!=") {
                    return "!==";
                }
                return op;
            };
            if (_in(self.operator, function_ops)) {
                output.print(function_ops[self.operator]);
                output.with_parens(function() {
                    self.left.print(output);
                    if (self.operator === "//") {
                        output.space();
                        output.print("/");
                        output.space();
                    } else {
                        output.comma();
                    }
                    self.right.print(output);
                });
            } else if (comparators[self.operator] && self.left instanceof ast.Binary && comparators[self.left.operator]) {
                operator = normalize(self.operator);
                if (self.left.right instanceof ast.Symbol) {
                    self.left.print(output);
                    leftvar = self.left.right.name;
                } else {
                    self.left.left.print(output);
                    output.space();
                    output.print(self.left.operator);
                    output.space();
                    output.with_parens(function() {
                        leftvar = output.newTemp();
                        output.assign(leftvar);
                        self.left.right.print(output);
                    });
                }
                output.space();
                output.spaced("&&", leftvar, operator, self.right);
            } else {
                output.spaced(self.left, normalize(self.operator), self.right);
            }
        });
        DEFPRINT(ast.DeepEquality, function(self, output) {
            var primitives;
            primitives = [ "Boolean", "String", "Number" ];
            if (_in(self.left.computedType, primitives) || _in(self.right.computedType, primitives)) {
                self.left.print(output);
                output.space();
                self.operator === "==" ? output.print("===") : output.print("!==");
                output.space();
                self.right.print(output);
            } else {
                output.with_parens(function() {
                    var left, right;
                    left = cacheBubble(self.left, output);
                    if (self.operator === "==") {
                        output.space();
                        output.spaced("===");
                        output.space();
                        right = cacheBubble(self.right, output);
                        output.space();
                        output.spaced("||", "typeof", left, "===", '"object"');
                        output.space();
                        output.print("&&");
                        output.space();
                        output.print("_eq");
                        output.with_parens(function() {
                            left.print(output);
                            output.comma();
                            right.print(output);
                        });
                    } else {
                        output.space();
                        output.spaced("!==");
                        output.space();
                        right = cacheBubble(self.right, output);
                        output.space();
                        output.print("&&");
                        output.space();
                        output.with_parens(function() {
                            output.spaced("typeof", left, "!==", '"object"');
                            output.space();
                            output.print("||");
                            output.space();
                            output.print("!_eq");
                            output.with_parens(function() {
                                left.print(output);
                                output.comma();
                                right.print(output);
                            });
                        });
                    }
                });
            }
        });
        DEFPRINT(ast.Assign, function(self, output) {
            if (self.right instanceof ast.Number && self.right.value === 1 && _in(self.operator, [ "+=", "-=" ])) {
                output.print(self.operator === "+=" ? "++" : "--");
                self.left.print(output);
            } else {
                if (self.operator === "//=") {
                    output.assign(self.left);
                    output.print("Math.floor");
                    output.with_parens(function() {
                        self.left.print(output);
                        output.space();
                        output.print("/");
                        output.space();
                        self.right.print(output);
                    });
                    return;
                }
                if (self.left instanceof ast.Array) {
                    if (output.option("es6")) {
                        output.with_square(function() {
                            self.left.elements.forEach(function(element, index) {
                                if (index) output.comma();
                                element.print(output);
                            });
                        });
                    } else {
                        output.print(output.newTemp("upk"));
                    }
                } else {
                    self.left.print(output);
                }
                output.space();
                output.print(self.operator);
                output.space();
                if (self.right instanceof ast.New) {
                    CREATION.push(self.left);
                }
                self.right.print(output);
                if (self.left instanceof ast.Array) {
                    if (!output.option("es6")) {
                        output.end_statement();
                        unpack_tuple(self.left, output, true);
                    }
                }
            }
        });
        DEFPRINT(ast.Conditional, function(self, output) {
            self.condition.print(output);
            output.space();
            output.print("?");
            output.space();
            self.consequent.print(output);
            output.space();
            output.colon();
            self.alternative.print(output);
        });
        DEFPRINT(ast.Array, function(self, output) {
            output.with_square(function() {
                var array, len_;
                array = self.elements;
                len_ = array.length;
                if (len_ > 0) {
                    output.space();
                }
                array.forEach(function(exp, i) {
                    if (i) {
                        output.comma();
                    }
                    exp.print(output);
                });
                if (len_ > 0) {
                    output.space();
                }
            });
        });
        DEFPRINT(ast.Range, function(self, output) {
            var itr81, idx81;
            var indexes, element, start, end, step;
            indexes = [];
            itr81 = _Iterable([ self.left, self.right ]);
            for (idx81 = 0; idx81 < itr81.length; idx81++) {
                element = itr81[idx81];
                if (element instanceof ast.UnaryPrefix && element.operator === "-" && element.expression instanceof ast.Number) {
                    indexes.push(parseFloat("-" + element.expression.value));
                } else if (element instanceof ast.Number) {
                    indexes.push(parseFloat(element.value));
                } else {
                    indexes.push(null);
                }
            }
            if (indexes[0] && indexes[1] && Math.abs(indexes[1] - indexes[0]) < 50) {
                start = indexes[0];
                end = indexes[1];
                step = start < end ? 1 : -1;
                if (self.operator === "to") {
                    end += step / 1e6;
                }
                output.with_square(function() {
                    var itr82, idx82;
                    var i;
                    itr82 = _Iterable(range(start, end, step));
                    for (idx82 = 0; idx82 < itr82.length; idx82++) {
                        i = itr82[idx82];
                        if (i !== start) {
                            output.comma();
                        }
                        output.print(i);
                    }
                });
            } else {
                output.print("range");
                output.with_parens(function() {
                    self.left.print(output);
                    output.comma();
                    if (self.operator === "to") {
                        output.spaced(self.left, "<", self.right, "?", self.right, "+", 1e-6, ":", self.right, "-", 1e-6);
                    } else {
                        self.right.print(output);
                    }
                    output.comma();
                    output.spaced(self.left, "<", self.right, "?", "1", ":", "-1");
                });
            }
        });
        DEFPRINT(ast.ObjectLiteral, function(self, output) {
            if (self.properties.length > 0) {
                output.with_block(function() {
                    self.properties.forEach(function(prop, i) {
                        if (i) {
                            output.print(",");
                            output.newline();
                        }
                        output.indent();
                        prop.print(output);
                    });
                    output.newline();
                });
            } else {
                output.print("{}");
            }
        });
        DEFPRINT(ast.ObjectKeyVal, function(self, output) {
            if (self.key instanceof ast.Identifier || self.key instanceof ast.String || self.key instanceof ast.Number || self.key instanceof ast.Boolean) {
                self.key.print(output);
            } else {
                output.with_square(function() {
                    self.key.print(output);
                });
            }
            output.colon();
            self.value.print(output);
        });
        ast.Symbol.prototype.definition = function() {
            return this.thedef;
        };
        DEFPRINT(ast.Symbol, function(self, output) {
            var def_;
            def_ = self.definition();
            output.print_name(def_ ? def_.mangled_name || def_.name : self.name);
        });
        DEFPRINT(ast.Undefined, function(self, output) {
            output.print("void 0");
        });
        DEFPRINT(ast.Hole, noop);
        DEFPRINT(ast.Infinity, function(self, output) {
            output.print("1/0");
        });
        DEFPRINT(ast.NotANumber, function(self, output) {
            output.print("0/0");
        });
        DEFPRINT(ast.This, function(self, output) {
            output.print("this");
        });
        DEFPRINT(ast.Constant, function(self, output) {
            output.print(self.getValue());
        });
        DEFPRINT(ast.String, function(self, output) {
            if (_in(self.modifier, "fF")) {
                output.print("`");
                output.print_string(self.getValue(), false);
                output.print("`");
            } else {
                output.print_string(self.getValue());
            }
        });
        DEFPRINT(ast.Verbatim, function(self, output) {
            output.print(self.getValue());
        });
        DEFPRINT(ast.Number, function(self, output) {
            output.print(make_num(self.getValue()));
        });
        DEFPRINT(ast.RegExp, function(self, output) {
            var str_, p;
            str_ = self.getValue().toString();
            if (output.option("ascii_only")) {
                str_ = output.to_ascii(str_);
            }
            output.print(str_);
            p = output.parent();
            if (p instanceof ast.Binary && /^in/.test(p.operator) && p.left === self) {
                output.print(" ");
            }
        });
        function force_statement(stat, output) {
            if (output.option("bracketize")) {
                if (!stat || stat instanceof ast.EmptyStatement) {
                    output.print("{}");
                } else if (stat instanceof ast.BlockStatement) {
                    stat.print(output);
                } else {
                    output.with_block(function() {
                        output.indent();
                        stat.print(output);
                        output.newline();
                    });
                }
            } else {
                if (!stat || stat instanceof ast.EmptyStatement) {
                    output.force_semicolon();
                } else {
                    stat.print(output);
                }
            }
        }
        function first_in_statement(output) {
            var processed, i, node, prev;
            processed = output.stack();
            i = processed.length;
            node = processed[--i];
            prev = processed[--i];
            while (i > 0) {
                if (prev instanceof ast.Statement && prev.body === node) {
                    return true;
                }
                if (prev instanceof ast.Seq && prev.car === node || prev instanceof ast.BaseCall && prev.expression === node || prev instanceof ast.Dot && prev.expression === node || prev instanceof ast.Sub && prev.expression === node || prev instanceof ast.Conditional && prev.condition === node || prev instanceof ast.Binary && prev.left === node || prev instanceof ast.UnaryPostfix && prev.expression === node) {
                    node = prev;
                    prev = processed[--i];
                } else {
                    return false;
                }
            }
        }
        function no_constructor_parens(self, output) {
            return self.args.length === 0 && !output.option("beautify");
        }
        function best_of(choices) {
            var best, len_, i;
            best = choices[0];
            len_ = best.length;
            for (i = 1; i < choices.length; i++) {
                if (choices[i].length < len_) {
                    best = choices[i];
                    len_ = best.length;
                }
            }
            return best;
        }
        function make_num(num) {
            var str_, choices, match;
            str_ = num.toString(10);
            choices = [ str_.replace(/^0\./, ".").replace("e+", "e") ];
            match = null;
            if (Math.floor(num) === num) {
                if (num >= 0) {
                    choices.push("0x" + num.toString(16).toLowerCase(), "0" + num.toString(8));
                } else {
                    choices.push("-0x" + (-num).toString(16).toLowerCase(), "-0" + (-num).toString(8));
                }
                if (match = /^(.*?)(0+)$/.exec(num)) {
                    choices.push(match[1] + "e" + match[2].length);
                }
            } else if (match = /^0?\.(0+)(.*)$/.exec(num)) {
                choices.push(match[2] + "e-" + (match[1].length + match[2].length), str_.substr(str_.indexOf(".")));
            }
            return best_of(choices);
        }
        function make_block(stmt, output) {
            if (stmt instanceof ast.BlockStatement) {
                stmt.print(output);
                return;
            }
            output.with_block(function() {
                output.indent();
                stmt.print(output);
                output.newline();
            });
        }
        function DEFMAP(nodetype, generator) {
            nodetype.prototype.add_source_map = function(stream) {
                generator(this, stream);
            };
        }
        DEFMAP(ast.Node, noop);
        function basic_sourcemap_gen(self, output) {
            output.add_mapping(self.start);
        }
        DEFMAP(ast.Directive, basic_sourcemap_gen);
        DEFMAP(ast.Debugger, basic_sourcemap_gen);
        DEFMAP(ast.Symbol, basic_sourcemap_gen);
        DEFMAP(ast.Jump, basic_sourcemap_gen);
        DEFMAP(ast.StatementWithBody, basic_sourcemap_gen);
        DEFMAP(ast.LabeledStatement, noop);
        DEFMAP(ast.Lambda, basic_sourcemap_gen);
        DEFMAP(ast.Switch, basic_sourcemap_gen);
        DEFMAP(ast.SwitchBranch, basic_sourcemap_gen);
        DEFMAP(ast.BlockStatement, basic_sourcemap_gen);
        DEFMAP(ast.TopLevel, noop);
        DEFMAP(ast.New, basic_sourcemap_gen);
        DEFMAP(ast.Try, basic_sourcemap_gen);
        DEFMAP(ast.Catch, basic_sourcemap_gen);
        DEFMAP(ast.Finally, basic_sourcemap_gen);
        DEFMAP(ast.Definitions, basic_sourcemap_gen);
        DEFMAP(ast.Constant, basic_sourcemap_gen);
        DEFMAP(ast.ObjectProperty, function(self, output) {
            output.add_mapping(self.start, self.key);
        });
    })();
    _modules["output"]["Stream"] = Stream;
})();
var exports, rapydscript, compile;
var utils = _modules["utils"];

var ast = _modules["ast"];

var tokenizer = _modules["tokenizer"];

var parser = _modules["parser"];

var output = _modules["output"];

ast.Node.warn_function = function(txt) {
    console.error(txt);
};
function splatBaselib(key, value) {
    return new ast.Splat({
        module: new ast.SymbolVar({
            name: key
        }),
        body: new ast.TopLevel({
            start: value[0].start,
            body: value,
            strict: true,
            end: value[value.length-1].end
        })
    });
}
if (!exports) {
    rapydscript = exports = {};
}
exports.parse_baselib = exports.parseBaselib = function(srcPath, beautify) {
    var itr83, idx83;
    var fs, baselibPath, baselibAst, hash, data, baselibList, item, key, value;
    try {
        fs = require("fs");
        baselibPath = require("path").join(srcPath, "baselib.pyj");
        baselibAst = parser.parse(fs.readFileSync(baselibPath, "utf8"), {
            readfile: fs.readFileSync,
            dropDocstrings: true,
            filename: "baselib.pyj"
        });
    } catch (_Exception) {
        var e = _Exception;
        if (e.code === "ENOENT") {
            throw "Failed to localte baselib module.";
        } else {
            throw _Exception;
        }
    }
    hash = baselibAst.body[baselibAst.body.length-1];
    data = hash.body.properties;
    baselibList = {};
    itr83 = _Iterable(data);
    for (idx83 = 0; idx83 < itr83.length; idx83++) {
        item = itr83[idx83];
        key = item.key.value;
        value = item.value.name ? [ item.value ] : item.value.body;
        baselibList[key] = splatBaselib(key, value);
    }
    return baselibList;
};
exports.get_import_dirs = function(paths_string, ignore_env) {
    var paths, path;
    paths = [];
    path = require("path");
    function merge(new_path) {
        if (!(_in(new_path, paths))) {
            paths.push(new_path);
        }
    }
    if (!ignore_env && process && process.env && process.env.RAPYDSCRIPT_PATH) {
        process.env.RAPYDSCRIPT_PATH.split(path.delimiter).forEach(merge);
    }
    if (paths_string) {
        paths_string.split(path.delimiter).forEach(merge);
    }
    return paths;
};
exports.compile = compile = function(code, options) {
    var toplevel, stream;
    toplevel = parser.parse(code, utils.defaults(options, {
        toplevel: toplevel,
        output: {}
    }));
    if (!options.omit_baselib) {
        if (!toplevel.baselib["AssertionError"]) {
            --toplevel.baselib["extends"];
        }
        if (!toplevel.baselib["IndexError"]) {
            --toplevel.baselib["extends"];
        }
        if (!toplevel.baselib["KeyError"]) {
            --toplevel.baselib["extends"];
        }
        if (!toplevel.baselib["TypeError"]) {
            --toplevel.baselib["extends"];
        }
        if (!toplevel.baselib["ValueError"]) {
            --toplevel.baselib["extends"];
        }
        if (!toplevel.baselib["kwargs"]) {
            --toplevel.baselib["in"];
            --toplevel.baselib["iterator"];
            --toplevel.baselib["range"];
            --toplevel.baselib["dir"];
        }
        if (!toplevel.baselib["eq"]) {
            toplevel.baselib["iterator"] -= 2;
            --toplevel.baselib["range"];
        }
        if (!toplevel.baselib["merge"]) {
            --toplevel.baselib["iterator"];
        }
        if (!toplevel.baselib["mixin"]) {
            --toplevel.baselib["in"];
            toplevel.baselib["iterator"] -= 2;
        }
        if (!toplevel.baselib["enumerate"]) {
            --toplevel.baselib["iterator"];
            --toplevel.baselib["range"];
        }
        if (!toplevel.baselib["all"]) {
            --toplevel.baselib["iterator"];
        }
        if (!toplevel.baselib["any"]) {
            --toplevel.baselib["iterator"];
        }
        if (!toplevel.baselib["zip"]) {
            --toplevel.baselib["iterator"];
            --toplevel.baselib["range"];
        }
        if (!toplevel.baselib["rebind_all"]) {
            --toplevel.baselib["bind"];
        }
    }
    stream = output.Stream(options);
    toplevel.print(stream);
    return stream.toString();
};
exports.minify = function(files, options) {
    var itr84, idx84;
    var options, files, file, code;
    options = utils.defaults(options, {
        fromString: false,
        warnings: false
    });
    if (typeof files === "string") {
        files = [ files ];
    }
    itr84 = _Iterable(files);
    for (idx84 = 0; idx84 < itr84.length; idx84++) {
        file = itr84[idx84];
        options.filename = options.fromString ? "?" : file;
        code = options.fromString ? file : require("fs").readFileSync(file, "utf8");
        retrun;
        ({
            code: compile(code, options)
        });
    }
};
exports.parse = parser.parse;
exports.output = function(ast, options) {
    var stream;
    stream = output.Stream(options);
    ast.print(stream);
    return stream.toString();
};
exports.string_template = utils.string_template;
exports.ast = ast;
exports.tokenizer = tokenizer;
exports.NATIVE_CLASSES = parser.NATIVE_CLASSES;
exports.ParseError = utils.ParseError;
exports.ImportError = utils.ImportError;
exports.ALL_KEYWORDS = tokenizer.ALL_KEYWORDS;
exports.IDENTIFIER_PAT = tokenizer.IDENTIFIER_PAT;
exports.colored = utils.colored;var _124, _125, _126, _127, _128;

}).call(this,require('_process'))

},{"_process":18,"fs":1,"path":17}],25:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":26,"punycode":19,"querystring":23}],26:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],27:[function(require,module,exports){
var upk5, _2, _3, _4, _5;
function _bind(fn, thisArg) {
    var fn, ret;
    if (fn.orig) {
        fn = fn.orig;
    }
    if (thisArg === false) {
        return fn;
    }
    ret = function() {
        return fn.apply(thisArg, arguments);
    };
    ret.orig = fn;
    return ret;
}
function _rebindAll(thisArg, rebind) {
    var rebind;
    if (rebind === void 0) {
        rebind = true;
    }
    for (var p in thisArg) {
        if (thisArg[p] && thisArg[p].orig) {
            if (rebind) {
                thisArg[p] = _bind(thisArg[p], thisArg);
            } else {
                thisArg[p] = thisArg[p].orig;
            }
        }
    }
}
function _extends(child, parent) {
    child.prototype = Object.create(parent.prototype);
    child.prototype.__base__ = parent;
    child.prototype.constructor = child;
}
function _Iterable(iterable) {
    var tmp;
    if (iterable.constructor === [].constructor || iterable.constructor === "".constructor || (tmp = Array.prototype.slice.call(iterable)).length) {
        return tmp || iterable;
    }
    return Object.keys(iterable);
}
function len(obj) {
    var tmp;
    if (obj.constructor === [].constructor || obj.constructor === "".constructor || (tmp = Array.prototype.slice.call(obj)).length) {
        return (tmp || obj).length;
    }
    return Object.keys(obj).length;
}
function range(start, stop, step) {
    var stop, start, step, length, idx, range;
    if (arguments.length <= 1) {
        stop = start || 0;
        start = 0;
    }
    step = arguments[2] || 1;
    length = Math.max(Math.ceil((stop - start) / step), 0);
    idx = 0;
    range = new Array(length);
    while (idx < length) {
        range[idx++] = start;
        start += step;
    }
    return range;
}
function _type(obj) {
    return obj && obj.constructor && obj.constructor.name ? obj.constructor.name : Object.prototype.toString.call(obj).slice(8, -1);
}
function _eq(a, b) {
    var itr10, idx10;
    var i;
    if (a === b) {
        return true;
    }
    if (Array.isArray(a) && Array.isArray(b) || a instanceof Object && b instanceof Object) {
        if (a.constructor !== b.constructor || a.length !== b.length) {
            return false;
        }
        if (Array.isArray(a)) {
            for (i = 0; i < a.length; i++) {
                if (!_eq(a[i], b[i])) {
                    return false;
                }
            }
        } else {
            if (Object.keys(a).length !== Object.keys(b).length) {
                return false;
            }
            itr10 = _Iterable(a);
            for (idx10 = 0; idx10 < itr10.length; idx10++) {
                i = itr10[idx10];
                if (!_eq(a[i], b[i])) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}
var IndexError = (_6 = function IndexError() {
    IndexError.prototype.__init__.apply(this, arguments);
}, _extends(_6, Error), Object.defineProperties(_6.prototype, {
    __init__: {
        enumerable: true, 
        writable: true, 
        value: function __init__(message){
            var self = this;
            _rebindAll(this, true);
            self.name = "IndexError";
            self.message = message;
        }
    }
}), _6);
var TypeError = (_7 = function TypeError() {
    TypeError.prototype.__init__.apply(this, arguments);
}, _extends(_7, Error), Object.defineProperties(_7.prototype, {
    __init__: {
        enumerable: true, 
        writable: true, 
        value: function __init__(message){
            var self = this;
            _rebindAll(this, true);
            self.name = "TypeError";
            self.message = message;
        }
    }
}), _7);
var ValueError = (_8 = function ValueError() {
    ValueError.prototype.__init__.apply(this, arguments);
}, _extends(_8, Error), Object.defineProperties(_8.prototype, {
    __init__: {
        enumerable: true, 
        writable: true, 
        value: function __init__(message){
            var self = this;
            _rebindAll(this, true);
            self.name = "ValueError";
            self.message = message;
        }
    }
}), _8);
var _modules = {};
_modules["random"] = {};
_modules["stdlib"] = {};

(function(){
    var __name__ = "random";
    var _$rapyd$_seed_state, _$rapyd$_get_random_byte;
    _$rapyd$_seed_state = {
        key: [],
        key_i: 0,
        key_j: 0
    };
    _$rapyd$_get_random_byte = function() {
        var upk1;
        _$rapyd$_seed_state.key_i = (_$rapyd$_seed_state.key_i + 1) % 256;
        _$rapyd$_seed_state.key_j = (_$rapyd$_seed_state.key_j + _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_i]) % 256;
        upk1 = [ _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_j], _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_i] ];
        _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_i] = upk1[0];
        _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_j] = upk1[1];
        return _$rapyd$_seed_state.key[(_$rapyd$_seed_state.key[_$rapyd$_seed_state.key_i] + _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_j]) % 256];
    };
    function seed(x) {
        var upk2;
        x = x === void 0 ? new Date().getTime() : x;
        var x, i, j;
        if (typeof x === "number") {
            x = x.toString();
        } else if (typeof x !== "string") {
            throw new TypeError("unhashable type: '" + typeof x + "'");
        }
        for (i = 0; i < 256; i++) {
            _$rapyd$_seed_state.key[i] = i;
        }
        j = 0;
        for (i = 0; i < 256; i++) {
            j = (j + _$rapyd$_seed_state.key[i] + x.charCodeAt(i % x.length)) % 256;
            upk2 = [ _$rapyd$_seed_state.key[j], _$rapyd$_seed_state.key[i] ];
            _$rapyd$_seed_state.key[i] = upk2[0];
            _$rapyd$_seed_state.key[j] = upk2[1];
        }
    }
    seed();
    function random() {
        var n, m, i;
        n = 0;
        m = 1;
        for (i = 0; i < 8; i++) {
            n += _$rapyd$_get_random_byte() * m;
            m *= 256;
        }
        return n / 0x10000000000000000;
    }
    function randrange() {
        return choice(range.apply(this, arguments));
    }
    function randint(a, b) {
        return parseInt(random() * (b - a + 1) + a);
    }
    function uniform(a, b) {
        return random() * (b - a) + a;
    }
    function choice(seq) {
        if (seq.length > 0) {
            return seq[Math.floor(random() * seq.length)];
        } else {
            throw new IndexError();
        }
    }
    function shuffle(x, random_f) {
        var upk3;
        random_f = random_f === void 0 ? random : random_f;
        var i, j;
        for (i = 0; i < x.length; i++) {
            j = Math.floor(random_f() * (i + 1));
            upk3 = [ x[j], x[i] ];
            x[i] = upk3[0];
            x[j] = upk3[1];
        }
        return x;
    }
    function sample(population, k) {
        var itr1, idx1, upk4;
        var x, i, j;
        x = population.slice();
        itr1 = _Iterable(range(population.length - 1, population.length - k - 1, -1));
        for (idx1 = 0; idx1 < itr1.length; idx1++) {
            i = itr1[idx1];
            j = Math.floor(random() * (i + 1));
            upk4 = [ x[j], x[i] ];
            x[i] = upk4[0];
            x[j] = upk4[1];
        }
        return x.slice(population.length - k);
    }
    _modules["random"]["_$rapyd$_seed_state"] = _$rapyd$_seed_state;

    _modules["random"]["_$rapyd$_get_random_byte"] = _$rapyd$_get_random_byte;

    _modules["random"]["seed"] = seed;

    _modules["random"]["random"] = random;

    _modules["random"]["randrange"] = randrange;

    _modules["random"]["randint"] = randint;

    _modules["random"]["uniform"] = uniform;

    _modules["random"]["choice"] = choice;

    _modules["random"]["shuffle"] = shuffle;

    _modules["random"]["sample"] = sample;
})();

(function(){
    var __name__ = "stdlib";
    var str;
    str = JSON.stringify;
    String.prototype.find = String.prototype.indexOf;
    String.prototype.strip = String.prototype.trim;
    String.prototype.lstrip = String.prototype.trimLeft;
    String.prototype.rstrip = String.prototype.trimRight;
    String.prototype.join = function(iterable) {
        return iterable.join(this);
    };
    String.prototype.zfill = function(size) {
        var s;
        s = this;
        while (s.length < size) {
            s = "0" + s;
        }
        return s;
    };
    function list(iterable) {
        var itr2, idx2;
        iterable = iterable === void 0 ? [] : iterable;
        var result, i;
        result = [];
        itr2 = _Iterable(iterable);
        for (idx2 = 0; idx2 < itr2.length; idx2++) {
            i = itr2[idx2];
            result.append(i);
        }
        return result;
    }
    Array.prototype.append = Array.prototype.push;
    Array.prototype.find = Array.prototype.indexOf;
    Array.prototype.index = function(index) {
        var _1;
        var val;
        val = this.find(index);
        if ((val === (_1 = -1) || typeof val === "object" && _eq(val, _1))) {
            throw new ValueError(str(index) + " is not in list");
        }
        return val;
    };
    Array.prototype.insert = function(index, item) {
        this.splice(index, 0, item);
    };
    Array.prototype.pop = function(index) {
        index = index === void 0 ? this.length - 1 : index;
        return this.splice(index, 1)[0];
    };
    Array.prototype.extend = function(array2) {
        this.push.apply(this, array2);
    };
    Array.prototype.remove = function(item) {
        var index;
        index = this.find(item);
        this.splice(index, 1);
    };
    Array.prototype.copy = function() {
        return this.slice(0);
    };
    function dict(iterable) {
        var itr3, idx3;
        var result, key;
        result = {};
        itr3 = _Iterable(iterable);
        for (idx3 = 0; idx3 < itr3.length; idx3++) {
            key = itr3[idx3];
            result[key] = iterable[key];
        }
        return result;
    }
    if (_type(Object.getOwnPropertyNames) !== "function") {
        dict.keys = function(hash) {
            var keys;
            keys = [];
            
        for (var x in hash) {
            if (hash.hasOwnProperty(x)) {
                keys.push(x);
            }
        }
        ;
            return keys;
        };
    } else {
        dict.keys = function(hash) {
            return Object.getOwnPropertyNames(hash);
        };
    }
    dict.values = function(hash) {
        var itr4, idx4;
        var vals, key;
        vals = [];
        itr4 = _Iterable(dict.keys(hash));
        for (idx4 = 0; idx4 < itr4.length; idx4++) {
            key = itr4[idx4];
            vals.append(hash[key]);
        }
        return vals;
    };
    dict.items = function(hash) {
        var itr5, idx5;
        var items, key;
        items = [];
        itr5 = _Iterable(dict.keys(hash));
        for (idx5 = 0; idx5 < itr5.length; idx5++) {
            key = itr5[idx5];
            items.append([key, hash[key]]);
        }
        return items;
    };
    dict.copy = dict;
    dict.clear = function(hash) {
        var itr6, idx6;
        var key;
        itr6 = _Iterable(dict.keys(hash));
        for (idx6 = 0; idx6 < itr6.length; idx6++) {
            key = itr6[idx6];
            delete hash[key];
        }
    };
    _modules["stdlib"]["str"] = str;

    _modules["stdlib"]["list"] = list;

    _modules["stdlib"]["dict"] = dict;
})();

var __name__ = "__main__";
var width, height, colors;
var random = _modules["random"];

var stdlib = _modules["stdlib"];

function _print() {
    var args = [].slice.call(arguments, 0);
    var sep, end;
    sep = " ";
    end = "\n";
    function printAsync() {
        var element, arg, addition, previous;
        element = document.getElementById("__terminal__");
        if (element) {
            addition = sep.join((function() {
                var idx7, itr7 = _Iterable(args), res = [], arg;
                for (idx7 = 0; idx7 < itr7.length; idx7++) {
                    arg = itr7[idx7];
                    res.push(arg);
                }
                return res;
            })()) + end;
            previous = element.innerHTML;
            element.innerHTML = previous + addition.replace("\n", "<br>");
            element.scrollTop = element.scrollHeight;
        } else {
            console.log(sep.join((function() {
                var idx8, itr8 = _Iterable(args), res = [], arg;
                for (idx8 = 0; idx8 < itr8.length; idx8++) {
                    arg = itr8[idx8];
                    res.push(str(arg));
                }
                return res;
            })()));
        }
    }
    setTimeout(printAsync, 5);
}
_print("<h1>Educa.Juegos</h1>");
_print("<h2>Aprende jugando</h1>");
upk5 = [ 800, 200 ];
width = upk5[0];
height = upk5[1];
var Bola2 = (_2 = function Bola2() {
    this.recolor = _bind(this.recolor, this);
    this.destroy = _bind(this.destroy, this);
    this.play = _bind(this.play, this);
    Bola2.prototype.__init__.apply(this, arguments);
}, Object.defineProperties(_2.prototype, {
    __init__: {
        enumerable: true, 
        writable: true, 
        value: function __init__(){
            var self = this;
            _rebindAll(this, true);
            director.game.circle(30, colors.vibe_light);
            self.director = educajuego;
            self.sprite = self;
            self.sprite.x = width / 2;
            self.sprite.y = height / 2;
            self.sprite.vy = random.randint(-5, 4) || 5;
            self.sprite.vx = random.randint(-3, 2) || 3;
            self.recolor();
        }
    },
    recolor: {
        enumerable: true, 
        writable: true, 
        value: function recolor(){
            var self = this;
            self.sprite.fillStyle = random.choice([ colors.vibe_light, colors.vibe, colors.mute, colors.mute_light ]);
        }
    },
    destroy: {
        enumerable: true, 
        writable: true, 
        value: function destroy(){
            var self = this;
            self.to_delete = true;
            self.sprite.visible = false;
            self.director.game.remove(self.sprite);
            self.sprite.destroy();
        }
    },
    play: {
        enumerable: true, 
        writable: true, 
        value: function play(){
            var self = this;
            if (self.sprite.visible) {
                if (self.sprite.y > height - self.sprite.height) {
                    self.sprite.vy *= -1;
                }
                if (self.sprite.x > width - self.sprite.width) {
                    self.destroy();
                }
                if (self.sprite.y < 0) {
                    self.sprite.vy *= -1;
                }
                if (self.sprite.x < 0) {
                    self.destroy();
                }
                self.director.game.move(self.sprite);
            }
        }
    }
}), _2);
var Bola = (_3 = function Bola() {
    this.recolor = _bind(this.recolor, this);
    this.destroy = _bind(this.destroy, this);
    this.play = _bind(this.play, this);
    Bola.prototype.__init__.apply(this, arguments);
}, Object.defineProperties(_3.prototype, {
    __init__: {
        enumerable: true, 
        writable: true, 
        value: function __init__(director){
            var self = this;
            _rebindAll(this, true);
            self.director = director;
            self.to_delete = false;
            self.sprite = director.game.circle(30, colors.vibe_light);
            self.sprite.x = width / 2;
            self.sprite.y = height / 2;
            self.sprite.vy = random.randint(-5, 4) || 5;
            self.sprite.vx = random.randint(-3, 2) || 3;
            self.recolor();
        }
    },
    recolor: {
        enumerable: true, 
        writable: true, 
        value: function recolor(){
            var self = this;
            self.sprite.fillStyle = random.choice([ colors.vibe_light, colors.vibe, colors.mute, colors.mute_light ]);
        }
    },
    destroy: {
        enumerable: true, 
        writable: true, 
        value: function destroy(){
            var self = this;
            self.to_delete = true;
            self.sprite.visible = false;
            self.director.game.remove(self.sprite);
            self.sprite.destroy();
        }
    },
    play: {
        enumerable: true, 
        writable: true, 
        value: function play(){
            var self = this;
            if (self.sprite.visible) {
                if (self.sprite.y > height - self.sprite.height) {
                    self.sprite.vy *= -1;
                }
                if (self.sprite.x > width - self.sprite.width) {
                    self.destroy();
                    return;
                }
                if (self.sprite.y < 0) {
                    self.sprite.vy *= -1;
                }
                if (self.sprite.x < 0) {
                    self.destroy();
                    return;
                }
                self.director.game.move(self.sprite);
            }
        }
    }
}), _3);
var Director = (_4 = function Director() {
    this.setup = _bind(this.setup, this);
    this.recolor = _bind(this.recolor, this);
    this.make_bola = _bind(this.make_bola, this);
    this.play = _bind(this.play, this);
    this.pause = _bind(this.pause, this);
    this.resume = _bind(this.resume, this);
    this.rescale = _bind(this.rescale, this);
    Director.prototype.__init__.apply(this, arguments);
}, Object.defineProperties(_4.prototype, {
    __init__: {
        enumerable: true, 
        writable: true, 
        value: function __init__(){
            var self = this;
            _rebindAll(this, true);
            self.game = hexi(width, height, self.setup);
            self.game.fps = 25;
            self.actors = [];
        }
    },
    setup: {
        enumerable: true, 
        writable: true, 
        value: function setup(){
            var self = this;
            self.recolor();
            self.game.state = self.play;
            self.make_bola();
            self.print = _print;
        }
    },
    recolor: {
        enumerable: true, 
        writable: true, 
        value: function recolor(){
            var itr9, idx9;
            var self = this;
            var actor;
            itr9 = _Iterable(self.actors);
            for (idx9 = 0; idx9 < itr9.length; idx9++) {
                actor = itr9[idx9];
                actor.recolor();
            }
            self.game.backgroundColor = colors.mute_dark;
            self.rescale();
        }
    },
    make_bola: {
        enumerable: true, 
        writable: true, 
        value: function make_bola(){
            var self = this;
            self.actors.append(new Bola(self));
        }
    },
    play: {
        enumerable: true, 
        writable: true, 
        value: function play(){
            var self = this;
            var index, actor;
            for (index = 0; index < len(self.actors); index++) {
                actor = self.actors[index];
                if (actor.to_delete === false) {
                    actor.play();
                } else if (actor.to_delete === true) {
                    self.actors.pop(index);
                }
            }
        }
    },
    pause: {
        enumerable: true, 
        writable: true, 
        value: function pause(){
            var self = this;
            self.game.pause();
        }
    },
    resume: {
        enumerable: true, 
        writable: true, 
        value: function resume(){
            var self = this;
            self.game.resume();
        }
    },
    rescale: {
        enumerable: true, 
        writable: true, 
        value: function rescale(){
            var self = this;
            self.game.scaleToWindow(colors.mute);
        }
    }
}), _4);
function setup_styles() {
    var styles;
    styles = document.styleSheets[document.styleSheets.length - 1];
    styles.insertRule("h1, h2 { color: " + colors.vibe_light + " }", 0);
    styles.insertRule("h1, h2 { text-align: center; }", 0);
    styles.insertRule("h1, h2 { font-family: 'Indie Flower'; }", 0);
    styles.insertRule("#__terminal__ { color: " + colors.vibe_light + " }", 0);
    styles.insertRule("#__terminal__ { font-family: 'Bitter'; }", 0);
    styles.insertRule("#__prompt__ { font-family: 'Bitter'; position:absolute; bottom: 0; right: 0}", 0);
    if (window.educajuego) {
        window.educajuego.recolor();
    }
}
var Palette = (_5 = function Palette() {
    this.parse = _bind(this.parse, this);
    Palette.prototype.__init__.apply(this, arguments);
}, Object.defineProperties(_5.prototype, {
    __init__: {
        enumerable: true, 
        writable: true, 
        value: function __init__(asset, callback){
            var self = this;
            _rebindAll(this, true);
            var v;
            self.callback = callback;
            v = new Vibrant(asset);
            v.getPalette(self.parse);
            self.vibe = "#335533";
            self.vibe_light = "#656565";
            self.vibe_dark = "#0f1f0f";
            self.mute = "#111111";
            self.mute_light = "#333333";
            self.mute_dark = "#222222";
        }
    },
    parse: {
        enumerable: true, 
        writable: true, 
        value: function parse(err, palette){
            var self = this;
            self.palette = palette;
            self.vibe = palette.Vibrant.getHex();
            self.vibe_light = palette.LightVibrant.getHex();
            self.vibe_dark = palette.DarkVibrant.getHex();
            self.mute = palette.Muted.getHex();
            self.mute_light = palette.LightMuted.getHex();
            self.mute_dark = palette.DarkMuted.getHex();
            if (self.callback) {
                self.callback();
            }
        }
    }
}), _5);
function main() {
    var educajuego;
    setup_styles();
    educajuego = new Director();
    educajuego.game.start();
    window.setInterval(educajuego.make_bola, 250);
    window.onblur = educajuego.pause;
    window.onfocus = educajuego.resume;
    window.onresize = educajuego.rescale;
    window.educajuego = educajuego;
}
colors = new Palette("assets/Paleta de Colores 3.jpg", setup_styles);
main();var _6, _7, _8;

},{}],28:[function(require,module,exports){
require ("node-vibrant")
require ("rapydscript")
require ("./main.py")

},{"./main.py":27,"node-vibrant":2,"rapydscript":24}]},{},[28])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL25vZGUtdmlicmFudC9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLXZpYnJhbnQvbGliL2ZpbHRlci9kZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL25vZGUtdmlicmFudC9saWIvZmlsdGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25vZGUtdmlicmFudC9saWIvZ2VuZXJhdG9yL2RlZmF1bHQuanMiLCJub2RlX21vZHVsZXMvbm9kZS12aWJyYW50L2xpYi9nZW5lcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbm9kZS12aWJyYW50L2xpYi9pbWFnZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtdmlicmFudC9saWIvaW1hZ2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbm9kZS12aWJyYW50L2xpYi9xdWFudGl6ZXIvaW1wbC9tbWNxLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtdmlicmFudC9saWIvcXVhbnRpemVyL2ltcGwvcHF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtdmlicmFudC9saWIvcXVhbnRpemVyL2ltcGwvdmJveC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLXZpYnJhbnQvbGliL3F1YW50aXplci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLXZpYnJhbnQvbGliL3F1YW50aXplci9tbWNxLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtdmlicmFudC9saWIvc3dhdGNoLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtdmlicmFudC9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLXZpYnJhbnQvbGliL3ZpYnJhbnQuanMiLCJub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWFudGl6ZS9xdWFudGl6ZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhcHlkc2NyaXB0L2xpYi9yYXB5ZHNjcmlwdC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwic3JjL21haW4ucHkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbDJTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIiLCJ2YXIgVmlicmFudDtcblxuVmlicmFudCA9IHJlcXVpcmUoJy4vdmlicmFudCcpO1xuXG5WaWJyYW50LkRlZmF1bHRPcHRzLkltYWdlID0gcmVxdWlyZSgnLi9pbWFnZS9icm93c2VyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmlicmFudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ociwgZywgYiwgYSkge1xuICByZXR1cm4gYSA+PSAxMjUgJiYgIShyID4gMjUwICYmIGcgPiAyNTAgJiYgYiA+IDI1MCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMuRGVmYXVsdCA9IHJlcXVpcmUoJy4vZGVmYXVsdCcpO1xuIiwidmFyIERlZmF1bHRHZW5lcmF0b3IsIERlZmF1bHRPcHRzLCBHZW5lcmF0b3IsIFN3YXRjaCwgdXRpbCxcbiAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gIHNsaWNlID0gW10uc2xpY2U7XG5cblN3YXRjaCA9IHJlcXVpcmUoJy4uL3N3YXRjaCcpO1xuXG51dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5HZW5lcmF0b3IgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbkRlZmF1bHRPcHRzID0ge1xuICB0YXJnZXREYXJrTHVtYTogMC4yNixcbiAgbWF4RGFya0x1bWE6IDAuNDUsXG4gIG1pbkxpZ2h0THVtYTogMC41NSxcbiAgdGFyZ2V0TGlnaHRMdW1hOiAwLjc0LFxuICBtaW5Ob3JtYWxMdW1hOiAwLjMsXG4gIHRhcmdldE5vcm1hbEx1bWE6IDAuNSxcbiAgbWF4Tm9ybWFsTHVtYTogMC43LFxuICB0YXJnZXRNdXRlc1NhdHVyYXRpb246IDAuMyxcbiAgbWF4TXV0ZXNTYXR1cmF0aW9uOiAwLjQsXG4gIHRhcmdldFZpYnJhbnRTYXR1cmF0aW9uOiAxLjAsXG4gIG1pblZpYnJhbnRTYXR1cmF0aW9uOiAwLjM1LFxuICB3ZWlnaHRTYXR1cmF0aW9uOiAzLFxuICB3ZWlnaHRMdW1hOiA2LFxuICB3ZWlnaHRQb3B1bGF0aW9uOiAxXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRHZW5lcmF0b3IgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoRGVmYXVsdEdlbmVyYXRvciwgc3VwZXJDbGFzcyk7XG5cbiAgRGVmYXVsdEdlbmVyYXRvci5wcm90b3R5cGUuSGlnaGVzdFBvcHVsYXRpb24gPSAwO1xuXG4gIGZ1bmN0aW9uIERlZmF1bHRHZW5lcmF0b3Iob3B0cykge1xuICAgIHRoaXMub3B0cyA9IHV0aWwuZGVmYXVsdHMob3B0cywgRGVmYXVsdE9wdHMpO1xuICAgIHRoaXMuVmlicmFudFN3YXRjaCA9IG51bGw7XG4gICAgdGhpcy5MaWdodFZpYnJhbnRTd2F0Y2ggPSBudWxsO1xuICAgIHRoaXMuRGFya1ZpYnJhbnRTd2F0Y2ggPSBudWxsO1xuICAgIHRoaXMuTXV0ZWRTd2F0Y2ggPSBudWxsO1xuICAgIHRoaXMuTGlnaHRNdXRlZFN3YXRjaCA9IG51bGw7XG4gICAgdGhpcy5EYXJrTXV0ZWRTd2F0Y2ggPSBudWxsO1xuICB9XG5cbiAgRGVmYXVsdEdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbihzd2F0Y2hlcykge1xuICAgIHRoaXMuc3dhdGNoZXMgPSBzd2F0Y2hlcztcbiAgICB0aGlzLm1heFBvcHVsYXRpb24gPSB0aGlzLmZpbmRNYXhQb3B1bGF0aW9uO1xuICAgIHRoaXMuZ2VuZXJhdGVWYXJhdGlvbkNvbG9ycygpO1xuICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRW1wdHlTd2F0Y2hlcygpO1xuICB9O1xuXG4gIERlZmF1bHRHZW5lcmF0b3IucHJvdG90eXBlLmdldFZpYnJhbnRTd2F0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5WaWJyYW50U3dhdGNoO1xuICB9O1xuXG4gIERlZmF1bHRHZW5lcmF0b3IucHJvdG90eXBlLmdldExpZ2h0VmlicmFudFN3YXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLkxpZ2h0VmlicmFudFN3YXRjaDtcbiAgfTtcblxuICBEZWZhdWx0R2VuZXJhdG9yLnByb3RvdHlwZS5nZXREYXJrVmlicmFudFN3YXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLkRhcmtWaWJyYW50U3dhdGNoO1xuICB9O1xuXG4gIERlZmF1bHRHZW5lcmF0b3IucHJvdG90eXBlLmdldE11dGVkU3dhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuTXV0ZWRTd2F0Y2g7XG4gIH07XG5cbiAgRGVmYXVsdEdlbmVyYXRvci5wcm90b3R5cGUuZ2V0TGlnaHRNdXRlZFN3YXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLkxpZ2h0TXV0ZWRTd2F0Y2g7XG4gIH07XG5cbiAgRGVmYXVsdEdlbmVyYXRvci5wcm90b3R5cGUuZ2V0RGFya011dGVkU3dhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuRGFya011dGVkU3dhdGNoO1xuICB9O1xuXG4gIERlZmF1bHRHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlVmFyYXRpb25Db2xvcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLlZpYnJhbnRTd2F0Y2ggPSB0aGlzLmZpbmRDb2xvclZhcmlhdGlvbih0aGlzLm9wdHMudGFyZ2V0Tm9ybWFsTHVtYSwgdGhpcy5vcHRzLm1pbk5vcm1hbEx1bWEsIHRoaXMub3B0cy5tYXhOb3JtYWxMdW1hLCB0aGlzLm9wdHMudGFyZ2V0VmlicmFudFNhdHVyYXRpb24sIHRoaXMub3B0cy5taW5WaWJyYW50U2F0dXJhdGlvbiwgMSk7XG4gICAgdGhpcy5MaWdodFZpYnJhbnRTd2F0Y2ggPSB0aGlzLmZpbmRDb2xvclZhcmlhdGlvbih0aGlzLm9wdHMudGFyZ2V0TGlnaHRMdW1hLCB0aGlzLm9wdHMubWluTGlnaHRMdW1hLCAxLCB0aGlzLm9wdHMudGFyZ2V0VmlicmFudFNhdHVyYXRpb24sIHRoaXMub3B0cy5taW5WaWJyYW50U2F0dXJhdGlvbiwgMSk7XG4gICAgdGhpcy5EYXJrVmlicmFudFN3YXRjaCA9IHRoaXMuZmluZENvbG9yVmFyaWF0aW9uKHRoaXMub3B0cy50YXJnZXREYXJrTHVtYSwgMCwgdGhpcy5vcHRzLm1heERhcmtMdW1hLCB0aGlzLm9wdHMudGFyZ2V0VmlicmFudFNhdHVyYXRpb24sIHRoaXMub3B0cy5taW5WaWJyYW50U2F0dXJhdGlvbiwgMSk7XG4gICAgdGhpcy5NdXRlZFN3YXRjaCA9IHRoaXMuZmluZENvbG9yVmFyaWF0aW9uKHRoaXMub3B0cy50YXJnZXROb3JtYWxMdW1hLCB0aGlzLm9wdHMubWluTm9ybWFsTHVtYSwgdGhpcy5vcHRzLm1heE5vcm1hbEx1bWEsIHRoaXMub3B0cy50YXJnZXRNdXRlc1NhdHVyYXRpb24sIDAsIHRoaXMub3B0cy5tYXhNdXRlc1NhdHVyYXRpb24pO1xuICAgIHRoaXMuTGlnaHRNdXRlZFN3YXRjaCA9IHRoaXMuZmluZENvbG9yVmFyaWF0aW9uKHRoaXMub3B0cy50YXJnZXRMaWdodEx1bWEsIHRoaXMub3B0cy5taW5MaWdodEx1bWEsIDEsIHRoaXMub3B0cy50YXJnZXRNdXRlc1NhdHVyYXRpb24sIDAsIHRoaXMub3B0cy5tYXhNdXRlc1NhdHVyYXRpb24pO1xuICAgIHJldHVybiB0aGlzLkRhcmtNdXRlZFN3YXRjaCA9IHRoaXMuZmluZENvbG9yVmFyaWF0aW9uKHRoaXMub3B0cy50YXJnZXREYXJrTHVtYSwgMCwgdGhpcy5vcHRzLm1heERhcmtMdW1hLCB0aGlzLm9wdHMudGFyZ2V0TXV0ZXNTYXR1cmF0aW9uLCAwLCB0aGlzLm9wdHMubWF4TXV0ZXNTYXR1cmF0aW9uKTtcbiAgfTtcblxuICBEZWZhdWx0R2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUVtcHR5U3dhdGNoZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaHNsO1xuICAgIGlmICh0aGlzLlZpYnJhbnRTd2F0Y2ggPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLkRhcmtWaWJyYW50U3dhdGNoICE9PSBudWxsKSB7XG4gICAgICAgIGhzbCA9IHRoaXMuRGFya1ZpYnJhbnRTd2F0Y2guZ2V0SHNsKCk7XG4gICAgICAgIGhzbFsyXSA9IHRoaXMub3B0cy50YXJnZXROb3JtYWxMdW1hO1xuICAgICAgICB0aGlzLlZpYnJhbnRTd2F0Y2ggPSBuZXcgU3dhdGNoKHV0aWwuaHNsVG9SZ2IoaHNsWzBdLCBoc2xbMV0sIGhzbFsyXSksIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5EYXJrVmlicmFudFN3YXRjaCA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuVmlicmFudFN3YXRjaCAhPT0gbnVsbCkge1xuICAgICAgICBoc2wgPSB0aGlzLlZpYnJhbnRTd2F0Y2guZ2V0SHNsKCk7XG4gICAgICAgIGhzbFsyXSA9IHRoaXMub3B0cy50YXJnZXREYXJrTHVtYTtcbiAgICAgICAgcmV0dXJuIHRoaXMuRGFya1ZpYnJhbnRTd2F0Y2ggPSBuZXcgU3dhdGNoKHV0aWwuaHNsVG9SZ2IoaHNsWzBdLCBoc2xbMV0sIGhzbFsyXSksIDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBEZWZhdWx0R2VuZXJhdG9yLnByb3RvdHlwZS5maW5kTWF4UG9wdWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBqLCBsZW4sIHBvcHVsYXRpb24sIHJlZiwgc3dhdGNoO1xuICAgIHBvcHVsYXRpb24gPSAwO1xuICAgIHJlZiA9IHRoaXMuc3dhdGNoZXM7XG4gICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBzd2F0Y2ggPSByZWZbal07XG4gICAgICBwb3B1bGF0aW9uID0gTWF0aC5tYXgocG9wdWxhdGlvbiwgc3dhdGNoLmdldFBvcHVsYXRpb24oKSk7XG4gICAgfVxuICAgIHJldHVybiBwb3B1bGF0aW9uO1xuICB9O1xuXG4gIERlZmF1bHRHZW5lcmF0b3IucHJvdG90eXBlLmZpbmRDb2xvclZhcmlhdGlvbiA9IGZ1bmN0aW9uKHRhcmdldEx1bWEsIG1pbkx1bWEsIG1heEx1bWEsIHRhcmdldFNhdHVyYXRpb24sIG1pblNhdHVyYXRpb24sIG1heFNhdHVyYXRpb24pIHtcbiAgICB2YXIgaiwgbGVuLCBsdW1hLCBtYXgsIG1heFZhbHVlLCByZWYsIHNhdCwgc3dhdGNoLCB2YWx1ZTtcbiAgICBtYXggPSBudWxsO1xuICAgIG1heFZhbHVlID0gMDtcbiAgICByZWYgPSB0aGlzLnN3YXRjaGVzO1xuICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgc3dhdGNoID0gcmVmW2pdO1xuICAgICAgc2F0ID0gc3dhdGNoLmdldEhzbCgpWzFdO1xuICAgICAgbHVtYSA9IHN3YXRjaC5nZXRIc2woKVsyXTtcbiAgICAgIGlmIChzYXQgPj0gbWluU2F0dXJhdGlvbiAmJiBzYXQgPD0gbWF4U2F0dXJhdGlvbiAmJiBsdW1hID49IG1pbkx1bWEgJiYgbHVtYSA8PSBtYXhMdW1hICYmICF0aGlzLmlzQWxyZWFkeVNlbGVjdGVkKHN3YXRjaCkpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmNyZWF0ZUNvbXBhcmlzb25WYWx1ZShzYXQsIHRhcmdldFNhdHVyYXRpb24sIGx1bWEsIHRhcmdldEx1bWEsIHN3YXRjaC5nZXRQb3B1bGF0aW9uKCksIHRoaXMuSGlnaGVzdFBvcHVsYXRpb24pO1xuICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IHZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICBtYXggPSBzd2F0Y2g7XG4gICAgICAgICAgbWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9O1xuXG4gIERlZmF1bHRHZW5lcmF0b3IucHJvdG90eXBlLmNyZWF0ZUNvbXBhcmlzb25WYWx1ZSA9IGZ1bmN0aW9uKHNhdHVyYXRpb24sIHRhcmdldFNhdHVyYXRpb24sIGx1bWEsIHRhcmdldEx1bWEsIHBvcHVsYXRpb24sIG1heFBvcHVsYXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy53ZWlnaHRlZE1lYW4odGhpcy5pbnZlcnREaWZmKHNhdHVyYXRpb24sIHRhcmdldFNhdHVyYXRpb24pLCB0aGlzLm9wdHMud2VpZ2h0U2F0dXJhdGlvbiwgdGhpcy5pbnZlcnREaWZmKGx1bWEsIHRhcmdldEx1bWEpLCB0aGlzLm9wdHMud2VpZ2h0THVtYSwgcG9wdWxhdGlvbiAvIG1heFBvcHVsYXRpb24sIHRoaXMub3B0cy53ZWlnaHRQb3B1bGF0aW9uKTtcbiAgfTtcblxuICBEZWZhdWx0R2VuZXJhdG9yLnByb3RvdHlwZS5pbnZlcnREaWZmID0gZnVuY3Rpb24odmFsdWUsIHRhcmdldFZhbHVlKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmFicyh2YWx1ZSAtIHRhcmdldFZhbHVlKTtcbiAgfTtcblxuICBEZWZhdWx0R2VuZXJhdG9yLnByb3RvdHlwZS53ZWlnaHRlZE1lYW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSwgc3VtLCBzdW1XZWlnaHQsIHZhbHVlLCB2YWx1ZXMsIHdlaWdodDtcbiAgICB2YWx1ZXMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICBzdW0gPSAwO1xuICAgIHN1bVdlaWdodCA9IDA7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgIHdlaWdodCA9IHZhbHVlc1tpICsgMV07XG4gICAgICBzdW0gKz0gdmFsdWUgKiB3ZWlnaHQ7XG4gICAgICBzdW1XZWlnaHQgKz0gd2VpZ2h0O1xuICAgICAgaSArPSAyO1xuICAgIH1cbiAgICByZXR1cm4gc3VtIC8gc3VtV2VpZ2h0O1xuICB9O1xuXG4gIERlZmF1bHRHZW5lcmF0b3IucHJvdG90eXBlLmlzQWxyZWFkeVNlbGVjdGVkID0gZnVuY3Rpb24oc3dhdGNoKSB7XG4gICAgcmV0dXJuIHRoaXMuVmlicmFudFN3YXRjaCA9PT0gc3dhdGNoIHx8IHRoaXMuRGFya1ZpYnJhbnRTd2F0Y2ggPT09IHN3YXRjaCB8fCB0aGlzLkxpZ2h0VmlicmFudFN3YXRjaCA9PT0gc3dhdGNoIHx8IHRoaXMuTXV0ZWRTd2F0Y2ggPT09IHN3YXRjaCB8fCB0aGlzLkRhcmtNdXRlZFN3YXRjaCA9PT0gc3dhdGNoIHx8IHRoaXMuTGlnaHRNdXRlZFN3YXRjaCA9PT0gc3dhdGNoO1xuICB9O1xuXG4gIHJldHVybiBEZWZhdWx0R2VuZXJhdG9yO1xuXG59KShHZW5lcmF0b3IpO1xuIiwidmFyIEdlbmVyYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW5lcmF0b3IgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG5cbiAgR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uKHN3YXRjaGVzKSB7fTtcblxuICBHZW5lcmF0b3IucHJvdG90eXBlLmdldFZpYnJhbnRTd2F0Y2ggPSBmdW5jdGlvbigpIHt9O1xuXG4gIEdlbmVyYXRvci5wcm90b3R5cGUuZ2V0TGlnaHRWaWJyYW50U3dhdGNoID0gZnVuY3Rpb24oKSB7fTtcblxuICBHZW5lcmF0b3IucHJvdG90eXBlLmdldERhcmtWaWJyYW50U3dhdGNoID0gZnVuY3Rpb24oKSB7fTtcblxuICBHZW5lcmF0b3IucHJvdG90eXBlLmdldE11dGVkU3dhdGNoID0gZnVuY3Rpb24oKSB7fTtcblxuICBHZW5lcmF0b3IucHJvdG90eXBlLmdldExpZ2h0TXV0ZWRTd2F0Y2ggPSBmdW5jdGlvbigpIHt9O1xuXG4gIEdlbmVyYXRvci5wcm90b3R5cGUuZ2V0RGFya011dGVkU3dhdGNoID0gZnVuY3Rpb24oKSB7fTtcblxuICByZXR1cm4gR2VuZXJhdG9yO1xuXG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cy5EZWZhdWx0ID0gcmVxdWlyZSgnLi9kZWZhdWx0Jyk7XG4iLCJ2YXIgQnJvd3NlckltYWdlLCBJbWFnZSwgVXJsLCBpc1JlbGF0aXZlVXJsLCBpc1NhbWVPcmlnaW4sXG4gIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5JbWFnZSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuVXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbmlzUmVsYXRpdmVVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgdmFyIHU7XG4gIHUgPSBVcmwucGFyc2UodXJsKTtcbiAgcmV0dXJuIHUucHJvdG9jb2wgPT09IG51bGwgJiYgdS5ob3N0ID09PSBudWxsICYmIHUucG9ydCA9PT0gbnVsbDtcbn07XG5cbmlzU2FtZU9yaWdpbiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIHVhLCB1YjtcbiAgdWEgPSBVcmwucGFyc2UoYSk7XG4gIHViID0gVXJsLnBhcnNlKGIpO1xuICByZXR1cm4gdWEucHJvdG9jb2wgPT09IHViLnByb3RvY29sICYmIHVhLmhvc3RuYW1lID09PSB1Yi5ob3N0bmFtZSAmJiB1YS5wb3J0ID09PSB1Yi5wb3J0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcm93c2VySW1hZ2UgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoQnJvd3NlckltYWdlLCBzdXBlckNsYXNzKTtcblxuICBmdW5jdGlvbiBCcm93c2VySW1hZ2UocGF0aCwgY2IpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdvYmplY3QnICYmIHBhdGggaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICB0aGlzLmltZyA9IHBhdGg7XG4gICAgICBwYXRoID0gdGhpcy5pbWcuc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgdGhpcy5pbWcuc3JjID0gcGF0aDtcbiAgICB9XG4gICAgaWYgKCFpc1JlbGF0aXZlVXJsKHBhdGgpICYmICFpc1NhbWVPcmlnaW4od2luZG93LmxvY2F0aW9uLmhyZWYsIHBhdGgpKSB7XG4gICAgICB0aGlzLmltZy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgIH1cbiAgICB0aGlzLmltZy5vbmxvYWQgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX2luaXRDYW52YXMoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiID8gY2IobnVsbCwgX3RoaXMpIDogdm9pZCAwO1xuICAgICAgfTtcbiAgICB9KSh0aGlzKTtcbiAgICBpZiAodGhpcy5pbWcuY29tcGxldGUpIHtcbiAgICAgIHRoaXMuaW1nLm9ubG9hZCgpO1xuICAgIH1cbiAgICB0aGlzLmltZy5vbmVycm9yID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZXJyO1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJGYWlsIHRvIGxvYWQgaW1hZ2U6IFwiICsgcGF0aCk7XG4gICAgICAgIGVyci5yYXcgPSBlO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIgPyBjYihlcnIpIDogdm9pZCAwO1xuICAgICAgfTtcbiAgICB9KSh0aGlzKTtcbiAgfVxuXG4gIEJyb3dzZXJJbWFnZS5wcm90b3R5cGUuX2luaXRDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5pbWcud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmltZy5oZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UodGhpcy5pbWcsIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfTtcblxuICBCcm93c2VySW1hZ2UucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9O1xuXG4gIEJyb3dzZXJJbWFnZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgfTtcblxuICBCcm93c2VySW1hZ2UucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgfTtcblxuICBCcm93c2VySW1hZ2UucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHcsIGgsIHIpIHtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGggPSB3O1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gaDtcbiAgICB0aGlzLmNvbnRleHQuc2NhbGUociwgcik7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UodGhpcy5pbWcsIDAsIDApO1xuICB9O1xuXG4gIEJyb3dzZXJJbWFnZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgfTtcblxuICBCcm93c2VySW1hZ2UucHJvdG90eXBlLmdldFBpeGVsQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICB9O1xuXG4gIEJyb3dzZXJJbWFnZS5wcm90b3R5cGUuZ2V0SW1hZ2VEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9O1xuXG4gIEJyb3dzZXJJbWFnZS5wcm90b3R5cGUucmVtb3ZlQ2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuICB9O1xuXG4gIHJldHVybiBCcm93c2VySW1hZ2U7XG5cbn0pKEltYWdlKTtcbiIsInZhciBJbWFnZTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gSW1hZ2UoKSB7fVxuXG4gIEltYWdlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge307XG5cbiAgSW1hZ2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge307XG5cbiAgSW1hZ2UucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24oKSB7fTtcblxuICBJbWFnZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7fTtcblxuICBJbWFnZS5wcm90b3R5cGUuc2NhbGVEb3duID0gZnVuY3Rpb24ob3B0cykge1xuICAgIHZhciBoZWlnaHQsIG1heFNpZGUsIHJhdGlvLCB3aWR0aDtcbiAgICB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgIHJhdGlvID0gMTtcbiAgICBpZiAob3B0cy5tYXhEaW1lbnNpb24gIT0gbnVsbCkge1xuICAgICAgbWF4U2lkZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgaWYgKG1heFNpZGUgPiBvcHRzLm1heERpbWVuc2lvbikge1xuICAgICAgICByYXRpbyA9IG9wdHMubWF4RGltZW5zaW9uIC8gbWF4U2lkZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmF0aW8gPSAxIC8gb3B0cy5xdWFsaXR5O1xuICAgIH1cbiAgICBpZiAocmF0aW8gPCAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNpemUod2lkdGggKiByYXRpbywgaGVpZ2h0ICogcmF0aW8sIHJhdGlvKTtcbiAgICB9XG4gIH07XG5cbiAgSW1hZ2UucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHcsIGgsIHIpIHt9O1xuXG4gIEltYWdlLnByb3RvdHlwZS5nZXRQaXhlbENvdW50ID0gZnVuY3Rpb24oKSB7fTtcblxuICBJbWFnZS5wcm90b3R5cGUuZ2V0SW1hZ2VEYXRhID0gZnVuY3Rpb24oKSB7fTtcblxuICBJbWFnZS5wcm90b3R5cGUucmVtb3ZlQ2FudmFzID0gZnVuY3Rpb24oKSB7fTtcblxuICByZXR1cm4gSW1hZ2U7XG5cbn0pKCk7XG4iLCJ2YXIgTU1DUSwgUFF1ZXVlLCBSU0hJRlQsIFNJR0JJVFMsIFN3YXRjaCwgVkJveCwgZ2V0Q29sb3JJbmRleCwgcmVmLCB1dGlsO1xuXG5yZWYgPSB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLCBnZXRDb2xvckluZGV4ID0gcmVmLmdldENvbG9ySW5kZXgsIFNJR0JJVFMgPSByZWYuU0lHQklUUywgUlNISUZUID0gcmVmLlJTSElGVDtcblxuU3dhdGNoID0gcmVxdWlyZSgnLi4vLi4vc3dhdGNoJyk7XG5cblZCb3ggPSByZXF1aXJlKCcuL3Zib3gnKTtcblxuUFF1ZXVlID0gcmVxdWlyZSgnLi9wcXVldWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNTUNRID0gKGZ1bmN0aW9uKCkge1xuICBNTUNRLkRlZmF1bHRPcHRzID0ge1xuICAgIG1heEl0ZXJhdGlvbnM6IDEwMDAsXG4gICAgZnJhY3RCeVBvcHVsYXRpb25zOiAwLjc1XG4gIH07XG5cbiAgZnVuY3Rpb24gTU1DUShvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gdXRpbC5kZWZhdWx0cyhvcHRzLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRPcHRzKTtcbiAgfVxuXG4gIE1NQ1EucHJvdG90eXBlLnF1YW50aXplID0gZnVuY3Rpb24ocGl4ZWxzLCBvcHRzKSB7XG4gICAgdmFyIGNvbG9yLCBjb2xvckNvdW50LCBoaXN0LCBwcSwgcHEyLCBzaG91bGRJZ25vcmUsIHN3YXRjaGVzLCB2LCB2Ym94O1xuICAgIGlmIChwaXhlbHMubGVuZ3RoID09PSAwIHx8IG9wdHMuY29sb3JDb3VudCA8IDIgfHwgb3B0cy5jb2xvckNvdW50ID4gMjU2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBNTUNRIHBhcmFtZXRlcnNcIik7XG4gICAgfVxuICAgIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5maWx0ZXJzKSAmJiBvcHRzLmZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgc2hvdWxkSWdub3JlID0gZnVuY3Rpb24ociwgZywgYiwgYSkge1xuICAgICAgICB2YXIgZiwgaSwgbGVuLCByZWYxO1xuICAgICAgICByZWYxID0gb3B0cy5maWx0ZXJzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZiA9IHJlZjFbaV07XG4gICAgICAgICAgaWYgKCFmKHIsIGcsIGIsIGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmJveCA9IFZCb3guYnVpbGQocGl4ZWxzLCBzaG91bGRJZ25vcmUpO1xuICAgIGhpc3QgPSB2Ym94Lmhpc3Q7XG4gICAgY29sb3JDb3VudCA9IE9iamVjdC5rZXlzKGhpc3QpLmxlbmd0aDtcbiAgICBwcSA9IG5ldyBQUXVldWUoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEuY291bnQoKSAtIGIuY291bnQoKTtcbiAgICB9KTtcbiAgICBwcS5wdXNoKHZib3gpO1xuICAgIHRoaXMuX3NwbGl0Qm94ZXMocHEsIHRoaXMub3B0cy5mcmFjdEJ5UG9wdWxhdGlvbnMgKiBvcHRzLmNvbG9yQ291bnQpO1xuICAgIHBxMiA9IG5ldyBQUXVldWUoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEuY291bnQoKSAqIGEudm9sdW1lKCkgLSBiLmNvdW50KCkgKiBiLnZvbHVtZSgpO1xuICAgIH0pO1xuICAgIHBxMi5jb250ZW50cyA9IHBxLmNvbnRlbnRzO1xuICAgIHRoaXMuX3NwbGl0Qm94ZXMocHEyLCBvcHRzLmNvbG9yQ291bnQgLSBwcTIuc2l6ZSgpKTtcbiAgICBzd2F0Y2hlcyA9IFtdO1xuICAgIHRoaXMudmJveGVzID0gW107XG4gICAgd2hpbGUgKHBxMi5zaXplKCkpIHtcbiAgICAgIHYgPSBwcTIucG9wKCk7XG4gICAgICBjb2xvciA9IHYuYXZnKCk7XG4gICAgICBpZiAoISh0eXBlb2Ygc2hvdWxkSWdub3JlID09PSBcImZ1bmN0aW9uXCIgPyBzaG91bGRJZ25vcmUoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgMjU1KSA6IHZvaWQgMCkpIHtcbiAgICAgICAgdGhpcy52Ym94ZXMucHVzaCh2KTtcbiAgICAgICAgc3dhdGNoZXMucHVzaChuZXcgU3dhdGNoKGNvbG9yLCB2LmNvdW50KCkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN3YXRjaGVzO1xuICB9O1xuXG4gIE1NQ1EucHJvdG90eXBlLl9zcGxpdEJveGVzID0gZnVuY3Rpb24ocHEsIHRhcmdldCkge1xuICAgIHZhciBjb2xvckNvdW50LCBpdGVyYXRpb24sIG1heEl0ZXJhdGlvbnMsIHJlZjEsIHZib3gsIHZib3gxLCB2Ym94MjtcbiAgICBjb2xvckNvdW50ID0gMTtcbiAgICBpdGVyYXRpb24gPSAwO1xuICAgIG1heEl0ZXJhdGlvbnMgPSB0aGlzLm9wdHMubWF4SXRlcmF0aW9ucztcbiAgICB3aGlsZSAoaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgaXRlcmF0aW9uKys7XG4gICAgICB2Ym94ID0gcHEucG9wKCk7XG4gICAgICBpZiAoIXZib3guY291bnQoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlZjEgPSB2Ym94LnNwbGl0KCksIHZib3gxID0gcmVmMVswXSwgdmJveDIgPSByZWYxWzFdO1xuICAgICAgcHEucHVzaCh2Ym94MSk7XG4gICAgICBpZiAodmJveDIpIHtcbiAgICAgICAgcHEucHVzaCh2Ym94Mik7XG4gICAgICAgIGNvbG9yQ291bnQrKztcbiAgICAgIH1cbiAgICAgIGlmIChjb2xvckNvdW50ID49IHRhcmdldCB8fCBpdGVyYXRpb24gPiBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1NQ1E7XG5cbn0pKCk7XG4iLCJ2YXIgUFF1ZXVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBRdWV1ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUFF1ZXVlKGNvbXBhcmF0b3IpIHtcbiAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgIHRoaXMuY29udGVudHMgPSBbXTtcbiAgICB0aGlzLnNvcnRlZCA9IGZhbHNlO1xuICB9XG5cbiAgUFF1ZXVlLnByb3RvdHlwZS5fc29ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGVudHMuc29ydCh0aGlzLmNvbXBhcmF0b3IpO1xuICAgIHJldHVybiB0aGlzLnNvcnRlZCA9IHRydWU7XG4gIH07XG5cbiAgUFF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obykge1xuICAgIHRoaXMuY29udGVudHMucHVzaChvKTtcbiAgICByZXR1cm4gdGhpcy5zb3J0ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBQUXVldWUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmICghdGhpcy5zb3J0ZWQpIHtcbiAgICAgIHRoaXMuX3NvcnQoKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5jb250ZW50cy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZW50c1tpbmRleF07XG4gIH07XG5cbiAgUFF1ZXVlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuc29ydGVkKSB7XG4gICAgICB0aGlzLl9zb3J0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLnBvcCgpO1xuICB9O1xuXG4gIFBRdWV1ZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLmxlbmd0aDtcbiAgfTtcblxuICBQUXVldWUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICBpZiAoIXRoaXMuc29ydGVkKSB7XG4gICAgICB0aGlzLl9zb3J0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLm1hcChmKTtcbiAgfTtcblxuICByZXR1cm4gUFF1ZXVlO1xuXG59KSgpO1xuIiwidmFyIFJTSElGVCwgU0lHQklUUywgVkJveCwgZ2V0Q29sb3JJbmRleCwgcmVmLCB1dGlsO1xuXG5yZWYgPSB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLCBnZXRDb2xvckluZGV4ID0gcmVmLmdldENvbG9ySW5kZXgsIFNJR0JJVFMgPSByZWYuU0lHQklUUywgUlNISUZUID0gcmVmLlJTSElGVDtcblxubW9kdWxlLmV4cG9ydHMgPSBWQm94ID0gKGZ1bmN0aW9uKCkge1xuICBWQm94LmJ1aWxkID0gZnVuY3Rpb24ocGl4ZWxzLCBzaG91bGRJZ25vcmUpIHtcbiAgICB2YXIgYSwgYiwgYm1heCwgYm1pbiwgZywgZ21heCwgZ21pbiwgaGlzdCwgaG4sIGksIGluZGV4LCBuLCBvZmZzZXQsIHIsIHJtYXgsIHJtaW47XG4gICAgaG4gPSAxIDw8ICgzICogU0lHQklUUyk7XG4gICAgaGlzdCA9IG5ldyBVaW50MzJBcnJheShobik7XG4gICAgcm1heCA9IGdtYXggPSBibWF4ID0gMDtcbiAgICBybWluID0gZ21pbiA9IGJtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIG4gPSBwaXhlbHMubGVuZ3RoIC8gNDtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgIG9mZnNldCA9IGkgKiA0O1xuICAgICAgaSsrO1xuICAgICAgciA9IHBpeGVsc1tvZmZzZXQgKyAwXTtcbiAgICAgIGcgPSBwaXhlbHNbb2Zmc2V0ICsgMV07XG4gICAgICBiID0gcGl4ZWxzW29mZnNldCArIDJdO1xuICAgICAgYSA9IHBpeGVsc1tvZmZzZXQgKyAzXTtcbiAgICAgIGlmIChzaG91bGRJZ25vcmUociwgZywgYiwgYSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByID0gciA+PiBSU0hJRlQ7XG4gICAgICBnID0gZyA+PiBSU0hJRlQ7XG4gICAgICBiID0gYiA+PiBSU0hJRlQ7XG4gICAgICBpbmRleCA9IGdldENvbG9ySW5kZXgociwgZywgYik7XG4gICAgICBoaXN0W2luZGV4XSArPSAxO1xuICAgICAgaWYgKHIgPiBybWF4KSB7XG4gICAgICAgIHJtYXggPSByO1xuICAgICAgfVxuICAgICAgaWYgKHIgPCBybWluKSB7XG4gICAgICAgIHJtaW4gPSByO1xuICAgICAgfVxuICAgICAgaWYgKGcgPiBnbWF4KSB7XG4gICAgICAgIGdtYXggPSBnO1xuICAgICAgfVxuICAgICAgaWYgKGcgPCBnbWluKSB7XG4gICAgICAgIGdtaW4gPSBnO1xuICAgICAgfVxuICAgICAgaWYgKGIgPiBibWF4KSB7XG4gICAgICAgIGJtYXggPSBiO1xuICAgICAgfVxuICAgICAgaWYgKGIgPCBibWluKSB7XG4gICAgICAgIGJtaW4gPSBiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFZCb3gocm1pbiwgcm1heCwgZ21pbiwgZ21heCwgYm1pbiwgYm1heCwgaGlzdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gVkJveChyMSwgcjIsIGcxLCBnMiwgYjEsIGIyLCBoaXN0MSkge1xuICAgIHRoaXMucjEgPSByMTtcbiAgICB0aGlzLnIyID0gcjI7XG4gICAgdGhpcy5nMSA9IGcxO1xuICAgIHRoaXMuZzIgPSBnMjtcbiAgICB0aGlzLmIxID0gYjE7XG4gICAgdGhpcy5iMiA9IGIyO1xuICAgIHRoaXMuaGlzdCA9IGhpc3QxO1xuICB9XG5cbiAgVkJveC5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jb3VudDtcbiAgICBkZWxldGUgdGhpcy5fYXZnO1xuICAgIHJldHVybiBkZWxldGUgdGhpcy5fdm9sdW1lO1xuICB9O1xuXG4gIFZCb3gucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl92b2x1bWUgPT0gbnVsbCkge1xuICAgICAgdGhpcy5fdm9sdW1lID0gKHRoaXMucjIgLSB0aGlzLnIxICsgMSkgKiAodGhpcy5nMiAtIHRoaXMuZzEgKyAxKSAqICh0aGlzLmIyIC0gdGhpcy5iMSArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdm9sdW1lO1xuICB9O1xuXG4gIFZCb3gucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGMsIGhpc3Q7XG4gICAgaWYgKHRoaXMuX2NvdW50ID09IG51bGwpIHtcbiAgICAgIGhpc3QgPSB0aGlzLmhpc3Q7XG4gICAgICBjID0gMDtcbiAgICAgIFxuICAgICAgZm9yICh2YXIgciA9IHRoaXMucjE7IHIgPD0gdGhpcy5yMjsgcisrKSB7XG4gICAgICAgIGZvciAodmFyIGcgPSB0aGlzLmcxOyBnIDw9IHRoaXMuZzI7IGcrKykge1xuICAgICAgICAgIGZvciAodmFyIGIgPSB0aGlzLmIxOyBiIDw9IHRoaXMuYjI7IGIrKykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0Q29sb3JJbmRleChyLCBnLCBiKTtcbiAgICAgICAgICAgIGMgKz0gaGlzdFtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICA7XG4gICAgICB0aGlzLl9jb3VudCA9IGM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jb3VudDtcbiAgfTtcblxuICBWQm94LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgVkJveCh0aGlzLnIxLCB0aGlzLnIyLCB0aGlzLmcxLCB0aGlzLmcyLCB0aGlzLmIxLCB0aGlzLmIyLCB0aGlzLmhpc3QpO1xuICB9O1xuXG4gIFZCb3gucHJvdG90eXBlLmF2ZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBic3VtLCBnc3VtLCBoaXN0LCBtdWx0LCBudG90LCByc3VtO1xuICAgIGlmICh0aGlzLl9hdmcgPT0gbnVsbCkge1xuICAgICAgaGlzdCA9IHRoaXMuaGlzdDtcbiAgICAgIG50b3QgPSAwO1xuICAgICAgbXVsdCA9IDEgPDwgKDggLSBTSUdCSVRTKTtcbiAgICAgIHJzdW0gPSBnc3VtID0gYnN1bSA9IDA7XG4gICAgICBcbiAgICAgIGZvciAodmFyIHIgPSB0aGlzLnIxOyByIDw9IHRoaXMucjI7IHIrKykge1xuICAgICAgICBmb3IgKHZhciBnID0gdGhpcy5nMTsgZyA8PSB0aGlzLmcyOyBnKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBiID0gdGhpcy5iMTsgYiA8PSB0aGlzLmIyOyBiKyspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldENvbG9ySW5kZXgociwgZywgYik7XG4gICAgICAgICAgICB2YXIgaCA9IGhpc3RbaW5kZXhdO1xuICAgICAgICAgICAgbnRvdCArPSBoO1xuICAgICAgICAgICAgcnN1bSArPSAoaCAqIChyICsgMC41KSAqIG11bHQpO1xuICAgICAgICAgICAgZ3N1bSArPSAoaCAqIChnICsgMC41KSAqIG11bHQpO1xuICAgICAgICAgICAgYnN1bSArPSAoaCAqIChiICsgMC41KSAqIG11bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgO1xuICAgICAgaWYgKG50b3QpIHtcbiAgICAgICAgdGhpcy5fYXZnID0gW35+KHJzdW0gLyBudG90KSwgfn4oZ3N1bSAvIG50b3QpLCB+fihic3VtIC8gbnRvdCldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYXZnID0gW35+KG11bHQgKiAodGhpcy5yMSArIHRoaXMucjIgKyAxKSAvIDIpLCB+fihtdWx0ICogKHRoaXMuZzEgKyB0aGlzLmcyICsgMSkgLyAyKSwgfn4obXVsdCAqICh0aGlzLmIxICsgdGhpcy5iMiArIDEpIC8gMildO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXZnO1xuICB9O1xuXG4gIFZCb3gucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFjY1N1bSwgYncsIGQsIGRvQ3V0LCBndywgaGlzdCwgaSwgaiwgbWF4ZCwgbWF4dywgcmVmMSwgcmV2ZXJzZVN1bSwgcncsIHNwbGl0UG9pbnQsIHN1bSwgdG90YWwsIHZib3g7XG4gICAgaGlzdCA9IHRoaXMuaGlzdDtcbiAgICBpZiAoIXRoaXMuY291bnQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvdW50KCkgPT09IDEpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jbG9uZSgpXTtcbiAgICB9XG4gICAgcncgPSB0aGlzLnIyIC0gdGhpcy5yMSArIDE7XG4gICAgZ3cgPSB0aGlzLmcyIC0gdGhpcy5nMSArIDE7XG4gICAgYncgPSB0aGlzLmIyIC0gdGhpcy5iMSArIDE7XG4gICAgbWF4dyA9IE1hdGgubWF4KHJ3LCBndywgYncpO1xuICAgIGFjY1N1bSA9IG51bGw7XG4gICAgc3VtID0gdG90YWwgPSAwO1xuICAgIG1heGQgPSBudWxsO1xuICAgIHN3aXRjaCAobWF4dykge1xuICAgICAgY2FzZSBydzpcbiAgICAgICAgbWF4ZCA9ICdyJztcbiAgICAgICAgYWNjU3VtID0gbmV3IFVpbnQzMkFycmF5KHRoaXMucjIgKyAxKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIHIgPSB0aGlzLnIxOyByIDw9IHRoaXMucjI7IHIrKykge1xuICAgICAgICAgIHN1bSA9IDBcbiAgICAgICAgICBmb3IgKHZhciBnID0gdGhpcy5nMTsgZyA8PSB0aGlzLmcyOyBnKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSB0aGlzLmIxOyBiIDw9IHRoaXMuYjI7IGIrKykge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRDb2xvckluZGV4KHIsIGcsIGIpO1xuICAgICAgICAgICAgICBzdW0gKz0gaGlzdFtpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdGFsICs9IHN1bTtcbiAgICAgICAgICBhY2NTdW1bcl0gPSB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBndzpcbiAgICAgICAgbWF4ZCA9ICdnJztcbiAgICAgICAgYWNjU3VtID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuZzIgKyAxKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGcgPSB0aGlzLmcxOyBnIDw9IHRoaXMuZzI7IGcrKykge1xuICAgICAgICAgIHN1bSA9IDBcbiAgICAgICAgICBmb3IgKHZhciByID0gdGhpcy5yMTsgciA8PSB0aGlzLnIyOyByKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSB0aGlzLmIxOyBiIDw9IHRoaXMuYjI7IGIrKykge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRDb2xvckluZGV4KHIsIGcsIGIpO1xuICAgICAgICAgICAgICBzdW0gKz0gaGlzdFtpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdGFsICs9IHN1bTtcbiAgICAgICAgICBhY2NTdW1bZ10gPSB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBidzpcbiAgICAgICAgbWF4ZCA9ICdiJztcbiAgICAgICAgYWNjU3VtID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuYjIgKyAxKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGIgPSB0aGlzLmIxOyBiIDw9IHRoaXMuYjI7IGIrKykge1xuICAgICAgICAgIHN1bSA9IDBcbiAgICAgICAgICBmb3IgKHZhciByID0gdGhpcy5yMTsgciA8PSB0aGlzLnIyOyByKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGcgPSB0aGlzLmcxOyBnIDw9IHRoaXMuZzI7IGcrKykge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRDb2xvckluZGV4KHIsIGcsIGIpO1xuICAgICAgICAgICAgICBzdW0gKz0gaGlzdFtpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdGFsICs9IHN1bTtcbiAgICAgICAgICBhY2NTdW1bYl0gPSB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgfVxuICAgIHNwbGl0UG9pbnQgPSAtMTtcbiAgICByZXZlcnNlU3VtID0gbmV3IFVpbnQzMkFycmF5KGFjY1N1bS5sZW5ndGgpO1xuICAgIGZvciAoaSA9IGogPSAwLCByZWYxID0gYWNjU3VtLmxlbmd0aCAtIDE7IDAgPD0gcmVmMSA/IGogPD0gcmVmMSA6IGogPj0gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsraiA6IC0taikge1xuICAgICAgZCA9IGFjY1N1bVtpXTtcbiAgICAgIGlmIChzcGxpdFBvaW50IDwgMCAmJiBkID4gdG90YWwgLyAyKSB7XG4gICAgICAgIHNwbGl0UG9pbnQgPSBpO1xuICAgICAgfVxuICAgICAgcmV2ZXJzZVN1bVtpXSA9IHRvdGFsIC0gZDtcbiAgICB9XG4gICAgdmJveCA9IHRoaXM7XG4gICAgZG9DdXQgPSBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgYzIsIGQxLCBkMiwgZGltMSwgZGltMiwgbGVmdCwgcmlnaHQsIHZib3gxLCB2Ym94MjtcbiAgICAgIGRpbTEgPSBkICsgXCIxXCI7XG4gICAgICBkaW0yID0gZCArIFwiMlwiO1xuICAgICAgZDEgPSB2Ym94W2RpbTFdO1xuICAgICAgZDIgPSB2Ym94W2RpbTJdO1xuICAgICAgdmJveDEgPSB2Ym94LmNsb25lKCk7XG4gICAgICB2Ym94MiA9IHZib3guY2xvbmUoKTtcbiAgICAgIGxlZnQgPSBzcGxpdFBvaW50IC0gZDE7XG4gICAgICByaWdodCA9IGQyIC0gc3BsaXRQb2ludDtcbiAgICAgIGlmIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgICAgIGQyID0gTWF0aC5taW4oZDIgLSAxLCB+fihzcGxpdFBvaW50ICsgcmlnaHQgLyAyKSk7XG4gICAgICAgIGQyID0gTWF0aC5tYXgoMCwgZDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZDIgPSBNYXRoLm1heChkMSwgfn4oc3BsaXRQb2ludCAtIDEgLSBsZWZ0IC8gMikpO1xuICAgICAgICBkMiA9IE1hdGgubWluKHZib3hbZGltMl0sIGQyKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICghYWNjU3VtW2QyXSkge1xuICAgICAgICBkMisrO1xuICAgICAgfVxuICAgICAgYzIgPSByZXZlcnNlU3VtW2QyXTtcbiAgICAgIHdoaWxlICghYzIgJiYgYWNjU3VtW2QyIC0gMV0pIHtcbiAgICAgICAgYzIgPSByZXZlcnNlU3VtWy0tZDJdO1xuICAgICAgfVxuICAgICAgdmJveDFbZGltMl0gPSBkMjtcbiAgICAgIHZib3gyW2RpbTFdID0gZDIgKyAxO1xuICAgICAgcmV0dXJuIFt2Ym94MSwgdmJveDJdO1xuICAgIH07XG4gICAgcmV0dXJuIGRvQ3V0KG1heGQpO1xuICB9O1xuXG4gIFZCb3gucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24ocCkge1xuICAgIHZhciBiLCBnLCByO1xuICAgIHIgPSBwWzBdID4+IFJTSElGVDtcbiAgICBnID0gcFsxXSA+PiBSU0hJRlQ7XG4gICAgYiA9IHBbMl0gPj4gUlNISUZUO1xuICAgIHJldHVybiByID49IHRoaXMucjEgJiYgciA8PSB0aGlzLnIyICYmIGcgPj0gdGhpcy5nMSAmJiBnIDw9IHRoaXMuZzIgJiYgYiA+PSB0aGlzLmIxICYmIGIgPD0gdGhpcy5iMjtcbiAgfTtcblxuICByZXR1cm4gVkJveDtcblxufSkoKTtcbiIsInZhciBRdWFudGl6ZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gUXVhbnRpemVyID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBRdWFudGl6ZXIoKSB7fVxuXG4gIFF1YW50aXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHBpeGVscywgb3B0cykge307XG5cbiAgUXVhbnRpemVyLnByb3RvdHlwZS5nZXRRdWFudGl6ZWRDb2xvcnMgPSBmdW5jdGlvbigpIHt9O1xuXG4gIHJldHVybiBRdWFudGl6ZXI7XG5cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzLk1NQ1EgPSByZXF1aXJlKCcuL21tY3EnKTtcbiIsInZhciBNTUNRLCBNTUNRSW1wbCwgUXVhbnRpemVyLCBTd2F0Y2gsXG4gIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5Td2F0Y2ggPSByZXF1aXJlKCcuLi9zd2F0Y2gnKTtcblxuUXVhbnRpemVyID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5NTUNRSW1wbCA9IHJlcXVpcmUoJy4vaW1wbC9tbWNxJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTU1DUSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gIGV4dGVuZChNTUNRLCBzdXBlckNsYXNzKTtcblxuICBmdW5jdGlvbiBNTUNRKCkge1xuICAgIHJldHVybiBNTUNRLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgTU1DUS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHBpeGVscywgb3B0cykge1xuICAgIHZhciBtbWNxO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgbW1jcSA9IG5ldyBNTUNRSW1wbCgpO1xuICAgIHJldHVybiB0aGlzLnN3YXRjaGVzID0gbW1jcS5xdWFudGl6ZShwaXhlbHMsIHRoaXMub3B0cyk7XG4gIH07XG5cbiAgTU1DUS5wcm90b3R5cGUuZ2V0UXVhbnRpemVkQ29sb3JzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3dhdGNoZXM7XG4gIH07XG5cbiAgcmV0dXJuIE1NQ1E7XG5cbn0pKFF1YW50aXplcik7XG4iLCJ2YXIgU3dhdGNoLCB1dGlsO1xuXG51dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cblxuLypcbiAgRnJvbSBWaWJyYW50LmpzIGJ5IEphcmkgWndhcnRzXG4gIFBvcnRlZCB0byBub2RlLmpzIGJ5IEFLRmlzaFxuXG4gIFN3YXRjaCBjbGFzc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3dhdGNoID0gKGZ1bmN0aW9uKCkge1xuICBTd2F0Y2gucHJvdG90eXBlLmhzbCA9IHZvaWQgMDtcblxuICBTd2F0Y2gucHJvdG90eXBlLnJnYiA9IHZvaWQgMDtcblxuICBTd2F0Y2gucHJvdG90eXBlLnBvcHVsYXRpb24gPSAxO1xuXG4gIFN3YXRjaC5wcm90b3R5cGUueWlxID0gMDtcblxuICBmdW5jdGlvbiBTd2F0Y2gocmdiLCBwb3B1bGF0aW9uKSB7XG4gICAgdGhpcy5yZ2IgPSByZ2I7XG4gICAgdGhpcy5wb3B1bGF0aW9uID0gcG9wdWxhdGlvbjtcbiAgfVxuXG4gIFN3YXRjaC5wcm90b3R5cGUuZ2V0SHNsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmhzbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaHNsID0gdXRpbC5yZ2JUb0hzbCh0aGlzLnJnYlswXSwgdGhpcy5yZ2JbMV0sIHRoaXMucmdiWzJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaHNsO1xuICAgIH1cbiAgfTtcblxuICBTd2F0Y2gucHJvdG90eXBlLmdldFBvcHVsYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wb3B1bGF0aW9uO1xuICB9O1xuXG4gIFN3YXRjaC5wcm90b3R5cGUuZ2V0UmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiO1xuICB9O1xuXG4gIFN3YXRjaC5wcm90b3R5cGUuZ2V0SGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWwucmdiVG9IZXgodGhpcy5yZ2JbMF0sIHRoaXMucmdiWzFdLCB0aGlzLnJnYlsyXSk7XG4gIH07XG5cbiAgU3dhdGNoLnByb3RvdHlwZS5nZXRUaXRsZVRleHRDb2xvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2Vuc3VyZVRleHRDb2xvcnMoKTtcbiAgICBpZiAodGhpcy55aXEgPCAyMDApIHtcbiAgICAgIHJldHVybiBcIiNmZmZcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiIzAwMFwiO1xuICAgIH1cbiAgfTtcblxuICBTd2F0Y2gucHJvdG90eXBlLmdldEJvZHlUZXh0Q29sb3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9lbnN1cmVUZXh0Q29sb3JzKCk7XG4gICAgaWYgKHRoaXMueWlxIDwgMTUwKSB7XG4gICAgICByZXR1cm4gXCIjZmZmXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIiMwMDBcIjtcbiAgICB9XG4gIH07XG5cbiAgU3dhdGNoLnByb3RvdHlwZS5fZW5zdXJlVGV4dENvbG9ycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy55aXEpIHtcbiAgICAgIHJldHVybiB0aGlzLnlpcSA9ICh0aGlzLnJnYlswXSAqIDI5OSArIHRoaXMucmdiWzFdICogNTg3ICsgdGhpcy5yZ2JbMl0gKiAxMTQpIC8gMTAwMDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFN3YXRjaDtcblxufSkoKTtcbiIsInZhciBERUxUQUU5NCwgUlNISUZULCBTSUdCSVRTO1xuXG5ERUxUQUU5NCA9IHtcbiAgTkE6IDAsXG4gIFBFUkZFQ1Q6IDEsXG4gIENMT1NFOiAyLFxuICBHT09EOiAxMCxcbiAgU0lNSUxBUjogNTBcbn07XG5cblNJR0JJVFMgPSA1O1xuXG5SU0hJRlQgPSA4IC0gU0lHQklUUztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNsb25lOiBmdW5jdGlvbihvKSB7XG4gICAgdmFyIF9vLCBrZXksIHZhbHVlO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG4gICAgICAgIHJldHVybiBvLm1hcCgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNsb25lKHYpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9vID0ge307XG4gICAgICAgIGZvciAoa2V5IGluIG8pIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ba2V5XTtcbiAgICAgICAgICBfb1trZXldID0gdGhpcy5jbG9uZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9vO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfSxcbiAgZGVmYXVsdHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfbywgaSwga2V5LCBsZW4sIG8sIHZhbHVlO1xuICAgIG8gPSB7fTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIF9vID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChrZXkgaW4gX28pIHtcbiAgICAgICAgdmFsdWUgPSBfb1trZXldO1xuICAgICAgICBpZiAob1trZXldID09IG51bGwpIHtcbiAgICAgICAgICBvW2tleV0gPSB0aGlzLmNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfSxcbiAgaGV4VG9SZ2I6IGZ1bmN0aW9uKGhleCkge1xuICAgIHZhciBtO1xuICAgIG0gPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgICBpZiAobSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gW21bMV0sIG1bMl0sIG1bM11dLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChzLCAxNik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHJnYlRvSGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgKCgxIDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYikudG9TdHJpbmcoMTYpLnNsaWNlKDEsIDcpO1xuICB9LFxuICByZ2JUb0hzbDogZnVuY3Rpb24ociwgZywgYikge1xuICAgIHZhciBkLCBoLCBsLCBtYXgsIG1pbiwgcztcbiAgICByIC89IDI1NTtcbiAgICBnIC89IDI1NTtcbiAgICBiIC89IDI1NTtcbiAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICBoID0gdm9pZCAwO1xuICAgIHMgPSB2b2lkIDA7XG4gICAgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIGggPSBzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IG1heCAtIG1pbjtcbiAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgIGNhc2UgcjpcbiAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZzpcbiAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgIH1cbiAgICAgIGggLz0gNjtcbiAgICB9XG4gICAgcmV0dXJuIFtoLCBzLCBsXTtcbiAgfSxcbiAgaHNsVG9SZ2I6IGZ1bmN0aW9uKGgsIHMsIGwpIHtcbiAgICB2YXIgYiwgZywgaHVlMnJnYiwgcCwgcSwgcjtcbiAgICByID0gdm9pZCAwO1xuICAgIGcgPSB2b2lkIDA7XG4gICAgYiA9IHZvaWQgMDtcbiAgICBodWUycmdiID0gZnVuY3Rpb24ocCwgcSwgdCkge1xuICAgICAgaWYgKHQgPCAwKSB7XG4gICAgICAgIHQgKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICB0IC09IDE7XG4gICAgICB9XG4gICAgICBpZiAodCA8IDEgLyA2KSB7XG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPCAxIC8gMikge1xuICAgICAgICByZXR1cm4gcTtcbiAgICAgIH1cbiAgICAgIGlmICh0IDwgMiAvIDMpIHtcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfTtcbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgciA9IGcgPSBiID0gbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gKGwgKiBzKTtcbiAgICAgIHAgPSAyICogbCAtIHE7XG4gICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gKDEgLyAzKSk7XG4gICAgfVxuICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG4gIH0sXG4gIHJnYlRvWHl6OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgdmFyIHgsIHksIHo7XG4gICAgciAvPSAyNTU7XG4gICAgZyAvPSAyNTU7XG4gICAgYiAvPSAyNTU7XG4gICAgciA9IHIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKHIgKyAwLjAwNSkgLyAxLjA1NSwgMi40KSA6IHIgLyAxMi45MjtcbiAgICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoZyArIDAuMDA1KSAvIDEuMDU1LCAyLjQpIDogZyAvIDEyLjkyO1xuICAgIGIgPSBiID4gMC4wNDA0NSA/IE1hdGgucG93KChiICsgMC4wMDUpIC8gMS4wNTUsIDIuNCkgOiBiIC8gMTIuOTI7XG4gICAgciAqPSAxMDA7XG4gICAgZyAqPSAxMDA7XG4gICAgYiAqPSAxMDA7XG4gICAgeCA9IHIgKiAwLjQxMjQgKyBnICogMC4zNTc2ICsgYiAqIDAuMTgwNTtcbiAgICB5ID0gciAqIDAuMjEyNiArIGcgKiAwLjcxNTIgKyBiICogMC4wNzIyO1xuICAgIHogPSByICogMC4wMTkzICsgZyAqIDAuMTE5MiArIGIgKiAwLjk1MDU7XG4gICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgfSxcbiAgeHl6VG9DSUVMYWI6IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgTCwgUkVGX1gsIFJFRl9ZLCBSRUZfWiwgYSwgYjtcbiAgICBSRUZfWCA9IDk1LjA0NztcbiAgICBSRUZfWSA9IDEwMDtcbiAgICBSRUZfWiA9IDEwOC44ODM7XG4gICAgeCAvPSBSRUZfWDtcbiAgICB5IC89IFJFRl9ZO1xuICAgIHogLz0gUkVGX1o7XG4gICAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6IDcuNzg3ICogeCArIDE2IC8gMTE2O1xuICAgIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiA3Ljc4NyAqIHkgKyAxNiAvIDExNjtcbiAgICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMSAvIDMpIDogNy43ODcgKiB6ICsgMTYgLyAxMTY7XG4gICAgTCA9IDExNiAqIHkgLSAxNjtcbiAgICBhID0gNTAwICogKHggLSB5KTtcbiAgICBiID0gMjAwICogKHkgLSB6KTtcbiAgICByZXR1cm4gW0wsIGEsIGJdO1xuICB9LFxuICByZ2JUb0NJRUxhYjogZnVuY3Rpb24ociwgZywgYikge1xuICAgIHZhciByZWYsIHgsIHksIHo7XG4gICAgcmVmID0gdGhpcy5yZ2JUb1h5eihyLCBnLCBiKSwgeCA9IHJlZlswXSwgeSA9IHJlZlsxXSwgeiA9IHJlZlsyXTtcbiAgICByZXR1cm4gdGhpcy54eXpUb0NJRUxhYih4LCB5LCB6KTtcbiAgfSxcbiAgZGVsdGFFOTQ6IGZ1bmN0aW9uKGxhYjEsIGxhYjIpIHtcbiAgICB2YXIgTDEsIEwyLCBXRUlHSFRfQywgV0VJR0hUX0gsIFdFSUdIVF9MLCBhMSwgYTIsIGIxLCBiMiwgZEwsIGRhLCBkYiwgeEMxLCB4QzIsIHhEQywgeERFLCB4REgsIHhETCwgeFNDLCB4U0g7XG4gICAgV0VJR0hUX0wgPSAxO1xuICAgIFdFSUdIVF9DID0gMTtcbiAgICBXRUlHSFRfSCA9IDE7XG4gICAgTDEgPSBsYWIxWzBdLCBhMSA9IGxhYjFbMV0sIGIxID0gbGFiMVsyXTtcbiAgICBMMiA9IGxhYjJbMF0sIGEyID0gbGFiMlsxXSwgYjIgPSBsYWIyWzJdO1xuICAgIGRMID0gTDEgLSBMMjtcbiAgICBkYSA9IGExIC0gYTI7XG4gICAgZGIgPSBiMSAtIGIyO1xuICAgIHhDMSA9IE1hdGguc3FydChhMSAqIGExICsgYjEgKiBiMSk7XG4gICAgeEMyID0gTWF0aC5zcXJ0KGEyICogYTIgKyBiMiAqIGIyKTtcbiAgICB4REwgPSBMMiAtIEwxO1xuICAgIHhEQyA9IHhDMiAtIHhDMTtcbiAgICB4REUgPSBNYXRoLnNxcnQoZEwgKiBkTCArIGRhICogZGEgKyBkYiAqIGRiKTtcbiAgICBpZiAoTWF0aC5zcXJ0KHhERSkgPiBNYXRoLnNxcnQoTWF0aC5hYnMoeERMKSkgKyBNYXRoLnNxcnQoTWF0aC5hYnMoeERDKSkpIHtcbiAgICAgIHhESCA9IE1hdGguc3FydCh4REUgKiB4REUgLSB4REwgKiB4REwgLSB4REMgKiB4REMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4REggPSAwO1xuICAgIH1cbiAgICB4U0MgPSAxICsgMC4wNDUgKiB4QzE7XG4gICAgeFNIID0gMSArIDAuMDE1ICogeEMxO1xuICAgIHhETCAvPSBXRUlHSFRfTDtcbiAgICB4REMgLz0gV0VJR0hUX0MgKiB4U0M7XG4gICAgeERIIC89IFdFSUdIVF9IICogeFNIO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeERMICogeERMICsgeERDICogeERDICsgeERIICogeERIKTtcbiAgfSxcbiAgcmdiRGlmZjogZnVuY3Rpb24ocmdiMSwgcmdiMikge1xuICAgIHZhciBsYWIxLCBsYWIyO1xuICAgIGxhYjEgPSB0aGlzLnJnYlRvQ0lFTGFiLmFwcGx5KHRoaXMsIHJnYjEpO1xuICAgIGxhYjIgPSB0aGlzLnJnYlRvQ0lFTGFiLmFwcGx5KHRoaXMsIHJnYjIpO1xuICAgIHJldHVybiB0aGlzLmRlbHRhRTk0KGxhYjEsIGxhYjIpO1xuICB9LFxuICBoZXhEaWZmOiBmdW5jdGlvbihoZXgxLCBoZXgyKSB7XG4gICAgdmFyIHJnYjEsIHJnYjI7XG4gICAgcmdiMSA9IHRoaXMuaGV4VG9SZ2IoaGV4MSk7XG4gICAgcmdiMiA9IHRoaXMuaGV4VG9SZ2IoaGV4Mik7XG4gICAgcmV0dXJuIHRoaXMucmdiRGlmZihyZ2IxLCByZ2IyKTtcbiAgfSxcbiAgREVMVEFFOTRfRElGRl9TVEFUVVM6IERFTFRBRTk0LFxuICBnZXRDb2xvckRpZmZTdGF0dXM6IGZ1bmN0aW9uKGQpIHtcbiAgICBpZiAoZCA8IERFTFRBRTk0Lk5BKSB7XG4gICAgICByZXR1cm4gXCJOL0FcIjtcbiAgICB9XG4gICAgaWYgKGQgPD0gREVMVEFFOTQuUEVSRkVDVCkge1xuICAgICAgcmV0dXJuIFwiUGVyZmVjdFwiO1xuICAgIH1cbiAgICBpZiAoZCA8PSBERUxUQUU5NC5DTE9TRSkge1xuICAgICAgcmV0dXJuIFwiQ2xvc2VcIjtcbiAgICB9XG4gICAgaWYgKGQgPD0gREVMVEFFOTQuR09PRCkge1xuICAgICAgcmV0dXJuIFwiR29vZFwiO1xuICAgIH1cbiAgICBpZiAoZCA8IERFTFRBRTk0LlNJTUlMQVIpIHtcbiAgICAgIHJldHVybiBcIlNpbWlsYXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiV3JvbmdcIjtcbiAgfSxcbiAgU0lHQklUUzogU0lHQklUUyxcbiAgUlNISUZUOiBSU0hJRlQsXG4gIGdldENvbG9ySW5kZXg6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICByZXR1cm4gKHIgPDwgKDIgKiBTSUdCSVRTKSkgKyAoZyA8PCBTSUdCSVRTKSArIGI7XG4gIH1cbn07XG4iLCJcbi8qXG4gIEZyb20gVmlicmFudC5qcyBieSBKYXJpIFp3YXJ0c1xuICBQb3J0ZWQgdG8gbm9kZS5qcyBieSBBS0Zpc2hcblxuICBDb2xvciBhbGdvcml0aG0gY2xhc3MgdGhhdCBmaW5kcyB2YXJpYXRpb25zIG9uIGNvbG9ycyBpbiBhbiBpbWFnZS5cblxuICBDcmVkaXRzXG4gIC0tLS0tLS0tXG4gIExva2VzaCBEaGFrYXIgKGh0dHA6Ly93d3cubG9rZXNoZGhha2FyLmNvbSkgLSBDcmVhdGVkIENvbG9yVGhpZWZcbiAgR29vZ2xlIC0gUGFsZXR0ZSBzdXBwb3J0IGxpYnJhcnkgaW4gQW5kcm9pZFxuICovXG52YXIgQnVpbGRlciwgRGVmYXVsdEdlbmVyYXRvciwgRmlsdGVyLCBTd2F0Y2gsIFZpYnJhbnQsIHV0aWwsXG4gIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG5Td2F0Y2ggPSByZXF1aXJlKCcuL3N3YXRjaCcpO1xuXG51dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbkRlZmF1bHRHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2dlbmVyYXRvcicpLkRlZmF1bHQ7XG5cbkZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmlicmFudCA9IChmdW5jdGlvbigpIHtcbiAgVmlicmFudC5EZWZhdWx0T3B0cyA9IHtcbiAgICBjb2xvckNvdW50OiA2NCxcbiAgICBxdWFsaXR5OiA1LFxuICAgIGdlbmVyYXRvcjogbmV3IERlZmF1bHRHZW5lcmF0b3IoKSxcbiAgICBJbWFnZTogbnVsbCxcbiAgICBRdWFudGl6ZXI6IHJlcXVpcmUoJy4vcXVhbnRpemVyJykuTU1DUSxcbiAgICBmaWx0ZXJzOiBbXVxuICB9O1xuXG4gIFZpYnJhbnQuZnJvbSA9IGZ1bmN0aW9uKHNyYykge1xuICAgIHJldHVybiBuZXcgQnVpbGRlcihzcmMpO1xuICB9O1xuXG4gIFZpYnJhbnQucHJvdG90eXBlLnF1YW50aXplID0gcmVxdWlyZSgncXVhbnRpemUnKTtcblxuICBWaWJyYW50LnByb3RvdHlwZS5fc3dhdGNoZXMgPSBbXTtcblxuICBmdW5jdGlvbiBWaWJyYW50KHNvdXJjZUltYWdlLCBvcHRzKSB7XG4gICAgdGhpcy5zb3VyY2VJbWFnZSA9IHNvdXJjZUltYWdlO1xuICAgIGlmIChvcHRzID09IG51bGwpIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5zd2F0Y2hlcyA9IGJpbmQodGhpcy5zd2F0Y2hlcywgdGhpcyk7XG4gICAgdGhpcy5vcHRzID0gdXRpbC5kZWZhdWx0cyhvcHRzLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRPcHRzKTtcbiAgICB0aGlzLmdlbmVyYXRvciA9IHRoaXMub3B0cy5nZW5lcmF0b3I7XG4gIH1cblxuICBWaWJyYW50LnByb3RvdHlwZS5nZXRQYWxldHRlID0gZnVuY3Rpb24oY2IpIHtcbiAgICB2YXIgaW1hZ2U7XG4gICAgcmV0dXJuIGltYWdlID0gbmV3IHRoaXMub3B0cy5JbWFnZSh0aGlzLnNvdXJjZUltYWdlLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihlcnIsIGltYWdlKSB7XG4gICAgICAgIHZhciBlcnJvciwgZXJyb3IxO1xuICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIF90aGlzLl9wcm9jZXNzKGltYWdlLCBfdGhpcy5vcHRzKTtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgX3RoaXMuc3dhdGNoZXMoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICAgIGVycm9yID0gZXJyb3IxO1xuICAgICAgICAgIHJldHVybiBjYihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkodGhpcykpO1xuICB9O1xuXG4gIFZpYnJhbnQucHJvdG90eXBlLmdldFN3YXRjaGVzID0gZnVuY3Rpb24oY2IpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQYWxldHRlKGNiKTtcbiAgfTtcblxuICBWaWJyYW50LnByb3RvdHlwZS5fcHJvY2VzcyA9IGZ1bmN0aW9uKGltYWdlLCBvcHRzKSB7XG4gICAgdmFyIGltYWdlRGF0YSwgcXVhbnRpemVyLCBzd2F0Y2hlcztcbiAgICBpbWFnZS5zY2FsZURvd24odGhpcy5vcHRzKTtcbiAgICBpbWFnZURhdGEgPSBpbWFnZS5nZXRJbWFnZURhdGEoKTtcbiAgICBxdWFudGl6ZXIgPSBuZXcgdGhpcy5vcHRzLlF1YW50aXplcigpO1xuICAgIHF1YW50aXplci5pbml0aWFsaXplKGltYWdlRGF0YS5kYXRhLCB0aGlzLm9wdHMpO1xuICAgIHN3YXRjaGVzID0gcXVhbnRpemVyLmdldFF1YW50aXplZENvbG9ycygpO1xuICAgIHRoaXMuZ2VuZXJhdG9yLmdlbmVyYXRlKHN3YXRjaGVzKTtcbiAgICByZXR1cm4gaW1hZ2UucmVtb3ZlQ2FudmFzKCk7XG4gIH07XG5cbiAgVmlicmFudC5wcm90b3R5cGUuc3dhdGNoZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgVmlicmFudDogdGhpcy5nZW5lcmF0b3IuZ2V0VmlicmFudFN3YXRjaCgpLFxuICAgICAgTXV0ZWQ6IHRoaXMuZ2VuZXJhdG9yLmdldE11dGVkU3dhdGNoKCksXG4gICAgICBEYXJrVmlicmFudDogdGhpcy5nZW5lcmF0b3IuZ2V0RGFya1ZpYnJhbnRTd2F0Y2goKSxcbiAgICAgIERhcmtNdXRlZDogdGhpcy5nZW5lcmF0b3IuZ2V0RGFya011dGVkU3dhdGNoKCksXG4gICAgICBMaWdodFZpYnJhbnQ6IHRoaXMuZ2VuZXJhdG9yLmdldExpZ2h0VmlicmFudFN3YXRjaCgpLFxuICAgICAgTGlnaHRNdXRlZDogdGhpcy5nZW5lcmF0b3IuZ2V0TGlnaHRNdXRlZFN3YXRjaCgpXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gVmlicmFudDtcblxufSkoKTtcblxubW9kdWxlLmV4cG9ydHMuQnVpbGRlciA9IEJ1aWxkZXIgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEJ1aWxkZXIoc3JjMSwgb3B0czEpIHtcbiAgICB0aGlzLnNyYyA9IHNyYzE7XG4gICAgdGhpcy5vcHRzID0gb3B0czEgIT0gbnVsbCA/IG9wdHMxIDoge307XG4gICAgdGhpcy5vcHRzLmZpbHRlcnMgPSB1dGlsLmNsb25lKFZpYnJhbnQuRGVmYXVsdE9wdHMuZmlsdGVycyk7XG4gIH1cblxuICBCdWlsZGVyLnByb3RvdHlwZS5tYXhDb2xvckNvdW50ID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMub3B0cy5jb2xvckNvdW50ID0gbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCdWlsZGVyLnByb3RvdHlwZS5tYXhEaW1lbnNpb24gPSBmdW5jdGlvbihkKSB7XG4gICAgdGhpcy5vcHRzLm1heERpbWVuc2lvbiA9IGQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQnVpbGRlci5wcm90b3R5cGUuYWRkRmlsdGVyID0gZnVuY3Rpb24oZikge1xuICAgIGlmICh0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5vcHRzLmZpbHRlcnMucHVzaChmKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQnVpbGRlci5wcm90b3R5cGUucmVtb3ZlRmlsdGVyID0gZnVuY3Rpb24oZikge1xuICAgIHZhciBpO1xuICAgIGlmICgoaSA9IHRoaXMub3B0cy5maWx0ZXJzLmluZGV4T2YoZikpID4gMCkge1xuICAgICAgdGhpcy5vcHRzLmZpbHRlcnMuc3BsaWNlKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCdWlsZGVyLnByb3RvdHlwZS5jbGVhckZpbHRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9wdHMuZmlsdGVycyA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJ1aWxkZXIucHJvdG90eXBlLnF1YWxpdHkgPSBmdW5jdGlvbihxKSB7XG4gICAgdGhpcy5vcHRzLnF1YWxpdHkgPSBxO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJ1aWxkZXIucHJvdG90eXBlLnVzZUltYWdlID0gZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICB0aGlzLm9wdHMuSW1hZ2UgPSBpbWFnZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCdWlsZGVyLnByb3RvdHlwZS51c2VHZW5lcmF0b3IgPSBmdW5jdGlvbihnZW5lcmF0b3IpIHtcbiAgICB0aGlzLm9wdHMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJ1aWxkZXIucHJvdG90eXBlLnVzZVF1YW50aXplciA9IGZ1bmN0aW9uKHF1YW50aXplcikge1xuICAgIHRoaXMub3B0cy5RdWFudGl6ZXIgPSBxdWFudGl6ZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy52ID09IG51bGwpIHtcbiAgICAgIHRoaXMudiA9IG5ldyBWaWJyYW50KHRoaXMuc3JjLCB0aGlzLm9wdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52O1xuICB9O1xuXG4gIEJ1aWxkZXIucHJvdG90eXBlLmdldFN3YXRjaGVzID0gZnVuY3Rpb24oY2IpIHtcbiAgICByZXR1cm4gdGhpcy5idWlsZCgpLmdldFBhbGV0dGUoY2IpO1xuICB9O1xuXG4gIEJ1aWxkZXIucHJvdG90eXBlLmdldFBhbGV0dGUgPSBmdW5jdGlvbihjYikge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkKCkuZ2V0UGFsZXR0ZShjYik7XG4gIH07XG5cbiAgQnVpbGRlci5wcm90b3R5cGUuZnJvbSA9IGZ1bmN0aW9uKHNyYykge1xuICAgIHJldHVybiBuZXcgVmlicmFudChzcmMsIHRoaXMub3B0cyk7XG4gIH07XG5cbiAgcmV0dXJuIEJ1aWxkZXI7XG5cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzLlV0aWwgPSB1dGlsO1xuXG5tb2R1bGUuZXhwb3J0cy5Td2F0Y2ggPSBTd2F0Y2g7XG5cbm1vZHVsZS5leHBvcnRzLlF1YW50aXplciA9IHJlcXVpcmUoJy4vcXVhbnRpemVyLycpO1xuXG5tb2R1bGUuZXhwb3J0cy5HZW5lcmF0b3IgPSByZXF1aXJlKCcuL2dlbmVyYXRvci8nKTtcblxubW9kdWxlLmV4cG9ydHMuRmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXIvJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLypcbiAqIHF1YW50aXplLmpzIENvcHlyaWdodCAyMDA4IE5pY2sgUmFiaW5vd2l0elxuICogUG9ydGVkIHRvIG5vZGUuanMgYnkgT2xpdmllciBMZXNuaWNraVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICovXG5cbi8vIGZpbGwgb3V0IGEgY291cGxlIHByb3RvdmlzIGRlcGVuZGVuY2llc1xuLypcbiAqIEJsb2NrIGJlbG93IGNvcGllZCBmcm9tIFByb3RvdmlzOiBodHRwOi8vbWJvc3RvY2suZ2l0aHViLmNvbS9wcm90b3Zpcy9cbiAqIENvcHlyaWdodCAyMDEwIFN0YW5mb3JkIFZpc3VhbGl6YXRpb24gR3JvdXBcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZTogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9ic2QtbGljZW5zZS5waHBcbiAqL1xuaWYgKCFwdikge1xuICAgIHZhciBwdiA9IHtcbiAgICAgICAgbWFwOiBmdW5jdGlvbihhcnJheSwgZikge1xuICAgICAgICAgICAgdmFyIG8gPSB7fTtcbiAgICAgICAgICAgIHJldHVybiBmID8gYXJyYXkubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICBvLmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5jYWxsKG8sIGQpO1xuICAgICAgICAgICAgfSkgOiBhcnJheS5zbGljZSgpO1xuICAgICAgICB9LFxuICAgICAgICBuYXR1cmFsT3JkZXI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYSA8IGIpID8gLTEgOiAoKGEgPiBiKSA/IDEgOiAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3VtOiBmdW5jdGlvbihhcnJheSwgZikge1xuICAgICAgICAgICAgdmFyIG8gPSB7fTtcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5yZWR1Y2UoZiA/IGZ1bmN0aW9uKHAsIGQsIGkpIHtcbiAgICAgICAgICAgICAgICBvLmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcCArIGYuY2FsbChvLCBkKTtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihwLCBkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAgKyBkO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1heDogZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBmID8gcHYubWFwKGFycmF5LCBmKSA6IGFycmF5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBCYXNpYyBKYXZhc2NyaXB0IHBvcnQgb2YgdGhlIE1NQ1EgKG1vZGlmaWVkIG1lZGlhbiBjdXQgcXVhbnRpemF0aW9uKVxuICogYWxnb3JpdGhtIGZyb20gdGhlIExlcHRvbmljYSBsaWJyYXJ5IChodHRwOi8vd3d3LmxlcHRvbmljYS5jb20vKS5cbiAqIFJldHVybnMgYSBjb2xvciBtYXAgeW91IGNhbiB1c2UgdG8gbWFwIG9yaWdpbmFsIHBpeGVscyB0byB0aGUgcmVkdWNlZFxuICogcGFsZXR0ZS4gU3RpbGwgYSB3b3JrIGluIHByb2dyZXNzLlxuICogXG4gKiBAYXV0aG9yIE5pY2sgUmFiaW5vd2l0elxuICogQGV4YW1wbGVcbiBcbi8vIGFycmF5IG9mIHBpeGVscyBhcyBbUixHLEJdIGFycmF5c1xudmFyIG15UGl4ZWxzID0gW1sxOTAsMTk3LDE5MF0sIFsyMDIsMjA0LDIwMF0sIFsyMDcsMjE0LDIxMF0sIFsyMTEsMjE0LDIxMV0sIFsyMDUsMjA3LDIwN11cbiAgICAgICAgICAgICAgICAvLyBldGNcbiAgICAgICAgICAgICAgICBdO1xudmFyIG1heENvbG9ycyA9IDQ7XG4gXG52YXIgY21hcCA9IE1NQ1EucXVhbnRpemUobXlQaXhlbHMsIG1heENvbG9ycyk7XG52YXIgbmV3UGFsZXR0ZSA9IGNtYXAucGFsZXR0ZSgpO1xudmFyIG5ld1BpeGVscyA9IG15UGl4ZWxzLm1hcChmdW5jdGlvbihwKSB7IFxuICAgIHJldHVybiBjbWFwLm1hcChwKTsgXG59KTtcbiBcbiAqL1xudmFyIE1NQ1EgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gcHJpdmF0ZSBjb25zdGFudHNcbiAgICB2YXIgc2lnYml0cyA9IDUsXG4gICAgICAgIHJzaGlmdCA9IDggLSBzaWdiaXRzLFxuICAgICAgICBtYXhJdGVyYXRpb25zID0gMTAwMCxcbiAgICAgICAgZnJhY3RCeVBvcHVsYXRpb25zID0gMC43NTtcblxuICAgIC8vIGdldCByZWR1Y2VkLXNwYWNlIGNvbG9yIGluZGV4IGZvciBhIHBpeGVsXG5cbiAgICBmdW5jdGlvbiBnZXRDb2xvckluZGV4KHIsIGcsIGIpIHtcbiAgICAgICAgcmV0dXJuIChyIDw8ICgyICogc2lnYml0cykpICsgKGcgPDwgc2lnYml0cykgKyBiO1xuICAgIH1cblxuICAgIC8vIFNpbXBsZSBwcmlvcml0eSBxdWV1ZVxuXG4gICAgZnVuY3Rpb24gUFF1ZXVlKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRzID0gW10sXG4gICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBzb3J0KCkge1xuICAgICAgICAgICAgY29udGVudHMuc29ydChjb21wYXJhdG9yKTtcbiAgICAgICAgICAgIHNvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzLnB1c2gobyk7XG4gICAgICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGVlazogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNvcnRlZCkgc29ydCgpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSBpbmRleCA9IGNvbnRlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzW2luZGV4XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghc29ydGVkKSBzb3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzLnBvcCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFwOiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzLm1hcChmKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWJ1ZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzb3J0ZWQpIHNvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gM2QgY29sb3Igc3BhY2UgYm94XG5cbiAgICBmdW5jdGlvbiBWQm94KHIxLCByMiwgZzEsIGcyLCBiMSwgYjIsIGhpc3RvKSB7XG4gICAgICAgIHZhciB2Ym94ID0gdGhpcztcbiAgICAgICAgdmJveC5yMSA9IHIxO1xuICAgICAgICB2Ym94LnIyID0gcjI7XG4gICAgICAgIHZib3guZzEgPSBnMTtcbiAgICAgICAgdmJveC5nMiA9IGcyO1xuICAgICAgICB2Ym94LmIxID0gYjE7XG4gICAgICAgIHZib3guYjIgPSBiMjtcbiAgICAgICAgdmJveC5oaXN0byA9IGhpc3RvO1xuICAgIH1cbiAgICBWQm94LnByb3RvdHlwZSA9IHtcbiAgICAgICAgdm9sdW1lOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICAgICAgdmFyIHZib3ggPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF2Ym94Ll92b2x1bWUgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgICAgICB2Ym94Ll92b2x1bWUgPSAoKHZib3gucjIgLSB2Ym94LnIxICsgMSkgKiAodmJveC5nMiAtIHZib3guZzEgKyAxKSAqICh2Ym94LmIyIC0gdmJveC5iMSArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2Ym94Ll92b2x1bWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvdW50OiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICAgICAgdmFyIHZib3ggPSB0aGlzLFxuICAgICAgICAgICAgICAgIGhpc3RvID0gdmJveC5oaXN0bztcbiAgICAgICAgICAgIGlmICghdmJveC5fY291bnRfc2V0IHx8IGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5waXggPSAwLFxuICAgICAgICAgICAgICAgICAgICBpLCBqLCBrLCBpbmRleDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSB2Ym94LnIxOyBpIDw9IHZib3gucjI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSB2Ym94LmcxOyBqIDw9IHZib3guZzI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gdmJveC5iMTsgayA8PSB2Ym94LmIyOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGdldENvbG9ySW5kZXgoaSwgaiwgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnBpeCArPSAoaGlzdG9baW5kZXhdIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZib3guX2NvdW50ID0gbnBpeDtcbiAgICAgICAgICAgICAgICB2Ym94Ll9jb3VudF9zZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZib3guX2NvdW50O1xuICAgICAgICB9LFxuICAgICAgICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2Ym94ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgVkJveCh2Ym94LnIxLCB2Ym94LnIyLCB2Ym94LmcxLCB2Ym94LmcyLCB2Ym94LmIxLCB2Ym94LmIyLCB2Ym94Lmhpc3RvKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXZnOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICAgICAgdmFyIHZib3ggPSB0aGlzLFxuICAgICAgICAgICAgICAgIGhpc3RvID0gdmJveC5oaXN0bztcbiAgICAgICAgICAgIGlmICghdmJveC5fYXZnIHx8IGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG50b3QgPSAwLFxuICAgICAgICAgICAgICAgICAgICBtdWx0ID0gMSA8PCAoOCAtIHNpZ2JpdHMpLFxuICAgICAgICAgICAgICAgICAgICByc3VtID0gMCxcbiAgICAgICAgICAgICAgICAgICAgZ3N1bSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGJzdW0gPSAwLFxuICAgICAgICAgICAgICAgICAgICBodmFsLFxuICAgICAgICAgICAgICAgICAgICBpLCBqLCBrLCBoaXN0b2luZGV4O1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IHZib3gucjE7IGkgPD0gdmJveC5yMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IHZib3guZzE7IGogPD0gdmJveC5nMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSB2Ym94LmIxOyBrIDw9IHZib3guYjI7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RvaW5kZXggPSBnZXRDb2xvckluZGV4KGksIGosIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh2YWwgPSBoaXN0b1toaXN0b2luZGV4XSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG50b3QgKz0gaHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByc3VtICs9IChodmFsICogKGkgKyAwLjUpICogbXVsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3N1bSArPSAoaHZhbCAqIChqICsgMC41KSAqIG11bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJzdW0gKz0gKGh2YWwgKiAoayArIDAuNSkgKiBtdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobnRvdCkge1xuICAgICAgICAgICAgICAgICAgICB2Ym94Ll9hdmcgPSBbfn4ocnN1bSAvIG50b3QpLCB+fiAoZ3N1bSAvIG50b3QpLCB+fiAoYnN1bSAvIG50b3QpXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdlbXB0eSBib3gnKTtcbiAgICAgICAgICAgICAgICAgICAgdmJveC5fYXZnID0gW35+KG11bHQgKiAodmJveC5yMSArIHZib3gucjIgKyAxKSAvIDIpLCB+fiAobXVsdCAqICh2Ym94LmcxICsgdmJveC5nMiArIDEpIC8gMiksIH5+IChtdWx0ICogKHZib3guYjEgKyB2Ym94LmIyICsgMSkgLyAyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZib3guX2F2ZztcbiAgICAgICAgfSxcbiAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICAgICAgICB2YXIgdmJveCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcnZhbCA9IHBpeGVsWzBdID4+IHJzaGlmdDtcbiAgICAgICAgICAgIGd2YWwgPSBwaXhlbFsxXSA+PiByc2hpZnQ7XG4gICAgICAgICAgICBidmFsID0gcGl4ZWxbMl0gPj4gcnNoaWZ0O1xuICAgICAgICAgICAgcmV0dXJuIChydmFsID49IHZib3gucjEgJiYgcnZhbCA8PSB2Ym94LnIyICYmXG4gICAgICAgICAgICAgICAgZ3ZhbCA+PSB2Ym94LmcxICYmIGd2YWwgPD0gdmJveC5nMiAmJlxuICAgICAgICAgICAgICAgIGJ2YWwgPj0gdmJveC5iMSAmJiBidmFsIDw9IHZib3guYjIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENvbG9yIG1hcFxuXG4gICAgZnVuY3Rpb24gQ01hcCgpIHtcbiAgICAgICAgdGhpcy52Ym94ZXMgPSBuZXcgUFF1ZXVlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBwdi5uYXR1cmFsT3JkZXIoXG4gICAgICAgICAgICAgICAgYS52Ym94LmNvdW50KCkgKiBhLnZib3gudm9sdW1lKCksXG4gICAgICAgICAgICAgICAgYi52Ym94LmNvdW50KCkgKiBiLnZib3gudm9sdW1lKClcbiAgICAgICAgICAgIClcbiAgICAgICAgfSk7O1xuICAgIH1cbiAgICBDTWFwLnByb3RvdHlwZSA9IHtcbiAgICAgICAgcHVzaDogZnVuY3Rpb24odmJveCkge1xuICAgICAgICAgICAgdGhpcy52Ym94ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdmJveDogdmJveCxcbiAgICAgICAgICAgICAgICBjb2xvcjogdmJveC5hdmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhbGV0dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmJveGVzLm1hcChmdW5jdGlvbih2Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2Yi5jb2xvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmJveGVzLnNpemUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFwOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgdmFyIHZib3hlcyA9IHRoaXMudmJveGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Ym94ZXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmJveGVzLnBlZWsoaSkudmJveC5jb250YWlucyhjb2xvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZib3hlcy5wZWVrKGkpLmNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lYXJlc3QoY29sb3IpO1xuICAgICAgICB9LFxuICAgICAgICBuZWFyZXN0OiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgdmFyIHZib3hlcyA9IHRoaXMudmJveGVzLFxuICAgICAgICAgICAgICAgIGQxLCBkMiwgcENvbG9yO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Ym94ZXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkMiA9IE1hdGguc3FydChcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coY29sb3JbMF0gLSB2Ym94ZXMucGVlayhpKS5jb2xvclswXSwgMikgK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhjb2xvclsxXSAtIHZib3hlcy5wZWVrKGkpLmNvbG9yWzFdLCAyKSArXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KGNvbG9yWzJdIC0gdmJveGVzLnBlZWsoaSkuY29sb3JbMl0sIDIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZDIgPCBkMSB8fCBkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGQxID0gZDI7XG4gICAgICAgICAgICAgICAgICAgIHBDb2xvciA9IHZib3hlcy5wZWVrKGkpLmNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcmNlYnc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gWFhYOiB3b24ndCAgd29yayB5ZXRcbiAgICAgICAgICAgIHZhciB2Ym94ZXMgPSB0aGlzLnZib3hlcztcbiAgICAgICAgICAgIHZib3hlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHYubmF0dXJhbE9yZGVyKHB2LnN1bShhLmNvbG9yKSwgcHYuc3VtKGIuY29sb3IpKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGZvcmNlIGRhcmtlc3QgY29sb3IgdG8gYmxhY2sgaWYgZXZlcnl0aGluZyA8IDVcbiAgICAgICAgICAgIHZhciBsb3dlc3QgPSB2Ym94ZXNbMF0uY29sb3I7XG4gICAgICAgICAgICBpZiAobG93ZXN0WzBdIDwgNSAmJiBsb3dlc3RbMV0gPCA1ICYmIGxvd2VzdFsyXSA8IDUpXG4gICAgICAgICAgICAgICAgdmJveGVzWzBdLmNvbG9yID0gWzAsIDAsIDBdO1xuXG4gICAgICAgICAgICAvLyBmb3JjZSBsaWdodGVzdCBjb2xvciB0byB3aGl0ZSBpZiBldmVyeXRoaW5nID4gMjUxXG4gICAgICAgICAgICB2YXIgaWR4ID0gdmJveGVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgaGlnaGVzdCA9IHZib3hlc1tpZHhdLmNvbG9yO1xuICAgICAgICAgICAgaWYgKGhpZ2hlc3RbMF0gPiAyNTEgJiYgaGlnaGVzdFsxXSA+IDI1MSAmJiBoaWdoZXN0WzJdID4gMjUxKVxuICAgICAgICAgICAgICAgIHZib3hlc1tpZHhdLmNvbG9yID0gWzI1NSwgMjU1LCAyNTVdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGhpc3RvICgxLWQgYXJyYXksIGdpdmluZyB0aGUgbnVtYmVyIG9mIHBpeGVscyBpblxuICAgIC8vIGVhY2ggcXVhbnRpemVkIHJlZ2lvbiBvZiBjb2xvciBzcGFjZSksIG9yIG51bGwgb24gZXJyb3JcblxuICAgIGZ1bmN0aW9uIGdldEhpc3RvKHBpeGVscykge1xuICAgICAgICB2YXIgaGlzdG9zaXplID0gMSA8PCAoMyAqIHNpZ2JpdHMpLFxuICAgICAgICAgICAgaGlzdG8gPSBuZXcgQXJyYXkoaGlzdG9zaXplKSxcbiAgICAgICAgICAgIGluZGV4LCBydmFsLCBndmFsLCBidmFsO1xuICAgICAgICBwaXhlbHMuZm9yRWFjaChmdW5jdGlvbihwaXhlbCkge1xuICAgICAgICAgICAgcnZhbCA9IHBpeGVsWzBdID4+IHJzaGlmdDtcbiAgICAgICAgICAgIGd2YWwgPSBwaXhlbFsxXSA+PiByc2hpZnQ7XG4gICAgICAgICAgICBidmFsID0gcGl4ZWxbMl0gPj4gcnNoaWZ0O1xuICAgICAgICAgICAgaW5kZXggPSBnZXRDb2xvckluZGV4KHJ2YWwsIGd2YWwsIGJ2YWwpO1xuICAgICAgICAgICAgaGlzdG9baW5kZXhdID0gKGhpc3RvW2luZGV4XSB8fCAwKSArIDE7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGlzdG87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmJveEZyb21QaXhlbHMocGl4ZWxzLCBoaXN0bykge1xuICAgICAgICB2YXIgcm1pbiA9IDEwMDAwMDAsXG4gICAgICAgICAgICBybWF4ID0gMCxcbiAgICAgICAgICAgIGdtaW4gPSAxMDAwMDAwLFxuICAgICAgICAgICAgZ21heCA9IDAsXG4gICAgICAgICAgICBibWluID0gMTAwMDAwMCxcbiAgICAgICAgICAgIGJtYXggPSAwLFxuICAgICAgICAgICAgcnZhbCwgZ3ZhbCwgYnZhbDtcbiAgICAgICAgLy8gZmluZCBtaW4vbWF4XG4gICAgICAgIHBpeGVscy5mb3JFYWNoKGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICAgICAgICBydmFsID0gcGl4ZWxbMF0gPj4gcnNoaWZ0O1xuICAgICAgICAgICAgZ3ZhbCA9IHBpeGVsWzFdID4+IHJzaGlmdDtcbiAgICAgICAgICAgIGJ2YWwgPSBwaXhlbFsyXSA+PiByc2hpZnQ7XG4gICAgICAgICAgICBpZiAocnZhbCA8IHJtaW4pIHJtaW4gPSBydmFsO1xuICAgICAgICAgICAgZWxzZSBpZiAocnZhbCA+IHJtYXgpIHJtYXggPSBydmFsO1xuICAgICAgICAgICAgaWYgKGd2YWwgPCBnbWluKSBnbWluID0gZ3ZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGd2YWwgPiBnbWF4KSBnbWF4ID0gZ3ZhbDtcbiAgICAgICAgICAgIGlmIChidmFsIDwgYm1pbikgYm1pbiA9IGJ2YWw7XG4gICAgICAgICAgICBlbHNlIGlmIChidmFsID4gYm1heCkgYm1heCA9IGJ2YWw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFZCb3gocm1pbiwgcm1heCwgZ21pbiwgZ21heCwgYm1pbiwgYm1heCwgaGlzdG8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lZGlhbkN1dEFwcGx5KGhpc3RvLCB2Ym94KSB7XG4gICAgICAgIGlmICghdmJveC5jb3VudCgpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHJ3ID0gdmJveC5yMiAtIHZib3gucjEgKyAxLFxuICAgICAgICAgICAgZ3cgPSB2Ym94LmcyIC0gdmJveC5nMSArIDEsXG4gICAgICAgICAgICBidyA9IHZib3guYjIgLSB2Ym94LmIxICsgMSxcbiAgICAgICAgICAgIG1heHcgPSBwdi5tYXgoW3J3LCBndywgYnddKTtcbiAgICAgICAgLy8gb25seSBvbmUgcGl4ZWwsIG5vIHNwbGl0XG4gICAgICAgIGlmICh2Ym94LmNvdW50KCkgPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFt2Ym94LmNvcHkoKV1cbiAgICAgICAgfVxuICAgICAgICAvKiBGaW5kIHRoZSBwYXJ0aWFsIHN1bSBhcnJheXMgYWxvbmcgdGhlIHNlbGVjdGVkIGF4aXMuICovXG4gICAgICAgIHZhciB0b3RhbCA9IDAsXG4gICAgICAgICAgICBwYXJ0aWFsc3VtID0gW10sXG4gICAgICAgICAgICBsb29rYWhlYWRzdW0gPSBbXSxcbiAgICAgICAgICAgIGksIGosIGssIHN1bSwgaW5kZXg7XG4gICAgICAgIGlmIChtYXh3ID09IHJ3KSB7XG4gICAgICAgICAgICBmb3IgKGkgPSB2Ym94LnIxOyBpIDw9IHZib3gucjI7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gdmJveC5nMTsgaiA8PSB2Ym94LmcyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gdmJveC5iMTsgayA8PSB2Ym94LmIyOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZ2V0Q29sb3JJbmRleChpLCBqLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSAoaGlzdG9baW5kZXhdIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdGFsICs9IHN1bTtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsc3VtW2ldID0gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWF4dyA9PSBndykge1xuICAgICAgICAgICAgZm9yIChpID0gdmJveC5nMTsgaSA8PSB2Ym94LmcyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IHZib3gucjE7IGogPD0gdmJveC5yMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IHZib3guYjE7IGsgPD0gdmJveC5iMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGdldENvbG9ySW5kZXgoaiwgaSwgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gKGhpc3RvW2luZGV4XSB8fCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbCArPSBzdW07XG4gICAgICAgICAgICAgICAgcGFydGlhbHN1bVtpXSA9IHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvKiBtYXh3ID09IGJ3ICovXG4gICAgICAgICAgICBmb3IgKGkgPSB2Ym94LmIxOyBpIDw9IHZib3guYjI7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gdmJveC5yMTsgaiA8PSB2Ym94LnIyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gdmJveC5nMTsgayA8PSB2Ym94LmcyOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZ2V0Q29sb3JJbmRleChqLCBrLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSAoaGlzdG9baW5kZXhdIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdGFsICs9IHN1bTtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsc3VtW2ldID0gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFydGlhbHN1bS5mb3JFYWNoKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIGxvb2thaGVhZHN1bVtpXSA9IHRvdGFsIC0gZFxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBkb0N1dChjb2xvcikge1xuICAgICAgICAgICAgdmFyIGRpbTEgPSBjb2xvciArICcxJyxcbiAgICAgICAgICAgICAgICBkaW0yID0gY29sb3IgKyAnMicsXG4gICAgICAgICAgICAgICAgbGVmdCwgcmlnaHQsIHZib3gxLCB2Ym94MiwgZDIsIGNvdW50MiA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSB2Ym94W2RpbTFdOyBpIDw9IHZib3hbZGltMl07IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsc3VtW2ldID4gdG90YWwgLyAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZib3gxID0gdmJveC5jb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgIHZib3gyID0gdmJveC5jb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpIC0gdmJveFtkaW0xXTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB2Ym94W2RpbTJdIC0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPD0gcmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBkMiA9IE1hdGgubWluKHZib3hbZGltMl0gLSAxLCB+fiAoaSArIHJpZ2h0IC8gMikpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGQyID0gTWF0aC5tYXgodmJveFtkaW0xXSwgfn4gKGkgLSAxIC0gbGVmdCAvIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgMC1jb3VudCBib3hlc1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXBhcnRpYWxzdW1bZDJdKSBkMisrO1xuICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSBsb29rYWhlYWRzdW1bZDJdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIWNvdW50MiAmJiBwYXJ0aWFsc3VtW2QyIC0gMV0pIGNvdW50MiA9IGxvb2thaGVhZHN1bVstLWQyXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgdmJveDFbZGltMl0gPSBkMjtcbiAgICAgICAgICAgICAgICAgICAgdmJveDJbZGltMV0gPSB2Ym94MVtkaW0yXSArIDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd2Ym94IGNvdW50czonLCB2Ym94LmNvdW50KCksIHZib3gxLmNvdW50KCksIHZib3gyLmNvdW50KCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Zib3gxLCB2Ym94Ml07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBjdXQgcGxhbmVzXG4gICAgICAgIHJldHVybiBtYXh3ID09IHJ3ID8gZG9DdXQoJ3InKSA6XG4gICAgICAgICAgICBtYXh3ID09IGd3ID8gZG9DdXQoJ2cnKSA6XG4gICAgICAgICAgICBkb0N1dCgnYicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHF1YW50aXplKHBpeGVscywgbWF4Y29sb3JzKSB7XG4gICAgICAgIC8vIHNob3J0LWNpcmN1aXRcbiAgICAgICAgaWYgKCFwaXhlbHMubGVuZ3RoIHx8IG1heGNvbG9ycyA8IDIgfHwgbWF4Y29sb3JzID4gMjU2KSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnd3JvbmcgbnVtYmVyIG9mIG1heGNvbG9ycycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWFhYOiBjaGVjayBjb2xvciBjb250ZW50IGFuZCBjb252ZXJ0IHRvIGdyYXlzY2FsZSBpZiBpbnN1ZmZpY2llbnRcblxuICAgICAgICB2YXIgaGlzdG8gPSBnZXRIaXN0byhwaXhlbHMpLFxuICAgICAgICAgICAgaGlzdG9zaXplID0gMSA8PCAoMyAqIHNpZ2JpdHMpO1xuXG4gICAgICAgIC8vIGNoZWNrIHRoYXQgd2UgYXJlbid0IGJlbG93IG1heGNvbG9ycyBhbHJlYWR5XG4gICAgICAgIHZhciBuQ29sb3JzID0gMDtcbiAgICAgICAgaGlzdG8uZm9yRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG5Db2xvcnMrK1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5Db2xvcnMgPD0gbWF4Y29sb3JzKSB7XG4gICAgICAgICAgICAvLyBYWFg6IGdlbmVyYXRlIHRoZSBuZXcgY29sb3JzIGZyb20gdGhlIGhpc3RvIGFuZCByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgYmVnaW5uaW5nIHZib3ggZnJvbSB0aGUgY29sb3JzXG4gICAgICAgIHZhciB2Ym94ID0gdmJveEZyb21QaXhlbHMocGl4ZWxzLCBoaXN0byksXG4gICAgICAgICAgICBwcSA9IG5ldyBQUXVldWUoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwdi5uYXR1cmFsT3JkZXIoYS5jb3VudCgpLCBiLmNvdW50KCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcHEucHVzaCh2Ym94KTtcblxuICAgICAgICAvLyBpbm5lciBmdW5jdGlvbiB0byBkbyB0aGUgaXRlcmF0aW9uXG5cbiAgICAgICAgZnVuY3Rpb24gaXRlcihsaCwgdGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgbmNvbG9ycyA9IDEsXG4gICAgICAgICAgICAgICAgbml0ZXJzID0gMCxcbiAgICAgICAgICAgICAgICB2Ym94O1xuICAgICAgICAgICAgd2hpbGUgKG5pdGVycyA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2Ym94ID0gbGgucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF2Ym94LmNvdW50KCkpIHsgLyoganVzdCBwdXQgaXQgYmFjayAqL1xuICAgICAgICAgICAgICAgICAgICBsaC5wdXNoKHZib3gpO1xuICAgICAgICAgICAgICAgICAgICBuaXRlcnMrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvIHRoZSBjdXRcbiAgICAgICAgICAgICAgICB2YXIgdmJveGVzID0gbWVkaWFuQ3V0QXBwbHkoaGlzdG8sIHZib3gpLFxuICAgICAgICAgICAgICAgICAgICB2Ym94MSA9IHZib3hlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgdmJveDIgPSB2Ym94ZXNbMV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXZib3gxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwidmJveDEgbm90IGRlZmluZWQ7IHNob3VsZG4ndCBoYXBwZW4hXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxoLnB1c2godmJveDEpO1xuICAgICAgICAgICAgICAgIGlmICh2Ym94MikgeyAvKiB2Ym94MiBjYW4gYmUgbnVsbCAqL1xuICAgICAgICAgICAgICAgICAgICBsaC5wdXNoKHZib3gyKTtcbiAgICAgICAgICAgICAgICAgICAgbmNvbG9ycysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmNvbG9ycyA+PSB0YXJnZXQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAobml0ZXJzKysgPiBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiaW5maW5pdGUgbG9vcDsgcGVyaGFwcyB0b28gZmV3IHBpeGVscyFcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCBzZXQgb2YgY29sb3JzLCBzb3J0ZWQgYnkgcG9wdWxhdGlvblxuICAgICAgICBpdGVyKHBxLCBmcmFjdEJ5UG9wdWxhdGlvbnMgKiBtYXhjb2xvcnMpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhwcS5zaXplKCksIHBxLmRlYnVnKCkubGVuZ3RoLCBwcS5kZWJ1ZygpLnNsaWNlKCkpO1xuXG4gICAgICAgIC8vIFJlLXNvcnQgYnkgdGhlIHByb2R1Y3Qgb2YgcGl4ZWwgb2NjdXBhbmN5IHRpbWVzIHRoZSBzaXplIGluIGNvbG9yIHNwYWNlLlxuICAgICAgICB2YXIgcHEyID0gbmV3IFBRdWV1ZShmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gcHYubmF0dXJhbE9yZGVyKGEuY291bnQoKSAqIGEudm9sdW1lKCksIGIuY291bnQoKSAqIGIudm9sdW1lKCkpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAocHEuc2l6ZSgpKSB7XG4gICAgICAgICAgICBwcTIucHVzaChwcS5wb3AoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBuZXh0IHNldCAtIGdlbmVyYXRlIHRoZSBtZWRpYW4gY3V0cyB1c2luZyB0aGUgKG5waXggKiB2b2wpIHNvcnRpbmcuXG4gICAgICAgIGl0ZXIocHEyLCBtYXhjb2xvcnMgLSBwcTIuc2l6ZSgpKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGFjdHVhbCBjb2xvcnNcbiAgICAgICAgdmFyIGNtYXAgPSBuZXcgQ01hcCgpO1xuICAgICAgICB3aGlsZSAocHEyLnNpemUoKSkge1xuICAgICAgICAgICAgY21hcC5wdXNoKHBxMi5wb3AoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY21hcDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBxdWFudGl6ZTogcXVhbnRpemVcbiAgICB9XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1NQ1EucXVhbnRpemVcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwidmFyINWQ1Y9fMSwg1ZDVj18yLCDVkNWPXzMsINWQ1Y9fNCwg1ZDVj181LCDVkNWPXzYsINWQ1Y9fNywg1ZDVj184LCDVkNWPXzksINWQ1Y9fMTAsINWQ1Y9fMTEsINWQ1Y9fMTIsINWQ1Y9fMTMsINWQ1Y9fMTQsINWQ1Y9fMTUsINWQ1Y9fMTYsINWQ1Y9fMTcsINWQ1Y9fMTgsINWQ1Y9fMTksINWQ1Y9fMjAsINWQ1Y9fMjEsINWQ1Y9fMjIsINWQ1Y9fMjMsINWQ1Y9fMjQsINWQ1Y9fMjUsINWQ1Y9fMjYsINWQ1Y9fMjcsINWQ1Y9fMjgsINWQ1Y9fMjksINWQ1Y9fMzEsINWQ1Y9fMzIsINWQ1Y9fMzMsINWQ1Y9fMzQsINWQ1Y9fMzUsINWQ1Y9fMzYsINWQ1Y9fMzcsINWQ1Y9fMzgsINWQ1Y9fMzksINWQ1Y9fNDAsINWQ1Y9fNDEsINWQ1Y9fNDIsINWQ1Y9fNDMsINWQ1Y9fNDQsINWQ1Y9fNDUsINWQ1Y9fNDYsINWQ1Y9fNDcsINWQ1Y9fNDgsINWQ1Y9fNDksINWQ1Y9fNTAsINWQ1Y9fNTEsINWQ1Y9fNTIsINWQ1Y9fNTMsINWQ1Y9fNTQsINWQ1Y9fNTUsINWQ1Y9fNTYsINWQ1Y9fNTcsINWQ1Y9fNTgsINWQ1Y9fNTksINWQ1Y9fNjAsINWQ1Y9fNjIsINWQ1Y9fNjMsINWQ1Y9fNjQsINWQ1Y9fNjUsINWQ1Y9fNjYsINWQ1Y9fNjcsINWQ1Y9fNjgsINWQ1Y9fNjksINWQ1Y9fNzAsINWQ1Y9fNzEsINWQ1Y9fNzIsINWQ1Y9fNzMsINWQ1Y9fNzQsINWQ1Y9fNzUsINWQ1Y9fNzYsINWQ1Y9fNzcsINWQ1Y9fNzgsINWQ1Y9fNzksINWQ1Y9fODAsINWQ1Y9fODEsINWQ1Y9fODIsINWQ1Y9fODMsINWQ1Y9fODQsINWQ1Y9fODUsINWQ1Y9fODYsINWQ1Y9fODcsINWQ1Y9fODgsINWQ1Y9fODksINWQ1Y9fOTAsINWQ1Y9fOTEsINWQ1Y9fOTIsINWQ1Y9fOTMsINWQ1Y9fOTQsINWQ1Y9fOTUsINWQ1Y9fOTYsINWQ1Y9fOTcsINWQ1Y9fOTgsINWQ1Y9fOTksINWQ1Y9fMTAwLCDVkNWPXzEwMSwg1ZDVj18xMDIsINWQ1Y9fMTAzLCDVkNWPXzEwNCwg1ZDVj18xMDUsINWQ1Y9fMTA2LCDVkNWPXzEwNywg1ZDVj18xMDgsINWQ1Y9fMTA5LCDVkNWPXzExMCwg1ZDVj18xMTEsINWQ1Y9fMTEyLCDVkNWPXzExMywg1ZDVj18xMTQ7XG5mdW5jdGlvbiBhYnMobikge1xuICAgIHJldHVybiBNYXRoLmFicyhuKTtcbn1cbmZ1bmN0aW9uIGFsbChhKSB7XG4gICAgdmFyINWQ1Y9pdHI4NSwg1ZDVj2lkeDg1O1xuICAgIHZhciBlO1xuICAgINWQ1Y9pdHI4NSA9INWQ1Y9fSXRlcmFibGUoYSk7XG4gICAgZm9yICjVkNWPaWR4ODUgPSAwOyDVkNWPaWR4ODUgPCDVkNWPaXRyODUubGVuZ3RoOyDVkNWPaWR4ODUrKykge1xuICAgICAgICBlID0g1ZDVj2l0cjg1W9WQ1Y9pZHg4NV07XG4gICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYW55KGEpIHtcbiAgICB2YXIg1ZDVj2l0cjg2LCDVkNWPaWR4ODY7XG4gICAgdmFyIGU7XG4gICAg1ZDVj2l0cjg2ID0g1ZDVj19JdGVyYWJsZShhKTtcbiAgICBmb3IgKNWQ1Y9pZHg4NiA9IDA7INWQ1Y9pZHg4NiA8INWQ1Y9pdHI4Ni5sZW5ndGg7INWQ1Y9pZHg4NisrKSB7XG4gICAgICAgIGUgPSDVkNWPaXRyODZb1ZDVj2lkeDg2XTtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGJpbihhKSB7XG4gICAgcmV0dXJuIFwiMGJcIiArIChhID4+PiAwKS50b1N0cmluZygyKTtcbn1cbmZ1bmN0aW9uINWQ1Y9fYmluZChmbiwgdGhpc0FyZykge1xuICAgIHZhciBmbiwgcmV0O1xuICAgIGlmIChmbi5vcmlnKSB7XG4gICAgICAgIGZuID0gZm4ub3JpZztcbiAgICB9XG4gICAgaWYgKHRoaXNBcmcgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gICAgcmV0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgcmV0Lm9yaWcgPSBmbjtcbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24g1ZDVj19yZWJpbmRBbGwodGhpc0FyZywgcmViaW5kKSB7XG4gICAgdmFyIHJlYmluZDtcbiAgICBpZiAocmViaW5kID09PSB2b2lkIDApIHtcbiAgICAgICAgcmViaW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgcCBpbiB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0aGlzQXJnW3BdICYmIHRoaXNBcmdbcF0ub3JpZykge1xuICAgICAgICAgICAgaWYgKHJlYmluZCkge1xuICAgICAgICAgICAgICAgIHRoaXNBcmdbcF0gPSDVkNWPX2JpbmQodGhpc0FyZ1twXSwgdGhpc0FyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNBcmdbcF0gPSB0aGlzQXJnW3BdLm9yaWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjbXAoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cbmNociA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5mdW5jdGlvbiBkaXIoaXRlbSkge1xuICAgIHZhciBhcnI7XG4gICAgYXJyID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBpdGVtKSB7XG4gICAgICAgIGFyci5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gZW51bWVyYXRlKGl0ZW0pIHtcbiAgICB2YXIgYXJyLCBpdGVyLCBpO1xuICAgIGFyciA9IFtdO1xuICAgIGl0ZXIgPSDVkNWPX0l0ZXJhYmxlKGl0ZW0pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBpdGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyclthcnIubGVuZ3RoXSA9IFsgaSwgaXRlbVtpXSBdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24g1ZDVj19lc2xpY2UoYXJyLCBzdGVwLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGFyciwgaXNTdHJpbmcsIHN0ZXAsIHN0YXJ0LCBlbmQ7XG4gICAgYXJyID0gYXJyLnNsaWNlKDApO1xuICAgIGlmICh0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiIHx8IGFyciBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICBpc1N0cmluZyA9IHRydWU7XG4gICAgICAgIGFyciA9IGFyci5zcGxpdChcIlwiKTtcbiAgICB9XG4gICAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICAgIHN0ZXAgPSAtc3RlcDtcbiAgICAgICAgYXJyLnJldmVyc2UoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFydCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgc3RhcnQgPSBhcnIubGVuZ3RoIC0gc3RhcnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBlbmQgPSBhcnIubGVuZ3RoIC0gZW5kIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZW5kID0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgYXJyID0gYXJyLnNsaWNlKHN0YXJ0LCBlbmQpLmZpbHRlcihmdW5jdGlvbihlLCBpKSB7XG4gICAgICAgIHJldHVybiBpICUgc3RlcCA9PT0gMDtcbiAgICB9KTtcbiAgICByZXR1cm4gaXNTdHJpbmcgPyBhcnIuam9pbihcIlwiKSA6IGFycjtcbn1cbmZ1bmN0aW9uINWQ1Y9fZXh0ZW5kcyhjaGlsZCwgcGFyZW50KSB7XG4gICAgY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgICBjaGlsZC5wcm90b3R5cGUuX19iYXNlX18gPSBwYXJlbnQ7XG4gICAgY2hpbGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG59XG5mdW5jdGlvbiBmaWx0ZXIob3BlciwgYXJyKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIob3Blcik7XG59XG5mdW5jdGlvbiBoZXgoYSkge1xuICAgIHJldHVybiBcIjB4XCIgKyAoYSA+Pj4gMCkudG9TdHJpbmcoMTYpO1xufVxuZnVuY3Rpb24g1ZDVj19pbih2YWwsIGFycikge1xuICAgIGlmICh0eXBlb2YgYXJyLmluZGV4T2YgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YodmFsKSAhPT0gLTE7XG4gICAgfVxuICAgIHJldHVybiBhcnIuaGFzT3duUHJvcGVydHkodmFsKTtcbn1cbmZ1bmN0aW9uINWQ1Y9fSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgICB2YXIgdG1wO1xuICAgIGlmIChpdGVyYWJsZS5jb25zdHJ1Y3RvciA9PT0gW10uY29uc3RydWN0b3IgfHwgaXRlcmFibGUuY29uc3RydWN0b3IgPT09IFwiXCIuY29uc3RydWN0b3IgfHwgKHRtcCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGl0ZXJhYmxlKSkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0bXAgfHwgaXRlcmFibGU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVyYWJsZSk7XG59XG5mdW5jdGlvbiBsZW4ob2JqKSB7XG4gICAgdmFyIHRtcDtcbiAgICBpZiAob2JqLmNvbnN0cnVjdG9yID09PSBbXS5jb25zdHJ1Y3RvciB8fCBvYmouY29uc3RydWN0b3IgPT09IFwiXCIuY29uc3RydWN0b3IgfHwgKHRtcCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaikpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gKHRtcCB8fCBvYmopLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xufVxuZnVuY3Rpb24gbWFwKG9wZXIsIGFycikge1xuICAgIHJldHVybiBhcnIubWFwKG9wZXIpO1xufVxuZnVuY3Rpb24gbWF4KGEpIHtcbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgQXJyYXkuaXNBcnJheShhKSA/IGEgOiBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gbWluKGEpIHtcbiAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkobnVsbCwgQXJyYXkuaXNBcnJheShhKSA/IGEgOiBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24g1ZDVj19tZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3ZlcndyaXRlKSB7XG4gICAgdmFyINWQ1Y9pdHI4Nywg1ZDVj2lkeDg3O1xuICAgIHZhciBwcm9wO1xuICAgIGZvciAodmFyIGkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoaSkgJiYgKG92ZXJ3cml0ZSB8fCB0eXBlb2YgdGFyZ2V0W2ldID09PSBcInVuZGVmaW5lZFwiKSkge1xuICAgICAgICAgICAgdGFyZ2V0W2ldID0gc291cmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgINWQ1Y9pdHI4NyA9INWQ1Y9fSXRlcmFibGUoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlLnByb3RvdHlwZSkpO1xuICAgIGZvciAo1ZDVj2lkeDg3ID0gMDsg1ZDVj2lkeDg3IDwg1ZDVj2l0cjg3Lmxlbmd0aDsg1ZDVj2lkeDg3KyspIHtcbiAgICAgICAgcHJvcCA9INWQ1Y9pdHI4N1vVkNWPaWR4ODddO1xuICAgICAgICBpZiAob3ZlcndyaXRlIHx8IHR5cGVvZiB0YXJnZXQucHJvdG90eXBlW3Byb3BdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0YXJnZXQucHJvdG90eXBlW3Byb3BdID0gc291cmNlLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uINWQ1Y9fbWl4aW4oKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJhc2VDbGFzcykge1xuICAgICAgICB2YXIg1ZDVj2l0cjg4LCDVkNWPaWR4ODgsINWQ1Y9pdHI4OSwg1ZDVj2lkeDg5O1xuICAgICAgICB2YXIgY2xzLCBrZXk7XG4gICAgICAgINWQ1Y9pdHI4OCA9INWQ1Y9fSXRlcmFibGUoY2xhc3Nlcyk7XG4gICAgICAgIGZvciAo1ZDVj2lkeDg4ID0gMDsg1ZDVj2lkeDg4IDwg1ZDVj2l0cjg4Lmxlbmd0aDsg1ZDVj2lkeDg4KyspIHtcbiAgICAgICAgICAgIGNscyA9INWQ1Y9pdHI4OFvVkNWPaWR4ODhdO1xuICAgICAgICAgICAg1ZDVj2l0cjg5ID0g1ZDVj19JdGVyYWJsZShPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjbHMucHJvdG90eXBlKSk7XG4gICAgICAgICAgICBmb3IgKNWQ1Y9pZHg4OSA9IDA7INWQ1Y9pZHg4OSA8INWQ1Y9pdHI4OS5sZW5ndGg7INWQ1Y9pZHg4OSsrKSB7XG4gICAgICAgICAgICAgICAga2V5ID0g1ZDVj2l0cjg5W9WQ1Y9pZHg4OV07XG4gICAgICAgICAgICAgICAgaWYgKCEo1ZDVj19pbihrZXksIGJhc2VDbGFzcy5wcm90b3R5cGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlQ2xhc3MucHJvdG90eXBlW2tleV0gPSBjbHMucHJvdG90eXBlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlQ2xhc3M7XG4gICAgfTtcbn1cbmZ1bmN0aW9uINWQ1Y9fcHJpbnQoKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICB2YXIgc3RvcCwgc3RhcnQsIHN0ZXAsIGxlbmd0aCwgaWR4LCByYW5nZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBhcmd1bWVudHNbMl0gfHwgMTtcbiAgICBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgaWR4ID0gMDtcbiAgICByYW5nZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChpZHggPCBsZW5ndGgpIHtcbiAgICAgICAgcmFuZ2VbaWR4KytdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiByYW5nZTtcbn1cbmZ1bmN0aW9uIHJlZHVjZShmLCBhKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChhLCBmKTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VkKGFycikge1xuICAgIHZhciB0bXA7XG4gICAgdG1wID0gYXJyLnNsaWNlKDApO1xuICAgIHJldHVybiB0bXAucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gc29ydGVkKGFycikge1xuICAgIHZhciB0bXA7XG4gICAgdG1wID0gYXJyLnNsaWNlKDApO1xuICAgIHJldHVybiB0bXAuc29ydCgpO1xufVxuZnVuY3Rpb24gc3VtKGFyciwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0ID09PSB2b2lkIDAgPyAwIDogc3RhcnQ7XG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICAgIHJldHVybiBwcmV2ICsgY3VyO1xuICAgIH0sIHN0YXJ0KTtcbn1cbmZ1bmN0aW9uINWQ1Y9fdHlwZShvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IubmFtZSA/IG9iai5jb25zdHJ1Y3Rvci5uYW1lIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikuc2xpY2UoOCwgLTEpO1xufVxuZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgICB2YXIgaTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIg1ZDVj2lkeDkwLCDVkNWPaXRyOTAgPSDVkNWPX0l0ZXJhYmxlKHJhbmdlKE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCkpKSwg1ZDVj3JlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKNWQ1Y9pZHg5MCA9IDA7INWQ1Y9pZHg5MCA8INWQ1Y9pdHI5MC5sZW5ndGg7INWQ1Y9pZHg5MCsrKSB7XG4gICAgICAgICAgICBpID0g1ZDVj2l0cjkwW9WQ1Y9pZHg5MF07XG4gICAgICAgICAgICDVkNWPcmVzLnB1c2goWyBhW2ldLCBiW2ldIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiDVkNWPcmVzO1xuICAgIH0pKCk7XG59XG5mdW5jdGlvbiBnZXRhdHRyKG9iaiwgbmFtZSkge1xuICAgIHJldHVybiBvYmpbbmFtZV07XG59XG5mdW5jdGlvbiBzZXRhdHRyKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGhhc2F0dHIob2JqLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gb2JqO1xufVxuZnVuY3Rpb24g1ZDVj19lcShhLCBiKSB7XG4gICAgdmFyINWQ1Y9pdHI5MSwg1ZDVj2lkeDkxO1xuICAgIHZhciBpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpIHx8IGEgaW5zdGFuY2VvZiBPYmplY3QgJiYgYiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvciB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIdWQ1Y9fZXEoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgINWQ1Y9pdHI5MSA9INWQ1Y9fSXRlcmFibGUoYSk7XG4gICAgICAgICAgICBmb3IgKNWQ1Y9pZHg5MSA9IDA7INWQ1Y9pZHg5MSA8INWQ1Y9pdHI5MS5sZW5ndGg7INWQ1Y9pZHg5MSsrKSB7XG4gICAgICAgICAgICAgICAgaSA9INWQ1Y9pdHI5MVvVkNWPaWR4OTFdO1xuICAgICAgICAgICAgICAgIGlmICgh1ZDVj19lcShhW2ldLCBiW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBrd2FyZ3MoZikge1xuICAgIHZhciBhcmdOYW1lcztcbiAgICBhcmdOYW1lcyA9IGYudG9TdHJpbmcoKS5tYXRjaCgvXFwoKFteXFwpXSspLylbMV07XG4gICAgaWYgKCFrd2FyZ3MubWVtb1thcmdOYW1lc10pIHtcbiAgICAgICAga3dhcmdzLm1lbW9bYXJnTmFtZXNdID0gYXJnTmFtZXMgPyBhcmdOYW1lcy5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzLnRyaW0oKTtcbiAgICAgICAgfSkgOiBbXTtcbiAgICB9XG4gICAgYXJnTmFtZXMgPSBrd2FyZ3MubWVtb1thcmdOYW1lc107XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncywga3csIGk7XG4gICAgICAgIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAga3cgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrdyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAo1ZDVj19pbihhcmdOYW1lc1tpXSwga3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0ga3dbYXJnTmFtZXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goa3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAo1ZDVj19FeGNlcHRpb24pIHtcbiAgICAgICAgICAgIHZhciBlID0g1ZDVj19FeGNlcHRpb247XG4gICAgICAgICAgICBpZiAoL0NsYXNzIGNvbnN0cnVjdG9yIFxcdysgY2Fubm90IGJlIGludm9rZWQgd2l0aG91dCAnbmV3Jy8udGVzdChlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZihhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93INWQ1Y9fRXhjZXB0aW9uO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmt3YXJncy5tZW1vID0ge307XG52YXIgQXNzZXJ0aW9uRXJyb3IgPSAo1ZDVj18xMjQgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcigpIHtcbiAgICBBc3NlcnRpb25FcnJvci5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzEyNCwgRXJyb3IpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzEyNC5wcm90b3R5cGUsIHtcbiAgICBfX2luaXRfXzoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX19pbml0X18obWVzc2FnZSl7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLm5hbWUgPSBcIkFzc2VydGlvbkVycm9yXCI7XG4gICAgICAgICAgICBzZWxmLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxufSksINWQ1Y9fMTI0KTtcbnZhciBJbmRleEVycm9yID0gKNWQ1Y9fMTI1ID0gZnVuY3Rpb24gSW5kZXhFcnJvcigpIHtcbiAgICBJbmRleEVycm9yLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTI1LCBFcnJvciksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMTI1LnByb3RvdHlwZSwge1xuICAgIF9faW5pdF9fOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfX2luaXRfXyhtZXNzYWdlKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYubmFtZSA9IFwiSW5kZXhFcnJvclwiO1xuICAgICAgICAgICAgc2VsZi5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cbn0pLCDVkNWPXzEyNSk7XG52YXIgS2V5RXJyb3IgPSAo1ZDVj18xMjYgPSBmdW5jdGlvbiBLZXlFcnJvcigpIHtcbiAgICBLZXlFcnJvci5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzEyNiwgRXJyb3IpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzEyNi5wcm90b3R5cGUsIHtcbiAgICBfX2luaXRfXzoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX19pbml0X18obWVzc2FnZSl7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLm5hbWUgPSBcIktleUVycm9yXCI7XG4gICAgICAgICAgICBzZWxmLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxufSksINWQ1Y9fMTI2KTtcbnZhciBUeXBlRXJyb3IgPSAo1ZDVj18xMjcgPSBmdW5jdGlvbiBUeXBlRXJyb3IoKSB7XG4gICAgVHlwZUVycm9yLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTI3LCBFcnJvciksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMTI3LnByb3RvdHlwZSwge1xuICAgIF9faW5pdF9fOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfX2luaXRfXyhtZXNzYWdlKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYubmFtZSA9IFwiVHlwZUVycm9yXCI7XG4gICAgICAgICAgICBzZWxmLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxufSksINWQ1Y9fMTI3KTtcbnZhciBWYWx1ZUVycm9yID0gKNWQ1Y9fMTI4ID0gZnVuY3Rpb24gVmFsdWVFcnJvcigpIHtcbiAgICBWYWx1ZUVycm9yLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTI4LCBFcnJvciksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMTI4LnByb3RvdHlwZSwge1xuICAgIF9faW5pdF9fOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfX2luaXRfXyhtZXNzYWdlKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYubmFtZSA9IFwiVmFsdWVFcnJvclwiO1xuICAgICAgICAgICAgc2VsZi5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cbn0pLCDVkNWPXzEyOCk7XG52YXIg1ZDVj19tb2R1bGVzID0ge307XG7VkNWPX21vZHVsZXNbXCJ1dGlsc1wiXSA9IHt9O1xu1ZDVj19tb2R1bGVzW1wiYXN0XCJdID0ge307XG7VkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl0gPSB7fTtcbtWQ1Y9fbW9kdWxlc1tcInBhcnNlclwiXSA9IHt9O1xu1ZDVj19tb2R1bGVzW1wiX2Jhc2VsaWJcIl0gPSB7fTtcbtWQ1Y9fbW9kdWxlc1tcIm91dHB1dFwiXSA9IHt9O1xuXG4oZnVuY3Rpb24oKXtcbiAgICB2YXIgX19uYW1lX18gPSBcInV0aWxzXCI7XG4gICAgdmFyIFJBUFlEX1BSRUZJWCwgTUFQLCBjb2xvcnM7XG4gICAgUkFQWURfUFJFRklYID0gXCLVkNWPXCI7XG4gICAgZnVuY3Rpb24gc2xpY2UoYSwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIHN0YXJ0IHx8IDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZW1iZXIobmFtZSwgYXJyYXkpIHtcbiAgICAgICAgdmFyINWQ1Y9pdHIxLCDVkNWPaWR4MTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgINWQ1Y9pdHIxID0g1ZDVj19JdGVyYWJsZShyYW5nZShhcnJheS5sZW5ndGggLSAxLCAtMSwgLTEpKTtcbiAgICAgICAgZm9yICjVkNWPaWR4MSA9IDA7INWQ1Y9pZHgxIDwg1ZDVj2l0cjEubGVuZ3RoOyDVkNWPaWR4MSsrKSB7XG4gICAgICAgICAgICBpID0g1ZDVj2l0cjFb1ZDVj2lkeDFdO1xuICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kX2lmKGZ1bmMsIGFycmF5KSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuKGFycmF5KTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZnVuYyhhcnJheVtpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwZWF0X3N0cmluZyhzdHJfLCBpKSB7XG4gICAgICAgIHZhciBkO1xuICAgICAgICBpZiAoaSA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cl87XG4gICAgICAgIH1cbiAgICAgICAgZCA9IHJlcGVhdF9zdHJpbmcoc3RyXywgaSA+PiAxKTtcbiAgICAgICAgZCArPSBkO1xuICAgICAgICBpZiAoaSAmIDEpIHtcbiAgICAgICAgICAgIGQgKz0gc3RyXztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gRGVmYXVsdHNFcnJvcihtc2csIGRlZnMpIHtcbiAgICAgICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgICAgIHRoaXMuZGVmcyA9IGRlZnM7XG4gICAgfVxuICAgIHZhciBJbXBvcnRFcnJvciA9ICjVkNWPXzEgPSBmdW5jdGlvbiBJbXBvcnRFcnJvcigpIHtcbiAgICAgICAgSW1wb3J0RXJyb3IucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMSwgRXJyb3IpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzEucHJvdG90eXBlLCB7XG4gICAgICAgIF9faW5pdF9fOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfX2luaXRfXyhtZXNzYWdlKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2VsZi5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzEpO1xuICAgIHZhciBQYXJzZUVycm9yID0gKNWQ1Y9fMiA9IGZ1bmN0aW9uIFBhcnNlRXJyb3IoKSB7XG4gICAgICAgIFBhcnNlRXJyb3IucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMiwgRXJyb3IpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzIucHJvdG90eXBlLCB7XG4gICAgICAgIF9faW5pdF9fOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfX2luaXRfXyhtZXNzYWdlLCBsaW5lLCBjb2wsIHBvcywgaXNfZW9mKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2VsZi5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzZWxmLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgIHNlbGYuY29sID0gY29sO1xuICAgICAgICAgICAgICAgIHNlbGYucG9zID0gcG9zO1xuICAgICAgICAgICAgICAgIHNlbGYuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgICAgICAgICAgICBzZWxmLmlzX2VvZiA9IGlzX2VvZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG9TdHJpbmc6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UgKyBcIiAobGluZTogXCIgKyB0aGlzLmxpbmUgKyBcIiwgY29sOiBcIiArIHRoaXMuY29sICsgXCIsIHBvczogXCIgKyB0aGlzLnBvcyArIFwiKVwiICsgXCJcXG5cXG5cIiArIHRoaXMuc3RhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18yKTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhcmdzLCBkZWZzLCBjcm9haykge1xuICAgICAgICB2YXIg1ZDVj2l0cjIsINWQ1Y9pZHgyLCDVkNWPaXRyMywg1ZDVj2lkeDM7XG4gICAgICAgIHZhciBhcmdzLCByZXQsIGtleTtcbiAgICAgICAgaWYgKGFyZ3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBhcmdzIHx8IHt9O1xuICAgICAgICBpZiAoY3JvYWspIHtcbiAgICAgICAgICAgINWQ1Y9pdHIyID0g1ZDVj19JdGVyYWJsZShyZXQpO1xuICAgICAgICAgICAgZm9yICjVkNWPaWR4MiA9IDA7INWQ1Y9pZHgyIDwg1ZDVj2l0cjIubGVuZ3RoOyDVkNWPaWR4MisrKSB7XG4gICAgICAgICAgICAgICAga2V5ID0g1ZDVj2l0cjJb1ZDVj2lkeDJdO1xuICAgICAgICAgICAgICAgIGlmICghKNWQ1Y9faW4oa2V5LCBkZWZzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlZmF1bHRzRXJyb3IoXCJgXCIgKyBrZXkgKyBcImAgaXMgbm90IGEgc3VwcG9ydGVkIG9wdGlvblwiLCBkZWZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAg1ZDVj2l0cjMgPSDVkNWPX0l0ZXJhYmxlKGRlZnMpO1xuICAgICAgICBmb3IgKNWQ1Y9pZHgzID0gMDsg1ZDVj2lkeDMgPCDVkNWPaXRyMy5sZW5ndGg7INWQ1Y9pZHgzKyspIHtcbiAgICAgICAgICAgIGtleSA9INWQ1Y9pdHIzW9WQ1Y9pZHgzXTtcbiAgICAgICAgICAgIHJldFtrZXldID0gYXJncyAmJiDVkNWPX2luKGtleSwgYXJncykgPyBhcmdzW2tleV0gOiBkZWZzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVyZ2Uob2JqLCBleHQpIHtcbiAgICAgICAgdmFyINWQ1Y9pdHI0LCDVkNWPaWR4NDtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAg1ZDVj2l0cjQgPSDVkNWPX0l0ZXJhYmxlKGV4dCk7XG4gICAgICAgIGZvciAo1ZDVj2lkeDQgPSAwOyDVkNWPaWR4NCA8INWQ1Y9pdHI0Lmxlbmd0aDsg1ZDVj2lkeDQrKykge1xuICAgICAgICAgICAga2V5ID0g1ZDVj2l0cjRb1ZDVj2lkeDRdO1xuICAgICAgICAgICAgb2JqW2tleV0gPSBleHRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgIH1cbiAgICBNQVAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNraXA7XG4gICAgICAgIGZ1bmN0aW9uIE1BUChhLCBmLCBiYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHZhciDVkNWPaXRyNSwg1ZDVj2lkeDU7XG4gICAgICAgICAgICB2YXIgcmV0LCB0b3AsIGk7XG4gICAgICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgICAgIHRvcCA9IFtdO1xuICAgICAgICAgICAgZnVuY3Rpb24gZG9pdCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsLCBpc19sYXN0O1xuICAgICAgICAgICAgICAgIHZhbCA9IGYoYVtpXSwgaSk7XG4gICAgICAgICAgICAgICAgaXNfbGFzdCA9IHZhbCBpbnN0YW5jZW9mIExhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGlzX2xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBdFRvcCkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwudjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFNwbGljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLnB1c2guYXBwbHkodG9wLCBiYWNrd2FyZHMgPyB2YWwudi5zbGljZSgpLnJldmVyc2UoKSA6IHZhbC52KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCAhPT0gc2tpcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgU3BsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaC5hcHBseShyZXQsIGJhY2t3YXJkcyA/IHZhbC52LnNsaWNlKCkucmV2ZXJzZSgpIDogdmFsLnYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXNfbGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhY2t3YXJkcykge1xuICAgICAgICAgICAgICAgICAgICDVkNWPaXRyNSA9INWQ1Y9fSXRlcmFibGUocmFuZ2UoYS5sZW5ndGggLSAxLCAtMSwgLTEpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4NSA9IDA7INWQ1Y9pZHg1IDwg1ZDVj2l0cjUubGVuZ3RoOyDVkNWPaWR4NSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0g1ZDVj2l0cjVb1ZDVj2lkeDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvaXQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRvcC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbihhKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9pdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9pdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9wLmNvbmNhdChyZXQpO1xuICAgICAgICB9XG4gICAgICAgIE1BUC5hdF90b3AgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXRUb3AodmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgTUFQLnNwbGljZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGxpY2UodmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgTUFQLmxhc3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGFzdCh2YWwpO1xuICAgICAgICB9O1xuICAgICAgICBza2lwID0gTUFQLnNraXAgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gQXRUb3AodmFsKSB7XG4gICAgICAgICAgICB0aGlzLnYgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gU3BsaWNlKHZhbCkge1xuICAgICAgICAgICAgdGhpcy52ID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIExhc3QodmFsKSB7XG4gICAgICAgICAgICB0aGlzLnYgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1BUDtcbiAgICB9KCk7XG4gICAgZnVuY3Rpb24gcHVzaF91bmlxKGFycmF5LCBlbCkge1xuICAgICAgICBpZiAoISjVkNWPX2luKGVsLCBhcnJheSkpKSB7XG4gICAgICAgICAgICBhcnJheS5wdXNoKGVsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdfdGVtcGxhdGUodGV4dCwgcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFx7KC4rPylcXH0vZywgZnVuY3Rpb24oc3RyXywgcCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzW3BdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBlbCkge1xuICAgICAgICB2YXIg1ZDVj2l0cjYsINWQ1Y9pZHg2O1xuICAgICAgICB2YXIgaWR4O1xuICAgICAgICDVkNWPaXRyNiA9INWQ1Y9fSXRlcmFibGUocmFuZ2UoYXJyYXkubGVuZ3RoIC0gMSwgLTEsIC0xKSk7XG4gICAgICAgIGZvciAo1ZDVj2lkeDYgPSAwOyDVkNWPaWR4NiA8INWQ1Y9pdHI2Lmxlbmd0aDsg1ZDVj2lkeDYrKykge1xuICAgICAgICAgICAgaWR4ID0g1ZDVj2l0cjZb1ZDVj2lkeDZdO1xuICAgICAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGVsKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lcmdlU29ydChhcnJheSwgY21wKSB7XG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXkuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtZXJnZShhLCBiKSB7XG4gICAgICAgICAgICB2YXIgciwgYWksIGJpLCBpO1xuICAgICAgICAgICAgciA9IFtdO1xuICAgICAgICAgICAgYWkgPSAwO1xuICAgICAgICAgICAgYmkgPSAwO1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoYWkgPCBhLmxlbmd0aCAmJiBiaSA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNtcChhW2FpXSwgYltiaV0pIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcltpXSA9IGFbYWldO1xuICAgICAgICAgICAgICAgICAgICArK2FpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJbaV0gPSBiW2JpXTtcbiAgICAgICAgICAgICAgICAgICAgKytiaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFpIDwgYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByLnB1c2guYXBwbHkociwgYS5zbGljZShhaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByLnB1c2guYXBwbHkociwgYi5zbGljZShiaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX21zKGEpIHtcbiAgICAgICAgICAgIHZhciBtLCBsZWZ0LCByaWdodDtcbiAgICAgICAgICAgIGlmIChhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtID0gTWF0aC5mbG9vcihhLmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgbGVmdCA9IGEuc2xpY2UoMCwgbSk7XG4gICAgICAgICAgICByaWdodCA9IGEuc2xpY2UobSk7XG4gICAgICAgICAgICBsZWZ0ID0gX21zKGxlZnQpO1xuICAgICAgICAgICAgcmlnaHQgPSBfbXMocmlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuINWQ1Y9fbWVyZ2UobGVmdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfbXMoYXJyYXkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRfZGlmZmVyZW5jZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgcmV0dXJuICEo1ZDVj19pbihlbCwgYikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0X2ludGVyc2VjdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgcmV0dXJuINWQ1Y9faW4oZWwsIGIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVByZWRpY2F0ZSh3b3Jkcykge1xuICAgICAgICB2YXIgd29yZHMsIGYsIGNhdHMsIGksIHNraXAsIGosIGNhdDtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSkge1xuICAgICAgICAgICAgd29yZHMgPSB3b3Jkcy5zcGxpdChcIiBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZiA9IFwiXCI7XG4gICAgICAgIGNhdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbih3b3Jkcyk7IGkrKykge1xuICAgICAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbihjYXRzKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhdHNbal1bMF0ubGVuZ3RoID09PSB3b3Jkc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0c1tqXS5wdXNoKHdvcmRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgc2tpcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2tpcCkge1xuICAgICAgICAgICAgICAgIGNhdHMucHVzaChbIHdvcmRzW2ldIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmVUbyhhcnIpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZiArPSBcInJldHVybiBzdHIgPT09IFwiICsgSlNPTi5zdHJpbmdpZnkoYXJyWzBdKSArIFwiO1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZiArPSBcInN3aXRjaChzdHIpe1wiO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbihhcnIpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmICs9IFwiY2FzZSBcIiArIEpTT04uc3RyaW5naWZ5KGFycltpXSkgKyBcIjpcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGYgKz0gXCJyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhdHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgY2F0cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZiArPSBcInN3aXRjaChzdHIubGVuZ3RoKXtcIjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4oY2F0cyk7IGkrKykge1xuICAgICAgICAgICAgICAgIGNhdCA9IGNhdHNbaV07XG4gICAgICAgICAgICAgICAgZiArPSBcImNhc2UgXCIgKyBjYXRbMF0ubGVuZ3RoICsgXCI6XCI7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvKGNhdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmICs9IFwifVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcGFyZVRvKHdvcmRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwic3RyXCIsIGYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5KCkge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICB9XG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUgPSB7XG4gICAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICsrdGhpcy5fc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tcIiRcIiArIGtleV0gPSB2YWw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldChrZXkpLnB1c2godmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBbIHZhbCBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlc1tcIiRcIiArIGtleV07XG4gICAgICAgIH0sXG4gICAgICAgIGRlbF86IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAtLXRoaXMuX3NpemU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3ZhbHVlc1tcIiRcIiArIGtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgaGFzOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiDVkNWPX2luKFwiJFwiICsga2V5LCB0aGlzLl92YWx1ZXMpO1xuICAgICAgICB9LFxuICAgICAgICBlYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSBpbiB0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBmKHRoaXMuX3ZhbHVlc1tpXSwgaS5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgICAgICB9LFxuICAgICAgICBtYXA6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHZhciByZXQsIGk7XG4gICAgICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSBpbiB0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChmKHRoaXMuX3ZhbHVlc1tpXSwgaS5zdWJzdHIoMSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbG9ycyA9IFsgXCJyZWRcIiwgXCJncmVlblwiLCBcInllbGxvd1wiLCBcImJsdWVcIiwgXCJtYWdlbnRhXCIsIFwiY3lhblwiLCBcIndoaXRlXCIgXTtcbiAgICBmdW5jdGlvbiBhbnNpKGNvZGUpIHtcbiAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgIGNvZGUgPSBjb2RlIHx8IDA7XG4gICAgICAgIHJldHVybiBcIlx1MDAxYltcIiArIGNvZGUgKyBcIm1cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29sb3JlZChzdHJpbmcsIGNvbG9yLCBib2xkKSB7XG4gICAgICAgIHZhciBwcmVmaXg7XG4gICAgICAgIHByZWZpeCA9IFtdO1xuICAgICAgICBpZiAoYm9sZCkge1xuICAgICAgICAgICAgcHJlZml4LnB1c2goYW5zaSgxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICBwcmVmaXgucHVzaChhbnNpKGNvbG9ycy5pbmRleE9mKGNvbG9yKSArIDMxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZWZpeC5qb2luKFwiXCIpICsgc3RyaW5nICsgYW5zaSgwKTtcbiAgICB9XG4gICAg1ZDVj19tb2R1bGVzW1widXRpbHNcIl1bXCJSQVBZRF9QUkVGSVhcIl0gPSBSQVBZRF9QUkVGSVg7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ1dGlsc1wiXVtcIk1BUFwiXSA9IE1BUDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInV0aWxzXCJdW1wiY29sb3JzXCJdID0gY29sb3JzO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widXRpbHNcIl1bXCJzbGljZVwiXSA9IHNsaWNlO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widXRpbHNcIl1bXCJtZW1iZXJcIl0gPSBtZW1iZXI7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ1dGlsc1wiXVtcImZpbmRfaWZcIl0gPSBmaW5kX2lmO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widXRpbHNcIl1bXCJyZXBlYXRfc3RyaW5nXCJdID0gcmVwZWF0X3N0cmluZztcblxuICAgINWQ1Y9fbW9kdWxlc1tcInV0aWxzXCJdW1wiRGVmYXVsdHNFcnJvclwiXSA9IERlZmF1bHRzRXJyb3I7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ1dGlsc1wiXVtcIkltcG9ydEVycm9yXCJdID0gSW1wb3J0RXJyb3I7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ1dGlsc1wiXVtcIlBhcnNlRXJyb3JcIl0gPSBQYXJzZUVycm9yO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widXRpbHNcIl1bXCJkZWZhdWx0c1wiXSA9IGRlZmF1bHRzO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widXRpbHNcIl1bXCJtZXJnZVwiXSA9IG1lcmdlO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widXRpbHNcIl1bXCJub29wXCJdID0gbm9vcDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInV0aWxzXCJdW1wicHVzaF91bmlxXCJdID0gcHVzaF91bmlxO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widXRpbHNcIl1bXCJzdHJpbmdfdGVtcGxhdGVcIl0gPSBzdHJpbmdfdGVtcGxhdGU7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ1dGlsc1wiXVtcInJlbW92ZVwiXSA9IHJlbW92ZTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInV0aWxzXCJdW1wibWVyZ2VTb3J0XCJdID0gbWVyZ2VTb3J0O1xuXG4gICAg1ZDVj19tb2R1bGVzW1widXRpbHNcIl1bXCJzZXRfZGlmZmVyZW5jZVwiXSA9IHNldF9kaWZmZXJlbmNlO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widXRpbHNcIl1bXCJzZXRfaW50ZXJzZWN0aW9uXCJdID0gc2V0X2ludGVyc2VjdGlvbjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInV0aWxzXCJdW1wibWFrZVByZWRpY2F0ZVwiXSA9IG1ha2VQcmVkaWNhdGU7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ1dGlsc1wiXVtcIkRpY3Rpb25hcnlcIl0gPSBEaWN0aW9uYXJ5O1xuXG4gICAg1ZDVj19tb2R1bGVzW1widXRpbHNcIl1bXCJhbnNpXCJdID0gYW5zaTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInV0aWxzXCJdW1wiY29sb3JlZFwiXSA9IGNvbG9yZWQ7XG59KSgpO1xuXG4oZnVuY3Rpb24oKXtcbiAgICB2YXIgX19uYW1lX18gPSBcImFzdFwiO1xuICAgIHZhciBub29wID0g1ZDVj19tb2R1bGVzW1widXRpbHNcIl0ubm9vcDtcbiAgICB2YXIgc3RyaW5nX3RlbXBsYXRlID0g1ZDVj19tb2R1bGVzW1widXRpbHNcIl0uc3RyaW5nX3RlbXBsYXRlO1xuICAgIHZhciBjb2xvcmVkID0g1ZDVj19tb2R1bGVzW1widXRpbHNcIl0uY29sb3JlZDtcbiAgICBcbiAgICBmdW5jdGlvbiBtZW1vaXplZChmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29tcHV0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlZFR5cGUgPSBmLmNhbGwodGhpcywgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZFR5cGU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBBU1QgPSAo1ZDVj18zID0gZnVuY3Rpb24gQVNUKCkge1xuICAgICAgICBBU1QucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj18zLnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7fSAgICAgICAgfSxcbiAgICAgICAgX19pbml0X186IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9faW5pdF9fKGluaXRpYWxpemVyKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiwgaTtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gc2VsZjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIG9iai5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZltpXSA9IGluaXRpYWxpemVyW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsb25lOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHNlbGYuY29uc3RydWN0b3Ioc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18zKTtcbiAgICB2YXIgVG9rZW4gPSAo1ZDVj180ID0gZnVuY3Rpb24gVG9rZW4oKSB7XG4gICAgICAgIEFTVC5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj180LCBBU1QpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzQucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJUaGUgdHlwZSBvZiB0aGUgdG9rZW5cIixcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiVGhlIHZhbHVlIG9mIHRoZSB0b2tlblwiLFxuICAgICAgICAgICAgICAgIFwibGluZVwiOiBcIlRoZSBsaW5lIG51bWJlciBhdCB3aGljaCB0aGUgdG9rZW4gb2NjdXJzXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xcIjogXCJUaGUgY29sdW1uIG51bWJlciBhdCB3aGljaCB0aGUgdG9rZW4gb2NjdXJzXCIsXG4gICAgICAgICAgICAgICAgXCJwb3NcIjogXCJBYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgdG9rZW4gc3RhcnQsIHJlbGF0aXZlIHRvIGRvY3VtZW50IHN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgXCJlbmRwb3NcIjogXCJBYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgdG9rZW4gc3RhcnQsIHJlbGF0aXZlIHRvIGRvY3VtZW50IHN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgXCJuZXdsaW5lX2JlZm9yZVwiOiBcIlRydWUgaWYgdGhlcmUgd2FzIGEgbmV3bGluZSBiZWZvcmUgdGhpcyB0b2tlblwiLFxuICAgICAgICAgICAgICAgIFwiY29tbWVudHNfYmVmb3JlXCI6IFwiVHJ1ZSBpZiB0aGVyZSB3ZXJlIGNvbW1lbnRzIGJlZm9yZSB0aGlzIHRva2VuXCIsXG4gICAgICAgICAgICAgICAgXCJmaWxlXCI6IFwiTmFtZSBvZiB0aGUgZmlsZSBjdXJyZW50bHkgYmVpbmcgcGFyc2VkXCJcbiAgICAgICAgICAgIH0gICAgICAgIH1cbiAgICB9KSwg1ZDVj180KTtcbiAgICB2YXIgTm9kZSA9ICjVkNWPXzUgPSBmdW5jdGlvbiBOb2RlKCkge1xuICAgICAgICBBU1QucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fNSwgQVNUKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj181LnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgXCJzdGFydFwiOiBcIltUb2tlbl0gVGhlIGZpcnN0IHRva2VuIG9mIHRoaXMgbm9kZVwiLFxuICAgICAgICAgICAgICAgIFwiZW5kXCI6IFwiW1Rva2VuXSBUaGUgbGFzdCB0b2tlbiBvZiB0aGlzIG5vZGVcIlxuICAgICAgICAgICAgfSAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWRUeXBlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBudWxsICAgICAgICB9LFxuICAgICAgICByZXNvbHZlVHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogbWVtb2l6ZWQoZnVuY3Rpb24gcmVzb2x2ZVR5cGUoKXtcbiAgICAgICAgICAgICAgICB2YXIgaGVhcCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiP1wiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgX3dhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWxrKHZpc2l0b3Ipe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQoc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZHVtcDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2R1bXAoZGVwdGgsIG9taXQsIG9mZnNldCwgaW5jbHVkZV9uYW1lLCBjb21wYWN0KXtcbiAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjcsINWQ1Y9pZHg3LCDVkNWPaXRyOCwg1ZDVj2lkeDgsINWQ1Y9pdHI5LCDVkNWPaWR4OSwg1ZDVj2l0cjEwLCDVkNWPaWR4MTA7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBrZXksIGNvbG9yZWRfa2V5LCB2YWx1ZSwgZWxlbWVudCwgcHJvcGVydHk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb3V0KHN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFkO1xuICAgICAgICAgICAgICAgICAgICBwYWQgPSBuZXcgQXJyYXkob2Zmc2V0ICsgMSkuam9pbihcIiAgXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhwYWQgKyBzdHJpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZV9uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dChjb2xvcmVkKNWQ1Y9fdHlwZShzZWxmKSwgXCJ5ZWxsb3dcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICDVkNWPaXRyNyA9INWQ1Y9fSXRlcmFibGUodGhpcyk7XG4gICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4NyA9IDA7INWQ1Y9pZHg3IDwg1ZDVj2l0cjcubGVuZ3RoOyDVkNWPaWR4NysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9INWQ1Y9pdHI3W9WQ1Y9pZHg3XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKNWQ1Y9faW4oa2V5LCBvbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29sb3JlZF9rZXkgPSBjb2xvcmVkKGtleSArIFwiOiBcIiwgXCJibHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGZba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0KFwiIFwiICsgY29sb3JlZF9rZXkgKyBcIltcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDVkNWPaXRyOCA9INWQ1Y9fSXRlcmFibGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHg4ID0gMDsg1ZDVj2lkeDggPCDVkNWPaXRyOC5sZW5ndGg7INWQ1Y9pZHg4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSDVkNWPaXRyOFvVkNWPaWR4OF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Ll9kdW1wKGRlcHRoIC0gMSwgb21pdCwgb2Zmc2V0ICsgMSwgdHJ1ZSwgY29tcGFjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDVkNWPaXRyOSA9INWQ1Y9fSXRlcmFibGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHg5ID0gMDsg1ZDVj2lkeDkgPCDVkNWPaXRyOS5sZW5ndGg7INWQ1Y9pZHg5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSDVkNWPaXRyOVvVkNWPaWR4OV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQoXCIgICBcIiArIGNvbG9yZWQo1ZDVj190eXBlKGVsZW1lbnQpLCBcInllbGxvd1wiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0KFwiIF1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQoXCIgXCIgKyBjb2xvcmVkX2tleSArIFwiW11cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCEo1ZDVj19pbih2YWx1ZSwgWyB2b2lkIDAsIG51bGwgXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAo1ZDVj190eXBlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICjVkNWPX3R5cGUodmFsdWUpID09PSBcIlRva2VuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dChcIiBcIiArIGNvbG9yZWRfa2V5ICsgY29sb3JlZCjVkNWPX3R5cGUodmFsdWUpICsgXCIoXCIgKyB2YWx1ZS5maWxlICsgXCI6XCIgKyB2YWx1ZS5saW5lICsgXCI6XCIgKyB2YWx1ZS5jb2wgKyBcIjogXCIgKyB2YWx1ZS52YWx1ZSArIFwiKVwiLCBcIm1hZ2VudGFcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0KFwiIFwiICsgY29sb3JlZF9rZXkgKyBjb2xvcmVkKNWQ1Y9fdHlwZSh2YWx1ZSksIFwibWFnZW50YVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDVkNWPaXRyMTAgPSDVkNWPX0l0ZXJhYmxlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDEwID0gMDsg1ZDVj2lkeDEwIDwg1ZDVj2l0cjEwLmxlbmd0aDsg1ZDVj2lkeDEwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9INWQ1Y9pdHIxMFvVkNWPaWR4MTBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dChcIiAgIFwiICsgY29sb3JlZChwcm9wZXJ0eSArIFwiOiBcIiwgXCJibHVlXCIpICsgdmFsdWVbcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dChcIiBcIiArIGNvbG9yZWRfa2V5ICsgY29sb3JlZCjVkNWPX3R5cGUodmFsdWUpLCBcInllbGxvd1wiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9kdW1wKGRlcHRoIC0gMSwgb21pdCwgb2Zmc2V0ICsgMSwgZmFsc2UsIGNvbXBhY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQoXCIgXCIgKyBjb2xvcmVkX2tleSArIGNvbG9yZWQoJ1wiJyArIHZhbHVlICsgJ1wiJywgXCJncmVlblwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dChcIiBcIiArIGNvbG9yZWRfa2V5ICsgY29sb3JlZCh2YWx1ZSwgXCJncmVlblwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQoXCIgXCIgKyBjb2xvcmVkX2tleSArIGNvbG9yZWQodmFsdWUsIFwiZ3JlZW5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQoXCIgXCIgKyBjb2xvcmVkX2tleSArIGNvbG9yZWQodmFsdWUsIFwicmVkXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dChcIiBcIiArIGNvbG9yZWRfa2V5ICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkdW1wOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdW1wKGRlcHRoLCBvbWl0LCBjb21wYWN0KXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdm9pZCAwID8gMiA6IGRlcHRoO1xuICAgICAgICAgICAgICAgIG9taXQgPSBvbWl0ID09PSB2b2lkIDAgPyBbIFwic3RhcnRcIiwgXCJlbmRcIiBdIDogb21pdDtcbiAgICAgICAgICAgICAgICBjb21wYWN0ID0gY29tcGFjdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IGNvbXBhY3Q7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2R1bXAoZGVwdGgsIG9taXQsIDAsIHRydWUsIGNvbXBhY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNSwge1xuICAgICAgICB3YXJuX2Z1bmN0aW9uOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3YXJuX2Z1bmN0aW9uKHNlbGYpe1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3YXJuOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3YXJuKHR4dCwgcHJvcHMpe1xuICAgICAgICAgICAgICAgIGlmIChOb2RlLndhcm5fZnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgTm9kZS53YXJuX2Z1bmN0aW9uKHN0cmluZ190ZW1wbGF0ZSh0eHQsIHByb3BzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fNSk7XG4gICAgdmFyIFN0YXRlbWVudCA9ICjVkNWPXzYgPSBmdW5jdGlvbiBTdGF0ZW1lbnQoKSB7XG4gICAgICAgIE5vZGUucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fNiwgTm9kZSksINWQ1Y9fNik7XG4gICAgdmFyIERlYnVnZ2VyID0gKNWQ1Y9fNyA9IGZ1bmN0aW9uIERlYnVnZ2VyKCkge1xuICAgICAgICBTdGF0ZW1lbnQucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fNywgU3RhdGVtZW50KSwg1ZDVj183KTtcbiAgICB2YXIgRGlyZWN0aXZlID0gKNWQ1Y9fOCA9IGZ1bmN0aW9uIERpcmVjdGl2ZSgpIHtcbiAgICAgICAgU3RhdGVtZW50LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzgsIFN0YXRlbWVudCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fOC5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIltzdHJpbmddIFRoZSB2YWx1ZSBvZiB0aGlzIGRpcmVjdGl2ZSBhcyBhIHBsYWluIHN0cmluZyAoaXQncyBub3QgYW4gU3RyaW5nISlcIixcbiAgICAgICAgICAgICAgICBzY29wZTogXCJbU2NvcGUvU10gVGhlIHNjb3BlIHRoYXQgdGhpcyBkaXJlY3RpdmUgYWZmZWN0c1wiXG4gICAgICAgICAgICB9ICAgICAgICB9XG4gICAgfSksINWQ1Y9fOCk7XG4gICAgdmFyIFNpbXBsZVN0YXRlbWVudCA9ICjVkNWPXzkgPSBmdW5jdGlvbiBTaW1wbGVTdGF0ZW1lbnQoKSB7XG4gICAgICAgIFN0YXRlbWVudC5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj185LCBTdGF0ZW1lbnQpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzkucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBib2R5OiBcIltOb2RlXSBhbiBleHByZXNzaW9uIG5vZGUgKHNob3VsZCBub3QgYmUgaW5zdGFuY2VvZiBTdGF0ZW1lbnQpXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIHdhbGtfOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3YWxrXygpe1xuICAgICAgICAgICAgICAgIHZhciB2aXNpdG9yID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQobm9kZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzkpO1xuICAgIGZ1bmN0aW9uIHdhbGtfYm9keShub2RlLCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciDVkNWPaXRyMTEsINWQ1Y9pZHgxMTtcbiAgICAgICAgdmFyIHN0YXQ7XG4gICAgICAgIGlmIChub2RlLmJvZHkgaW5zdGFuY2VvZiBTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIG5vZGUuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmJvZHkpIHtcbiAgICAgICAgICAgINWQ1Y9pdHIxMSA9INWQ1Y9fSXRlcmFibGUobm9kZS5ib2R5KTtcbiAgICAgICAgICAgIGZvciAo1ZDVj2lkeDExID0gMDsg1ZDVj2lkeDExIDwg1ZDVj2l0cjExLmxlbmd0aDsg1ZDVj2lkeDExKyspIHtcbiAgICAgICAgICAgICAgICBzdGF0ID0g1ZDVj2l0cjExW9WQ1Y9pZHgxMV07XG4gICAgICAgICAgICAgICAgc3RhdC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgQmxvY2sgPSAo1ZDVj18xMCA9IGZ1bmN0aW9uIEJsb2NrKCkge1xuICAgICAgICBTdGF0ZW1lbnQucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTAsIFN0YXRlbWVudCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMTAucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBib2R5OiBcIltTdGF0ZW1lbnQqXSBhbiBhcnJheSBvZiBzdGF0ZW1lbnRzXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsayh2aXNpdG9yKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB3YWxrX2JvZHkoc2VsZiwgdmlzaXRvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18xMCk7XG4gICAgdmFyIEJsb2NrU3RhdGVtZW50ID0gKNWQ1Y9fMTEgPSBmdW5jdGlvbiBCbG9ja1N0YXRlbWVudCgpIHtcbiAgICAgICAgQmxvY2sucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTEsIEJsb2NrKSwg1ZDVj18xMSk7XG4gICAgdmFyIEVtcHR5U3RhdGVtZW50ID0gKNWQ1Y9fMTIgPSBmdW5jdGlvbiBFbXB0eVN0YXRlbWVudCgpIHtcbiAgICAgICAgU3RhdGVtZW50LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzEyLCBTdGF0ZW1lbnQpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzEyLnByb3RvdHlwZSwge1xuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzEyKTtcbiAgICB2YXIgU3RhdGVtZW50V2l0aEJvZHkgPSAo1ZDVj18xMyA9IGZ1bmN0aW9uIFN0YXRlbWVudFdpdGhCb2R5KCkge1xuICAgICAgICBTdGF0ZW1lbnQucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTMsIFN0YXRlbWVudCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMTMucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBib2R5OiBcIltTdGF0ZW1lbnRdIHRoZSBib2R5OyB0aGlzIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCwgZXZlbiBpZiBpdCdzIGFuIEVtcHR5U3RhdGVtZW50XCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsayh2aXNpdG9yKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18xMyk7XG4gICAgdmFyIExhYmVsZWRTdGF0ZW1lbnQgPSAo1ZDVj18xNCA9IGZ1bmN0aW9uIExhYmVsZWRTdGF0ZW1lbnQoKSB7XG4gICAgICAgIFN0YXRlbWVudFdpdGhCb2R5LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzE0LCBTdGF0ZW1lbnRXaXRoQm9keSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMTQucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBsYWJlbDogXCJbTGFiZWxdIGEgbGFiZWwgZGVmaW5pdGlvblwiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYWJlbC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fMTQpO1xuICAgIHZhciBEV0xvb3AgPSAo1ZDVj18xNSA9IGZ1bmN0aW9uIERXTG9vcCgpIHtcbiAgICAgICAgU3RhdGVtZW50V2l0aEJvZHkucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTUsIFN0YXRlbWVudFdpdGhCb2R5KSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj18xNS5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogXCJbTm9kZV0gdGhlIGxvb3AgY29uZGl0aW9uLiAgU2hvdWxkIG5vdCBiZSBpbnN0YW5jZW9mIFN0YXRlbWVudFwiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzE1KTtcbiAgICB2YXIgRG8gPSAo1ZDVj18xNiA9IGZ1bmN0aW9uIERvKCkge1xuICAgICAgICBEV0xvb3AucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTYsIERXTG9vcCksINWQ1Y9fMTYpO1xuICAgIHZhciBXaGlsZSA9ICjVkNWPXzE3ID0gZnVuY3Rpb24gV2hpbGUoKSB7XG4gICAgICAgIERXTG9vcC5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj18xNywgRFdMb29wKSwg1ZDVj18xNyk7XG4gICAgdmFyIEZvckluID0gKNWQ1Y9fMTggPSBmdW5jdGlvbiBGb3JJbigpIHtcbiAgICAgICAgU3RhdGVtZW50V2l0aEJvZHkucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTgsIFN0YXRlbWVudFdpdGhCb2R5KSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj18xOC5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGluaXQ6IFwiW05vZGVdIHRoZSBgZm9yL2luYCBpbml0aWFsaXphdGlvbiBjb2RlXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJbU3ltYm9sUmVmP10gdGhlIGxvb3AgdmFyaWFibGUsIG9ubHkgaWYgYGluaXRgIGlzIFZhclwiLFxuICAgICAgICAgICAgICAgIG9iamVjdDogXCJbTm9kZV0gdGhlIG9iamVjdCB0aGF0IHdlJ3JlIGxvb3BpbmcgdGhyb3VnaFwiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbml0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9iamVjdC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fMTgpO1xuICAgIHZhciBGb3JKUyA9ICjVkNWPXzE5ID0gZnVuY3Rpb24gRm9ySlMoKSB7XG4gICAgICAgIFN0YXRlbWVudFdpdGhCb2R5LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzE5LCBTdGF0ZW1lbnRXaXRoQm9keSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMTkucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IFwiW1ZlcmJhdGltXSByYXcgSmF2YVNjcmlwdCBjb25kaXRpb25hbFwiXG4gICAgICAgICAgICB9ICAgICAgICB9XG4gICAgfSksINWQ1Y9fMTkpO1xuICAgIHZhciBMaXN0Q29tcHJlaGVuc2lvbiA9ICjVkNWPXzIwID0gZnVuY3Rpb24gTGlzdENvbXByZWhlbnNpb24oKSB7XG4gICAgICAgIEZvckluLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzIwLCBGb3JJbiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMjAucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IFwiW05vZGVdIHRoZSBgaWZgIGNvbmRpdGlvblwiLFxuICAgICAgICAgICAgICAgIHN0YXRlbWVudDogXCJbTm9kZV0gc3RhdGVtZW50IHRvIHBlcmZvcm0gb24gZWFjaCBlbGVtZW50IGJlZm9yZSByZXR1cm5pbmcgaXRcIlxuICAgICAgICAgICAgfSAgICAgICAgfSxcbiAgICAgICAgX3dhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWxrKHZpc2l0b3Ipe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQoc2VsZiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5pdC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zdGF0ZW1lbnQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzIwKTtcbiAgICB2YXIgRGljdENvbXByZWhlbnNpb24gPSAo1ZDVj18yMSA9IGZ1bmN0aW9uIERpY3RDb21wcmVoZW5zaW9uKCkge1xuICAgICAgICBMaXN0Q29tcHJlaGVuc2lvbi5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj18yMSwgTGlzdENvbXByZWhlbnNpb24pLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzIxLnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWVfc3RhdGVtZW50OiBcIltOb2RlXSBzdGF0ZW1lbnQgdG8gcGVyZm9ybSBvbiBlYWNoIHZhbHVlIGJlZm9yZSByZXR1cm5pbmcgaXRcIlxuICAgICAgICAgICAgfSAgICAgICAgfSxcbiAgICAgICAgX3dhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWxrKHZpc2l0b3Ipe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQoc2VsZiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5pdC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zdGF0ZW1lbnQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudmFsdWVfc3RhdGVtZW50Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18yMSk7XG4gICAgdmFyIFdpdGggPSAo1ZDVj18yMiA9IGZ1bmN0aW9uIFdpdGgoKSB7XG4gICAgICAgIFN0YXRlbWVudFdpdGhCb2R5LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzIyLCBTdGF0ZW1lbnRXaXRoQm9keSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMjIucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcIltOb2RlXSB0aGUgYHdpdGhgIGV4cHJlc3Npb25cIlxuICAgICAgICAgICAgfSAgICAgICAgfSxcbiAgICAgICAgX3dhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWxrKHZpc2l0b3Ipe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQoc2VsZiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fMjIpO1xuICAgIHZhciBTY29wZSA9ICjVkNWPXzIzID0gZnVuY3Rpb24gU2NvcGUoKSB7XG4gICAgICAgIEJsb2NrLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzIzLCBCbG9jayksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMjMucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBkb2NzdHJpbmc6IFwiW3N0cmluZz9dIGRvY3N0cmluZyBmb3IgdGhpcyBzY29wZSwgaWYgYW55XCIsXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlczogXCJbc3RyaW5nKi9TXSBhbiBhcnJheSBvZiBkaXJlY3RpdmVzIGRlY2xhcmVkIGluIHRoaXMgc2NvcGVcIixcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IFwiW09iamVjdC9TXSBhIG1hcCBvZiBuYW1lIC0+IFN5bWJvbERlZiBmb3IgYWxsIHZhcmlhYmxlcy9mdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIHNjb3BlXCIsXG4gICAgICAgICAgICAgICAgbG9jYWx2YXJzOiBcIltTeW1ib2xEZWYqXSBsaXN0IG9mIHZhcmlhYmxlcyBsb2NhbCB0byB0aGlzIHNjb3BlXCIsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25zOiBcIltPYmplY3QvU10gbGlrZSBgdmFyaWFibGVzYCwgYnV0IG9ubHkgbGlzdHMgZnVuY3Rpb24gZGVjbGFyYXRpb25zXCIsXG4gICAgICAgICAgICAgICAgcGFyZW50X3Njb3BlOiBcIltTY29wZT8vU10gbGluayB0byB0aGUgcGFyZW50IHNjb3BlXCIsXG4gICAgICAgICAgICAgICAgZW5jbG9zZWQ6IFwiW1N5bWJvbERlZiovU10gYSBsaXN0IG9mIGFsbCBzeW1ib2wgZGVmaW5pdGlvbnMgdGhhdCBhcmUgYWNjZXNzZWQgZnJvbSB0aGlzIHNjb3BlIG9yIGFueSBzdWJzY29wZXNcIlxuICAgICAgICAgICAgfSAgICAgICAgfVxuICAgIH0pLCDVkNWPXzIzKTtcbiAgICB2YXIgVG9wTGV2ZWwgPSAo1ZDVj18yNCA9IGZ1bmN0aW9uIFRvcExldmVsKCkge1xuICAgICAgICBTY29wZS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj18yNCwgU2NvcGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzI0LnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsczogXCJbT2JqZWN0L1NdIGEgbWFwIG9mIG5hbWUgLT4gU3ltYm9sRGVmIGZvciBhbGwgdW5kZWNsYXJlZCBuYW1lc1wiLFxuICAgICAgICAgICAgICAgIGJhc2VsaWI6IFwiW09iamVjdC9zXSBhIGNvbGxlY3Rpb24gb2YgdXNlZCBwYXJ0cyBvZiBiYXNlbGliXCIsXG4gICAgICAgICAgICAgICAgaW1wb3J0czogXCJbT2JqZWN0L1NdIGEgbWFwIG9mIG1vZHVsZV9pZC0+VG9wTGV2ZWwgZm9yIGFsbCBpbXBvcnRlZCBtb2R1bGVzXCIsXG4gICAgICAgICAgICAgICAgbm9ubG9jYWx2YXJzOiBcIltTdHJpbmcqXSBhIGxpc3Qgb2YgYWxsIG5vbi1sb2NhbCB2YXJpYWJsZSBuYW1lcyAobmFtZXMgdGhhdCBjb21lIGZyb20gdGhlIGdsb2JhbCBzY29wZSlcIixcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IFwiW2Jvb2xlYW4vU10gdHJ1ZSBpZiBzdHJpY3QgZGlyZWN0aXZlIGlzIGluIHNjb3BlXCIsXG4gICAgICAgICAgICAgICAgc2hlYmFuZzogXCJbc3RyaW5nXSBJZiAjISBsaW5lIGlzIHByZXNlbnQsIGl0IHdpbGwgYmUgc3RvcmVkIGhlcmVcIixcbiAgICAgICAgICAgICAgICBpbXBvcnRfb3JkZXI6IFwiW251bWJlcl0gVGhlIGdsb2JhbCBvcmRlciBpbiB3aGljaCB0aGlzIHNjb3BlIHdhcyBpbXBvcnRlZFwiLFxuICAgICAgICAgICAgICAgIG1vZHVsZV9pZDogXCJbc3RyaW5nXSBUaGUgaWQgb2YgdGhpcyBtb2R1bGVcIixcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBcIltTeW1ib2xEZWYqXSBsaXN0IG9mIG5hbWVzIGV4cG9ydGVkIGZyb20gdGhpcyBtb2R1bGVcIixcbiAgICAgICAgICAgICAgICBzdWJtb2R1bGVzOiBcIltzdHJpbmcqXSBsaXN0IG9mIG5hbWVzIGV4cG9ydGVkIGZyb20gdGhpcyBtb2R1bGVcIixcbiAgICAgICAgICAgICAgICBjbGFzc2VzOiBcIltPYmplY3QvU10gYSBtYXAgb2YgY2xhc3MgbmFtZXMgdG8gQ2xhc3MgZm9yIGNsYXNzZXMgZGVmaW5lZCBpbiB0aGlzIG1vZHVsZVwiLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBcIltzdHJpbmddIFRoZSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBmaWxlIGZyb20gd2hpY2ggdGhpcyBtb2R1bGUgd2FzIHJlYWRcIixcbiAgICAgICAgICAgICAgICBzcmNoYXNoOiBcIltzdHJpbmddIFNIQTEgaGFzaCBvZiBzb3VyY2UgY29kZSwgdXNlZCBmb3IgY2FjaGluZ1wiXG4gICAgICAgICAgICB9ICAgICAgICB9XG4gICAgfSksINWQ1Y9fMjQpO1xuICAgIHZhciBTcGxhdCA9ICjVkNWPXzI1ID0gZnVuY3Rpb24gU3BsYXQoKSB7XG4gICAgICAgIFN0YXRlbWVudC5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj18yNSwgU3RhdGVtZW50KSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj18yNS5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogXCJbU3ltYm9sVmFyXSBuYW1lIG9mIHRoZSBtb2R1bGUgd2UncmUgc3BsYXR0aW5nXCIsXG4gICAgICAgICAgICAgICAga2V5OiBcIltzdHJpbmddIFRoZSBrZXkgYnkgd2hpY2ggdGhpcyBtb2R1bGUgaXMgc3RvcmVkIGluIHRoZSBnbG9iYWwgbW9kdWxlcyBtYXBwaW5nXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJbVG9wTGV2ZWxdIHBhcnNlZCBjb250ZW50cyBvZiB0aGUgaW1wb3J0ZWQgZmlsZVwiXG4gICAgICAgICAgICB9ICAgICAgICB9XG4gICAgfSksINWQ1Y9fMjUpO1xuICAgIHZhciBJbXBvcnQgPSAo1ZDVj18yNiA9IGZ1bmN0aW9uIEltcG9ydCgpIHtcbiAgICAgICAgU3RhdGVtZW50LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzI2LCBTdGF0ZW1lbnQpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzI2LnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiBcIltTeW1ib2xWYXJdIG5hbWUgb2YgdGhlIG1vZHVsZSB3ZSdyZSBpbXBvcnRpbmdcIixcbiAgICAgICAgICAgICAgICBrZXk6IFwiW3N0cmluZ10gVGhlIGtleSBieSB3aGljaCB0aGlzIG1vZHVsZSBpcyBzdG9yZWQgaW4gdGhlIGdsb2JhbCBtb2R1bGVzIG1hcHBpbmdcIixcbiAgICAgICAgICAgICAgICBhbGlhczogXCJbU3ltYm9sQWxpYXNdIFRoZSBuYW1lIHRoaXMgbW9kdWxlIGlzIGltcG9ydGVkIGFzLCBjYW4gYmUgTm9uZS4gRm9yIGltcG9ydCB4IGFzIHkgc3RhdGVtZW50cy5cIixcbiAgICAgICAgICAgICAgICBhcmduYW1lczogXCJbSW1wb3J0ZWRWYXIqXSBuYW1lcyBvZiBvYmplY3RzIHRvIGJlIGltcG9ydGVkXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJbVG9wTGV2ZWxdIHBhcnNlZCBjb250ZW50cyBvZiB0aGUgaW1wb3J0ZWQgZmlsZVwiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyINWQ1Y9pdHIxMiwg1ZDVj2lkeDEyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgICAgICAgICDVkNWPaXRyMTIgPSDVkNWPX0l0ZXJhYmxlKHNlbGYuYXJnbmFtZXMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHgxMiA9IDA7INWQ1Y9pZHgxMiA8INWQ1Y9pdHIxMi5sZW5ndGg7INWQ1Y9pZHgxMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSDVkNWPaXRyMTJb1ZDVj2lkeDEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZy5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fMjYpO1xuICAgIHZhciBJbXBvcnRzID0gKNWQ1Y9fMjcgPSBmdW5jdGlvbiBJbXBvcnRzKCkge1xuICAgICAgICBTdGF0ZW1lbnQucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMjcsIFN0YXRlbWVudCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMjcucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBcImltcG9ydHNcIjogXCJbSW1wb3J0K10gYXJyYXkgb2YgaW1wb3J0c1wiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyINWQ1Y9pdHIxMywg1ZDVj2lkeDEzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW1wO1xuICAgICAgICAgICAgICAgICAgICDVkNWPaXRyMTMgPSDVkNWPX0l0ZXJhYmxlKHNlbGYuaW1wb3J0cyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDEzID0gMDsg1ZDVj2lkeDEzIDwg1ZDVj2l0cjEzLmxlbmd0aDsg1ZDVj2lkeDEzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcCA9INWQ1Y9pdHIxM1vVkNWPaWR4MTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1wLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18yNyk7XG4gICAgdmFyIERlY29yYXRvciA9ICjVkNWPXzI4ID0gZnVuY3Rpb24gRGVjb3JhdG9yKCkge1xuICAgICAgICBOb2RlLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzI4LCBOb2RlKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj18yOC5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiW05vZGVdIGRlY29yYXRvciBleHByZXNzaW9uXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsayh2aXNpdG9yKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24ud2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18yOCk7XG4gICAgdmFyIEFubm90YXRpb24gPSAo1ZDVj18yOSA9IGZ1bmN0aW9uIEFubm90YXRpb24oKSB7XG4gICAgICAgIE5vZGUucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMjksIE5vZGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzI5LnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJbTm9kZV0gZGVjb3JhdG9yIGV4cHJlc3Npb25cIlxuICAgICAgICAgICAgfSAgICAgICAgfSxcbiAgICAgICAgX3dhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWxrKHZpc2l0b3Ipe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi53YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKGhlYXApe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwYXJzZShvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyINWQ1Y9fMzA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5lbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyBwYXJzZShvYmouZWxlbWVudHNbMF0pICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbP11cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgT2JqZWN0TGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5wcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIntTdHJpbmc6XCIgKyBwYXJzZShvYmoucHJvcGVydGllc1swXS52YWx1ZSkgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIntTdHJpbmc6P31cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLm5hbWUgPT09IFwiQXJyYXlcIiA/IFwiWz9dXCIgOiDVkNWPX2luKG9iai5uYW1lLCBbIFwiT2JqZWN0XCIsIFwiRGljdGlvbmFyeVwiIF0pID8gXCJ7U3RyaW5nOj99XCIgOiBvYmoubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5leHByZXNzaW9uIGluc3RhbmNlb2YgU3ltYm9sUmVmICYmIG9iai5leHByZXNzaW9uLm5hbWUgPT09IFwiQXJyYXlcIiAmJiBvYmouYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyBwYXJzZShvYmouYXJnc1swXSkgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFN5bWJvbFJlZiAmJiDVkNWPX2luKG9iai5leHByZXNzaW9uLm5hbWUsIFsgXCJPYmplY3RcIiwgXCJEaWN0aW9uYXJ5XCIgXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMSA8PSAo1ZDVj18zMCA9IG9iai5hcmdzLmxlbmd0aCkgJiYg1ZDVj18zMCA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIntTdHJpbmc6XCIgKyBwYXJzZShvYmouYXJnc1tvYmouYXJncy5sZW5ndGgtMV0pICsgXCJ9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIntTdHJpbmc6P31cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI/XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZShzZWxmLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzI5KTtcbiAgICB2YXIgTGFtYmRhID0gKNWQ1Y9fMzEgPSBmdW5jdGlvbiBMYW1iZGEoKSB7XG4gICAgICAgIFNjb3BlLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzMxLCBTY29wZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMzEucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIltTeW1ib2xEZWNsYXJhdGlvbj9dIHRoZSBuYW1lIG9mIHRoaXMgZnVuY3Rpb24vY2xhc3MvbWV0aG9kXCIsXG4gICAgICAgICAgICAgICAgYXJnbmFtZXM6IFwiW1N5bWJvbEZ1bmFyZypdIGFycmF5IG9mIGFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgICAgIGt3YXJnczogXCJbU3ltYm9sRnVuYXJnP10ga3dhcmdzIHN5bWJvbCwgaWYgYW55XCIsXG4gICAgICAgICAgICAgICAgdXNlc19hcmd1bWVudHM6IFwiW2Jvb2xlYW4vU10gdGVsbHMgd2hldGhlciB0aGlzIGZ1bmN0aW9uIGFjY2Vzc2VzIHRoZSBhcmd1bWVudHMgYXJyYXlcIixcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3JzOiBcIltEZWNvcmF0b3IqXSBmdW5jdGlvbiBkZWNvcmF0b3JzLCBpZiBhbnlcIixcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6IFwiW2Jvb2xlYW5dIHRydWUgaWYgdGhpcyBpcyBhIGdlbmVyYXRvciBmdW5jdGlvbiAoZmFsc2UgYnkgZGVmYXVsdClcIixcbiAgICAgICAgICAgICAgICByZXR1cm5fYW5ub3RhdGlvbjogXCJbQW5ub3RhdGlvbj9dIHRoZSByZXR1cm4gdHlwZSBhbm5vdGF0aW9uIHByb3ZpZGVkIChpZiBhbnkpXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsayh2aXNpdG9yKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjE0LCDVkNWPaWR4MTQsINWQ1Y9pdHIxNSwg1ZDVj2lkeDE1O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCwgYXJnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kZWNvcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICDVkNWPaXRyMTQgPSDVkNWPX0l0ZXJhYmxlKHNlbGYuZGVjb3JhdG9ycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHgxNCA9IDA7INWQ1Y9pZHgxNCA8INWQ1Y9pdHIxNC5sZW5ndGg7INWQ1Y9pZHgxNCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9INWQ1Y9pdHIxNFvVkNWPaWR4MTRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQud2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm5hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjE1ID0g1ZDVj19JdGVyYWJsZShzZWxmLmFyZ25hbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4MTUgPSAwOyDVkNWPaWR4MTUgPCDVkNWPaXRyMTUubGVuZ3RoOyDVkNWPaWR4MTUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0g1ZDVj2l0cjE1W9WQ1Y9pZHgxNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJnbmFtZXMuc3RhcmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXJnbmFtZXMuc3RhcmFyZ3MuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYua3dhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmt3YXJncy5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3YWxrX2JvZHkoc2VsZiwgdmlzaXRvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18zMSk7XG4gICAgdmFyIEFjY2Vzc29yID0gKNWQ1Y9fMzIgPSBmdW5jdGlvbiBBY2Nlc3NvcigpIHtcbiAgICAgICAgTGFtYmRhLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzMyLCBMYW1iZGEpLCDVkNWPXzMyKTtcbiAgICB2YXIgRnVuY3Rpb24gPSAo1ZDVj18zMyA9IGZ1bmN0aW9uIEZ1bmN0aW9uKCkge1xuICAgICAgICBMYW1iZGEucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMzMsIExhbWJkYSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMzMucHJvdG90eXBlLCB7XG4gICAgICAgIHJlc29sdmVUeXBlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBtZW1vaXplZChmdW5jdGlvbiByZXNvbHZlVHlwZShoZWFwKXtcbiAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjE2LCDVkNWPaWR4MTY7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0ZWQsIGFyZ3MsIGFyZywgY29tcHV0ZWRUeXBlLCByZXN1bHQsIHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmduYW1lcy5zdGFyYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJGdW5jdGlvblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbm5vdGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICDVkNWPaXRyMTYgPSDVkNWPX0l0ZXJhYmxlKHNlbGYuYXJnbmFtZXMpO1xuICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDE2ID0gMDsg1ZDVj2lkeDE2IDwg1ZDVj2l0cjE2Lmxlbmd0aDsg1ZDVj2lkeDE2KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0g1ZDVj2l0cjE2W9WQ1Y9pZHgxNl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcuYW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRUeXBlID0gYXJnLmFubm90YXRpb24ucmVzb2x2ZVR5cGUoaGVhcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNvbXB1dGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5yZXR1cm5fYW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmLnJldHVybl9hbm5vdGF0aW9uLnJlc29sdmVUeXBlKGhlYXApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gXCJGdW5jdGlvblwiO1xuICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlICs9IFwiKFwiICsgYXJncy5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgKz0gXCIgLT4gXCIgKyByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18zMyk7XG4gICAgdmFyIENsYXNzID0gKNWQ1Y9fMzQgPSBmdW5jdGlvbiBDbGFzcygpIHtcbiAgICAgICAgU2NvcGUucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMzQsIFNjb3BlKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj18zNC5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiW1N5bWJvbERlY2xhcmF0aW9uP10gdGhlIG5hbWUgb2YgdGhpcyBjbGFzc1wiLFxuICAgICAgICAgICAgICAgIGluaXQ6IFwiW0Z1bmN0aW9uXSBjb25zdHJ1Y3RvciBmb3IgdGhlIGNsYXNzXCIsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBcIltDbGFzcz9dIHBhcmVudCBjbGFzcyB0aGlzIGNsYXNzIGluaGVyaXRzIGZyb21cIixcbiAgICAgICAgICAgICAgICBzdGF0aWM6IFwiW3N0cmluZypdIGxpc3Qgb2Ygc3RhdGljIG1ldGhvZHNcIixcbiAgICAgICAgICAgICAgICBleHRlcm5hbDogXCJbYm9vbGVhbl0gdHJ1ZSBpZiBjbGFzcyBpcyBkZWNsYXJlZCBlbHNld2hlcmUsIGJ1dCB3aWxsIGJlIHdpdGhpbiBjdXJyZW50IHNjb3BlIGF0IHJ1bnRpbWVcIixcbiAgICAgICAgICAgICAgICBib3VuZDogXCJbc3RyaW5nKl0gaGFzaCBvZiBtZXRob2RzIHRoYXQgbmVlZCB0byBiZSBib3VuZCB0byBiZWhhdmUgY29ycmVjdGx5IChmdW5jdGlvbiBwb2ludGVycylcIixcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3JzOiBcIltEZWNvcmF0b3IqXSBmdW5jdGlvbiBkZWNvcmF0b3JzLCBpZiBhbnlcIixcbiAgICAgICAgICAgICAgICBtb2R1bGVfaWQ6IFwiW3N0cmluZ10gVGhlIGlkIG9mIHRoZSBtb2R1bGUgdGhpcyBjbGFzcyBpcyBkZWZpbmVkIGluXCIsXG4gICAgICAgICAgICAgICAgc3RhdGVtZW50czogXCJbTm9kZSpdIGxpc3Qgb2Ygc3RhdGVtZW50cyBpbiB0aGUgY2xhc3Mgc2NvcGUgKGV4Y2x1ZGluZyBtZXRob2QgZGVmaW5pdGlvbnMpXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsayh2aXNpdG9yKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm5hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIHdhbGtfYm9keSh0aGlzLCB2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcmVudC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXNvbHZlVHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogbWVtb2l6ZWQoZnVuY3Rpb24gcmVzb2x2ZVR5cGUoaGVhcCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLm5hbWUubmFtZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18zNCk7XG4gICAgdmFyIE1vZHVsZSA9ICjVkNWPXzM1ID0gZnVuY3Rpb24gTW9kdWxlKCkge1xuICAgICAgICBTY29wZS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj18zNSwgU2NvcGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzM1LnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJbU3ltYm9sRGVjbGFyYXRpb24/XSB0aGUgbmFtZSBvZiB0aGlzIGNsYXNzXCIsXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWw6IFwiW2Jvb2xlYW5dIHRydWUgaWYgbW9kdWxlIGlzIGRlY2xhcmVkIGVsc2V3aGVyZSwgYnV0IHdpbGwgYmUgd2l0aGluIGN1cnJlbnQgc2NvcGUgYXQgcnVudGltZVwiLFxuICAgICAgICAgICAgICAgIGRlY29yYXRvcnM6IFwiW0RlY29yYXRvcipdIG1vZHVsZSBkZWNvcmF0b3JzLCBpZiBhbnlcIlxuICAgICAgICAgICAgfSAgICAgICAgfVxuICAgIH0pLCDVkNWPXzM1KTtcbiAgICB2YXIgTWV0aG9kID0gKNWQ1Y9fMzYgPSBmdW5jdGlvbiBNZXRob2QoKSB7XG4gICAgICAgIExhbWJkYS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj18zNiwgTGFtYmRhKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj18zNi5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHN0YXRpYzogXCJbYm9vbGVhbl0gdHJ1ZSBpZiBtZXRob2QgaXMgc3RhdGljXCJcbiAgICAgICAgICAgIH0gICAgICAgIH1cbiAgICB9KSwg1ZDVj18zNik7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gKNWQ1Y9fMzcgPSBmdW5jdGlvbiBDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgTWV0aG9kLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzM3LCBNZXRob2QpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzM3LnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgY2FsbHNTdXBlcjogXCJbYm9vbGVhbl0gdHJ1ZSBpZiB1c2VyIG1hbnVhbGx5IGNhbGxlZCBzdXBlciBvciBQYXJlbnQuX19pbml0X19cIixcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IFwiW3N0cmluZz9dIHBhcmVudCBjbGFzcyB0aGlzIGNsYXNzIGluaGVyaXRzIGZyb21cIlxuICAgICAgICAgICAgfSAgICAgICAgfVxuICAgIH0pLCDVkNWPXzM3KTtcbiAgICB2YXIgSnVtcCA9ICjVkNWPXzM4ID0gZnVuY3Rpb24gSnVtcCgpIHtcbiAgICAgICAgU3RhdGVtZW50LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzM4LCBTdGF0ZW1lbnQpLCDVkNWPXzM4KTtcbiAgICB2YXIgRXhpdCA9ICjVkNWPXzM5ID0gZnVuY3Rpb24gRXhpdCgpIHtcbiAgICAgICAgSnVtcC5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj18zOSwgSnVtcCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMzkucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJbTm9kZT9dIHRoZSB2YWx1ZSByZXR1cm5lZCBvciB0aHJvd24gYnkgdGhpcyBzdGF0ZW1lbnQ7IGNvdWxkIGJlIG51bGwgZm9yIFJldHVyblwiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudmFsdWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKGhlYXApe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi52YWx1ZS5yZXNvbHZlVHlwZShoZWFwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18zOSk7XG4gICAgdmFyIFJldHVybiA9ICjVkNWPXzQwID0gZnVuY3Rpb24gUmV0dXJuKCkge1xuICAgICAgICBFeGl0LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzQwLCBFeGl0KSwg1ZDVj180MCk7XG4gICAgdmFyIFlpZWxkID0gKNWQ1Y9fNDEgPSBmdW5jdGlvbiBZaWVsZCgpIHtcbiAgICAgICAgRXhpdC5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj180MSwgRXhpdCksINWQ1Y9fNDEpO1xuICAgIHZhciBUaHJvdyA9ICjVkNWPXzQyID0gZnVuY3Rpb24gVGhyb3coKSB7XG4gICAgICAgIEV4aXQucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fNDIsIEV4aXQpLCDVkNWPXzQyKTtcbiAgICB2YXIgTG9vcENvbnRyb2wgPSAo1ZDVj180MyA9IGZ1bmN0aW9uIExvb3BDb250cm9sKCkge1xuICAgICAgICBKdW1wLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzQzLCBKdW1wKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj180My5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBcIltMYWJlbFJlZj9dIHRoZSBsYWJlbCwgb3IgbnVsbCBpZiBub25lXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsayh2aXNpdG9yKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sYWJlbC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fNDMpO1xuICAgIHZhciBCcmVhayA9ICjVkNWPXzQ0ID0gZnVuY3Rpb24gQnJlYWsoKSB7XG4gICAgICAgIExvb3BDb250cm9sLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzQ0LCBMb29wQ29udHJvbCksINWQ1Y9fNDQpO1xuICAgIHZhciBDb250aW51ZSA9ICjVkNWPXzQ1ID0gZnVuY3Rpb24gQ29udGludWUoKSB7XG4gICAgICAgIExvb3BDb250cm9sLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzQ1LCBMb29wQ29udHJvbCksINWQ1Y9fNDUpO1xuICAgIHZhciBJZiA9ICjVkNWPXzQ2ID0gZnVuY3Rpb24gSWYoKSB7XG4gICAgICAgIFN0YXRlbWVudFdpdGhCb2R5LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzQ2LCBTdGF0ZW1lbnRXaXRoQm9keSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNDYucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IFwiW05vZGVdIHRoZSBgaWZgIGNvbmRpdGlvblwiLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBcIltTdGF0ZW1lbnQ/XSB0aGUgYGVsc2VgIHBhcnQsIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIlxuICAgICAgICAgICAgfSAgICAgICAgfSxcbiAgICAgICAgX3dhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWxrKHZpc2l0b3Ipe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQoc2VsZiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFsdGVybmF0aXZlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj180Nik7XG4gICAgdmFyIFN3aXRjaCA9ICjVkNWPXzQ3ID0gZnVuY3Rpb24gU3dpdGNoKCkge1xuICAgICAgICBCbG9jay5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj180NywgQmxvY2spLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzQ3LnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJbTm9kZV0gdGhlIGBzd2l0Y2hgIOKAnGRpc2NyaW1pbmFudOKAnVwiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICB3YWxrX2JvZHkoc2VsZiwgdmlzaXRvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj180Nyk7XG4gICAgdmFyIFN3aXRjaEJyYW5jaCA9ICjVkNWPXzQ4ID0gZnVuY3Rpb24gU3dpdGNoQnJhbmNoKCkge1xuICAgICAgICBCbG9jay5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj180OCwgQmxvY2spLCDVkNWPXzQ4KTtcbiAgICB2YXIgRGVmYXVsdCA9ICjVkNWPXzQ5ID0gZnVuY3Rpb24gRGVmYXVsdCgpIHtcbiAgICAgICAgU3dpdGNoQnJhbmNoLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzQ5LCBTd2l0Y2hCcmFuY2gpLCDVkNWPXzQ5KTtcbiAgICB2YXIgQ2FzZSA9ICjVkNWPXzUwID0gZnVuY3Rpb24gQ2FzZSgpIHtcbiAgICAgICAgU3dpdGNoQnJhbmNoLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzUwLCBTd2l0Y2hCcmFuY2gpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzUwLnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJbTm9kZV0gdGhlIGBjYXNlYCBleHByZXNzaW9uXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsayh2aXNpdG9yKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIHdhbGtfYm9keShzZWxmLCB2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzUwKTtcbiAgICB2YXIgVHJ5ID0gKNWQ1Y9fNTEgPSBmdW5jdGlvbiBUcnkoKSB7XG4gICAgICAgIEJsb2NrLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzUxLCBCbG9jayksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNTEucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBiY2F0Y2g6IFwiW0NhdGNoP10gdGhlIGNhdGNoIGJsb2NrLCBvciBudWxsIGlmIG5vdCBwcmVzZW50XCIsXG4gICAgICAgICAgICAgICAgYmZpbmFsbHk6IFwiW0ZpbmFsbHk/XSB0aGUgZmluYWxseSBibG9jaywgb3IgbnVsbCBpZiBub3QgcHJlc2VudFwiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa19ib2R5KHNlbGYsIHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5iY2F0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmNhdGNoLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmJmaW5hbGx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJmaW5hbGx5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj181MSk7XG4gICAgdmFyIENhdGNoID0gKNWQ1Y9fNTIgPSBmdW5jdGlvbiBDYXRjaCgpIHtcbiAgICAgICAgQmxvY2sucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fNTIsIEJsb2NrKSwg1ZDVj181Mik7XG4gICAgdmFyIEV4Y2VwdCA9ICjVkNWPXzUzID0gZnVuY3Rpb24gRXhjZXB0KCkge1xuICAgICAgICBCbG9jay5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj181MywgQmxvY2spLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzUzLnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgYXJnbmFtZTogXCJbU3ltYm9sQ2F0Y2hdIHN5bWJvbCBmb3IgdGhlIGV4Y2VwdGlvblwiLFxuICAgICAgICAgICAgICAgIGVycm9yczogXCJbU3ltYm9sVmFyKl0gZXJyb3IgY2xhc3NlcyB0byBjYXRjaCBpbiB0aGlzIGJsb2NrXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsayh2aXNpdG9yKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjE3LCDVkNWPaWR4MTc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmduYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFyZ25hbWUud2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgINWQ1Y9pdHIxNyA9INWQ1Y9fSXRlcmFibGUoc2VsZi5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4MTcgPSAwOyDVkNWPaWR4MTcgPCDVkNWPaXRyMTcubGVuZ3RoOyDVkNWPaWR4MTcrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSDVkNWPaXRyMTdb1ZDVj2lkeDE3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLndhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2Fsa19ib2R5KHNlbGYsIHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fNTMpO1xuICAgIHZhciBGaW5hbGx5ID0gKNWQ1Y9fNTQgPSBmdW5jdGlvbiBGaW5hbGx5KCkge1xuICAgICAgICBCbG9jay5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj181NCwgQmxvY2spLCDVkNWPXzU0KTtcbiAgICB2YXIgRGVmaW5pdGlvbnMgPSAo1ZDVj181NSA9IGZ1bmN0aW9uIERlZmluaXRpb25zKCkge1xuICAgICAgICBTdGF0ZW1lbnQucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fNTUsIFN0YXRlbWVudCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNTUucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uczogXCJbVmFyRGVmKl0gYXJyYXkgb2YgdmFyaWFibGUgZGVmaW5pdGlvbnNcIlxuICAgICAgICAgICAgfSAgICAgICAgfSxcbiAgICAgICAgX3dhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWxrKHZpc2l0b3Ipe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQoc2VsZiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciDVkNWPaXRyMTgsINWQ1Y9pZHgxODtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZl87XG4gICAgICAgICAgICAgICAgICAgINWQ1Y9pdHIxOCA9INWQ1Y9fSXRlcmFibGUoc2VsZi5kZWZpbml0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDE4ID0gMDsg1ZDVj2lkeDE4IDwg1ZDVj2l0cjE4Lmxlbmd0aDsg1ZDVj2lkeDE4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZl8gPSDVkNWPaXRyMThb1ZDVj2lkeDE4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZl8uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzU1KTtcbiAgICB2YXIgVmFyID0gKNWQ1Y9fNTYgPSBmdW5jdGlvbiBWYXIoKSB7XG4gICAgICAgIERlZmluaXRpb25zLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzU2LCBEZWZpbml0aW9ucyksINWQ1Y9fNTYpO1xuICAgIHZhciBDb25zdCA9ICjVkNWPXzU3ID0gZnVuY3Rpb24gQ29uc3QoKSB7XG4gICAgICAgIERlZmluaXRpb25zLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzU3LCBEZWZpbml0aW9ucyksINWQ1Y9fNTcpO1xuICAgIHZhciBWYXJEZWYgPSAo1ZDVj181OCA9IGZ1bmN0aW9uIFZhckRlZigpIHtcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj181OCwgTm9kZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNTgucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIltTeW1ib2xWYXJ8U3ltYm9sQ29uc3RdIG5hbWUgb2YgdGhlIHZhcmlhYmxlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiW05vZGU/XSBpbml0aWFsaXplciwgb3IgbnVsbCBpZiB0aGVyZSdzIG5vIGluaXRpYWxpemVyXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsayh2aXNpdG9yKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm5hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj181OCk7XG4gICAgdmFyIEJhc2VDYWxsID0gKNWQ1Y9fNTkgPSBmdW5jdGlvbiBCYXNlQ2FsbCgpIHtcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj181OSwgTm9kZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNTkucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBhcmdzOiBcIltOb2RlKl0gYXJyYXkgb2YgYXJndW1lbnRzXCJcbiAgICAgICAgICAgIH0gICAgICAgIH1cbiAgICB9KSwg1ZDVj181OSk7XG4gICAgdmFyIENhbGwgPSAo1ZDVj182MCA9IGZ1bmN0aW9uIENhbGwoKSB7XG4gICAgICAgIEJhc2VDYWxsLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzYwLCBCYXNlQ2FsbCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNjAucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcIltOb2RlXSBleHByZXNzaW9uIHRvIGludm9rZSBhcyBmdW5jdGlvblwiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyINWQ1Y9pdHIxOSwg1ZDVj2lkeDE5LCDVkNWPaXRyMjAsINWQ1Y9pZHgyMCwg1ZDVj2l0cjIxLCDVkNWPaWR4MjE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjE5ID0g1ZDVj19JdGVyYWJsZShzZWxmLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHgxOSA9IDA7INWQ1Y9pZHgxOSA8INWQ1Y9pdHIxOS5sZW5ndGg7INWQ1Y9pZHgxOSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSDVkNWPaXRyMTlb1ZDVj2lkeDE5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZy5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmt3YXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjIwID0g1ZDVj19JdGVyYWJsZShzZWxmLmFyZ3Mua3dhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDIwID0gMDsg1ZDVj2lkeDIwIDwg1ZDVj2l0cjIwLmxlbmd0aDsg1ZDVj2lkeDIwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSDVkNWPaXRyMjBb1ZDVj2lkeDIwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdbMF0uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnWzFdLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFyZ3Mua3dhcmdfaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgINWQ1Y9pdHIyMSA9INWQ1Y9fSXRlcmFibGUoc2VsZi5hcmdzLmt3YXJnX2l0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDIxID0gMDsg1ZDVj2lkeDIxIDwg1ZDVj2l0cjIxLmxlbmd0aDsg1ZDVj2lkeDIxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSDVkNWPaXRyMjFb1ZDVj2lkeDIxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKGhlYXApe1xuICAgICAgICAgICAgICAgIHZhciDVkNWPaXRyMjIsINWQ1Y9pZHgyMjtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHNjb3BlLCBwYXJzZSwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBTeW1ib2xSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjIyID0g1ZDVj19JdGVyYWJsZShyZXZlcnNlZChoZWFwKSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDIyID0gMDsg1ZDVj2lkeDIyIDwg1ZDVj2l0cjIyLmxlbmd0aDsg1ZDVj2lkeDIyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0g1ZDVj2l0cjIyW9WQ1Y9pZHgyMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAo1ZDVj19pbihzZWxmLmV4cHJlc3Npb24ubmFtZSwgc2NvcGUudmFycykgJiYg1ZDVj19pbihcIi0+XCIsIHNjb3BlLnZhcnNbc2VsZi5leHByZXNzaW9uLm5hbWVdW3Njb3BlLnZhcnNbc2VsZi5leHByZXNzaW9uLm5hbWVdLmxlbmd0aC0xXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUudmFyc1tzZWxmLmV4cHJlc3Npb24ubmFtZV1bc2NvcGUudmFyc1tzZWxmLmV4cHJlc3Npb24ubmFtZV0ubGVuZ3RoLTFdLnNwbGl0KFwiLT5cIilbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICjVkNWPX2luKHNlbGYuZXhwcmVzc2lvbi5uYW1lLCBzY29wZS5mdW5jdGlvbnMpICYmINWQ1Y9faW4oXCItPlwiLCBzY29wZS5mdW5jdGlvbnNbc2VsZi5leHByZXNzaW9uLm5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5mdW5jdGlvbnNbc2VsZi5leHByZXNzaW9uLm5hbWVdLnNwbGl0KFwiLT5cIilbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY29wZS50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZi5leHByZXNzaW9uLm5hbWUgPT09IHNjb3BlLm5hbWUgJiYgc2NvcGUucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2UgPSBmdW5jdGlvbih2YXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIg1ZDVj182MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXAsIHdyYXBwZXIsIGVsZW1lbnQsIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJyYXlcIjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyB2YWx1ZSArIFwiXVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGljdFwiOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIntTdHJpbmc6XCIgKyB2YWx1ZSArIFwifVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFzZVwiOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlciA9IFwiYmFzZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlLmVsZW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIgPSBcImFycmF5XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gdmFyaWFibGUuZWxlbWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFyaWFibGUgaW5zdGFuY2VvZiBDYWxsICYmIHZhcmlhYmxlLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBTeW1ib2xSZWYgJiYgdmFyaWFibGUuZXhwcmVzc2lvbi5uYW1lID09PSBcIkFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZS5hcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIgPSBcImFycmF5XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gdmFyaWFibGUuYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIE9iamVjdExpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZS5wcm9wZXJ0aWVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIgPSBcImRpY3RcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSB2YXJpYWJsZS5wcm9wZXJ0aWVzWzBdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhcmlhYmxlIGluc3RhbmNlb2YgQ2FsbCAmJiB2YXJpYWJsZS5leHByZXNzaW9uIGluc3RhbmNlb2YgU3ltYm9sUmVmICYmINWQ1Y9faW4odmFyaWFibGUuZXhwcmVzc2lvbi5uYW1lLCBbIFwiT2JqZWN0XCIsIFwiRGljdGlvbmFyeVwiIF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMSA8PSAo1ZDVj182MSA9IHZhcmlhYmxlLmFyZ3MubGVuZ3RoKSAmJiDVkNWPXzYxIDw9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gdmFyaWFibGUuYXJnc1t2YXJpYWJsZS5hcmdzLmxlbmd0aC0xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyID0gXCJkaWN0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSB2YXJpYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFN5bWJvbFJlZiAmJiDVkNWPX2luKGVsZW1lbnQubmFtZSwgTkFUSVZFX0NMQVNTRVMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcFt3cmFwcGVyXShlbGVtZW50Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheSB8fCBlbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0TGl0ZXJhbCB8fCBlbGVtZW50IGluc3RhbmNlb2YgQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2UoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBbd3JhcHBlcl0ocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2Uoc2NvcGUucmV0dXJuX2Fubm90YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiP1wiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzYwKTtcbiAgICB2YXIgQ2xhc3NDYWxsID0gKNWQ1Y9fNjIgPSBmdW5jdGlvbiBDbGFzc0NhbGwoKSB7XG4gICAgICAgIEJhc2VDYWxsLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzYyLCBCYXNlQ2FsbCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNjIucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogXCJbc3RyaW5nXSBuYW1lIG9mIHRoZSBjbGFzcyBtZXRob2QgYmVsb25ncyB0b1wiLFxuICAgICAgICAgICAgICAgIHN1cGVyOiBcIltib29sZWFuXSB0aGlzIGNhbGwgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBzdXBlcigpIGNhbGxcIixcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiW3N0cmluZ10gY2xhc3MgbWV0aG9kIGJlaW5nIGNhbGxlZFwiLFxuICAgICAgICAgICAgICAgIHN0YXRpYzogXCJbYm9vbGVhbl0gZGVmaW5lcyB3aGV0aGVyIHRoZSBtZXRob2QgaXMgc3RhdGljXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsayh2aXNpdG9yKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjIzLCDVkNWPaWR4MjMsINWQ1Y9pdHIyNCwg1ZDVj2lkeDI0LCDVkNWPaXRyMjUsINWQ1Y9pZHgyNTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgINWQ1Y9pdHIyMyA9INWQ1Y9fSXRlcmFibGUoc2VsZi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4MjMgPSAwOyDVkNWPaWR4MjMgPCDVkNWPaXRyMjMubGVuZ3RoOyDVkNWPaWR4MjMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0g1ZDVj2l0cjIzW9WQ1Y9pZHgyM107XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjI0ID0g1ZDVj19JdGVyYWJsZShzZWxmLmFyZ3Mua3dhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4MjQgPSAwOyDVkNWPaWR4MjQgPCDVkNWPaXRyMjQubGVuZ3RoOyDVkNWPaWR4MjQrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0g1ZDVj2l0cjI0W9WQ1Y9pZHgyNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdbMF0uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdbMV0uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjI1ID0g1ZDVj19JdGVyYWJsZShzZWxmLmFyZ3Mua3dhcmdfaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHgyNSA9IDA7INWQ1Y9pZHgyNSA8INWQ1Y9pdHIyNS5sZW5ndGg7INWQ1Y9pZHgyNSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSDVkNWPaXRyMjVb1ZDVj2lkeDI1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZy5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fNjIpO1xuICAgIHZhciBOZXcgPSAo1ZDVj182MyA9IGZ1bmN0aW9uIE5ldygpIHtcbiAgICAgICAgQ2FsbC5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj182MywgQ2FsbCksINWQ1Y9fNjMpO1xuICAgIHZhciBTZXEgPSAo1ZDVj182NCA9IGZ1bmN0aW9uIFNlcSgpIHtcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj182NCwgTm9kZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNjQucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjYXI6IFwiW05vZGVdIGZpcnN0IGVsZW1lbnQgaW4gc2VxdWVuY2VcIixcbiAgICAgICAgICAgICAgICBjZHI6IFwiW05vZGVdIHNlY29uZCBlbGVtZW50IGluIHNlcXVlbmNlXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIGNvbnM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnMoeCwgeSl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBzZXE7XG4gICAgICAgICAgICAgICAgc2VxID0gbmV3IFNlcSh4KTtcbiAgICAgICAgICAgICAgICBzZXEuY2FyID0geDtcbiAgICAgICAgICAgICAgICBzZXEuY2RyID0geTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tX2FycmF5OiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tX2FycmF5KGFycmF5KXtcbiAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjI2LCDVkNWPaWR4MjY7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0LCBpLCBwO1xuICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5WzBdLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgINWQ1Y9pdHIyNiA9INWQ1Y9fSXRlcmFibGUocmFuZ2UoYXJyYXkubGVuZ3RoIC0gMSwgLTEsIC0xKSk7XG4gICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4MjYgPSAwOyDVkNWPaWR4MjYgPCDVkNWPaXRyMjYubGVuZ3RoOyDVkNWPaWR4MjYrKykge1xuICAgICAgICAgICAgICAgICAgICBpID0g1ZDVj2l0cjI2W9WQ1Y9pZHgyNl07XG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSBTZXEucHJvdG90eXBlLmNvbnMuY2FsbChhcnJheVtpXSwgbGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBsaXN0O1xuICAgICAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLmNkciAmJiAhcC5jZHIuY2RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmNkciA9IHAuY2RyLmNhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmNkcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvX2FycmF5OiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b19hcnJheSgpe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcCwgYTtcbiAgICAgICAgICAgICAgICBwID0gdGhpcztcbiAgICAgICAgICAgICAgICBhID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHAuY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAuY2RyICYmICEocC5jZHIgaW5zdGFuY2VvZiBTZXEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gocC5jZHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuY2RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQobm9kZSl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBwLCBjZWxsO1xuICAgICAgICAgICAgICAgIHAgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHAuY2RyIGluc3RhbmNlb2YgU2VxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCA9IFNlcS5wcm90b3R5cGUuY29ucy5jYWxsKHAuY2RyLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwLmNkciA9IGNlbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuY2RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3dhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWxrKHZpc2l0b3Ipe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQoc2VsZiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FyLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jZHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2RyLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj182NCk7XG4gICAgdmFyIFByb3BBY2Nlc3MgPSAo1ZDVj182NSA9IGZ1bmN0aW9uIFByb3BBY2Nlc3MoKSB7XG4gICAgICAgIE5vZGUucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fNjUsIE5vZGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzY1LnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJbTm9kZV0gdGhlIOKAnGNvbnRhaW5lcuKAnSBleHByZXNzaW9uXCIsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IFwiW05vZGV8c3RyaW5nXSB0aGUgcHJvcGVydHkgdG8gYWNjZXNzLiBGb3IgRG90IHRoaXMgaXMgYWx3YXlzIGEgcGxhaW4gc3RyaW5nLCB3aGlsZSBmb3IgU3ViIGl0J3MgYW4gYXJiaXRyYXJ5IE5vZGVcIlxuICAgICAgICAgICAgfSAgICAgICAgfVxuICAgIH0pLCDVkNWPXzY1KTtcbiAgICB2YXIgRG90ID0gKNWQ1Y9fNjYgPSBmdW5jdGlvbiBEb3QoKSB7XG4gICAgICAgIFByb3BBY2Nlc3MucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fNjYsIFByb3BBY2Nlc3MpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzY2LnByb3RvdHlwZSwge1xuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXNvbHZlVHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogbWVtb2l6ZWQoZnVuY3Rpb24gcmVzb2x2ZVR5cGUoaGVhcCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJUeXBlO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lclR5cGUgPSBzZWxmLmV4cHJlc3Npb24ucmVzb2x2ZVR5cGUoaGVhcCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lclR5cGUgJiYgY29udGFpbmVyVHlwZVswXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9cXHtcXHcrOiguKilcXH0vLmV4ZWMoY29udGFpbmVyVHlwZSlbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBcIj9cIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj182Nik7XG4gICAgdmFyIFN1YiA9ICjVkNWPXzY3ID0gZnVuY3Rpb24gU3ViKCkge1xuICAgICAgICBQcm9wQWNjZXNzLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzY3LCBQcm9wQWNjZXNzKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj182Ny5wcm90b3R5cGUsIHtcbiAgICAgICAgX3dhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWxrKHZpc2l0b3Ipe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQoc2VsZiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9wZXJ0eS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKGhlYXApe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyVHlwZTtcbiAgICAgICAgICAgICAgICBjb250YWluZXJUeXBlID0gc2VsZi5leHByZXNzaW9uLnJlc29sdmVUeXBlKGhlYXApO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXJUeXBlWzBdID09PSBcIltcIiAmJiBzZWxmLnByb3BlcnR5IGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gL1xcWyguKilcXF0vLmV4ZWMoY29udGFpbmVyVHlwZSlbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lclR5cGVbMF0gPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gL1xce1xcdys6KC4qKVxcfS8uZXhlYyhjb250YWluZXJUeXBlKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXCI/XCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fNjcpO1xuICAgIHZhciBTbGljZSA9ICjVkNWPXzY4ID0gZnVuY3Rpb24gU2xpY2UoKSB7XG4gICAgICAgIFByb3BBY2Nlc3MucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fNjgsIFByb3BBY2Nlc3MpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzY4LnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkyOiBcIltOb2RlXSB0aGUgMm5kIHByb3BlcnR5IHRvIGFjY2VzcyAtIHR5cGljYWxseSBlbmRpbmcgaW5kZXggZm9yIHRoZSBhcnJheS5cIixcbiAgICAgICAgICAgICAgICBhc3NpZ25tZW50OiBcIltOb2RlXSBUaGUgZGF0YSBiZWluZyBzcGxpY2VkIGluLlwiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnByb3BlcnR5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnByb3BlcnR5Mi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKGhlYXApe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5leHByZXNzaW9uLnJlc29sdmVUeXBlKGhlYXApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzY4KTtcbiAgICB2YXIgVW5hcnkgPSAo1ZDVj182OSA9IGZ1bmN0aW9uIFVuYXJ5KCkge1xuICAgICAgICBOb2RlLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzY5LCBOb2RlKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj182OS5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIltzdHJpbmddIHRoZSBvcGVyYXRvclwiLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiW05vZGVdIGV4cHJlc3Npb24gdGhhdCB0aGlzIHVuYXJ5IG9wZXJhdG9yIGFwcGxpZXMgdG9cIlxuICAgICAgICAgICAgfSAgICAgICAgfSxcbiAgICAgICAgX3dhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWxrKHZpc2l0b3Ipe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQoc2VsZiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKGhlYXApe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcGVyYXRvciA9PT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQm9vbGVhblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAo1ZDVj19pbihzZWxmLm9wZXJhdG9yLCBbIFwiLVwiLCBcIitcIiBdKSAmJiBzZWxmLmV4cHJlc3Npb24ucmVzb2x2ZVR5cGUoaGVhcCkgPT09IFwiTnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTnVtYmVyXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBcIj9cIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj182OSk7XG4gICAgdmFyIFVuYXJ5UHJlZml4ID0gKNWQ1Y9fNzAgPSBmdW5jdGlvbiBVbmFyeVByZWZpeCgpIHtcbiAgICAgICAgVW5hcnkucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fNzAsIFVuYXJ5KSwg1ZDVj183MCk7XG4gICAgdmFyIFVuYXJ5UG9zdGZpeCA9ICjVkNWPXzcxID0gZnVuY3Rpb24gVW5hcnlQb3N0Zml4KCkge1xuICAgICAgICBVbmFyeS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj183MSwgVW5hcnkpLCDVkNWPXzcxKTtcbiAgICB2YXIgQmluYXJ5ID0gKNWQ1Y9fNzIgPSBmdW5jdGlvbiBCaW5hcnkoKSB7XG4gICAgICAgIE5vZGUucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fNzIsIE5vZGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzcyLnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogXCJbTm9kZV0gbGVmdC1oYW5kIHNpZGUgZXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIltzdHJpbmddIHRoZSBvcGVyYXRvclwiLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBcIltOb2RlXSByaWdodC1oYW5kIHNpZGUgZXhwcmVzc2lvblwiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sZWZ0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJpZ2h0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXNvbHZlVHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogbWVtb2l6ZWQoZnVuY3Rpb24gcmVzb2x2ZVR5cGUoaGVhcCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0LCByaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoIShzZWxmLmxlZnQgJiYgc2VsZi5yaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiP1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZWZ0ID0gc2VsZi5sZWZ0LnJlc29sdmVUeXBlKGhlYXApO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gc2VsZi5sZWZ0LnJlc29sdmVUeXBlKGhlYXApO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSBcIk51bWJlclwiICYmIHJpZ2h0ID09PSBcIk51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk51bWJlclwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gXCJCb29sZWFuXCIgJiYgcmlnaHQgPT09IFwiQm9vbGVhblwiIHx8INWQ1Y9faW4oc2VsZi5vcGVyYXRvciwgWyBcIj09PVwiLCBcIiE9PVwiLCBcIj5cIiwgXCI+PVwiLCBcIjxcIiwgXCI8PVwiIF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkJvb2xlYW5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09IFwiU3RyaW5nXCIgJiYgc2VsZi5vcGVyYXRvciA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBcIj9cIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj183Mik7XG4gICAgdmFyIFJhbmdlID0gKNWQ1Y9fNzMgPSBmdW5jdGlvbiBSYW5nZSgpIHtcbiAgICAgICAgQmluYXJ5LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzczLCBCaW5hcnkpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzczLnByb3RvdHlwZSwge1xuICAgICAgICByZXNvbHZlVHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogbWVtb2l6ZWQoZnVuY3Rpb24gcmVzb2x2ZVR5cGUoaGVhcCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltOdW1iZXJdXCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fNzMpO1xuICAgIHZhciBEZWVwRXF1YWxpdHkgPSAo1ZDVj183NCA9IGZ1bmN0aW9uIERlZXBFcXVhbGl0eSgpIHtcbiAgICAgICAgQmluYXJ5LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzc0LCBCaW5hcnkpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzc0LnByb3RvdHlwZSwge1xuICAgICAgICByZXNvbHZlVHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogbWVtb2l6ZWQoZnVuY3Rpb24gcmVzb2x2ZVR5cGUoaGVhcCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkJvb2xlYW5cIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj183NCk7XG4gICAgdmFyIENvbmRpdGlvbmFsID0gKNWQ1Y9fNzUgPSBmdW5jdGlvbiBDb25kaXRpb25hbCgpIHtcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj183NSwgTm9kZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNzUucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IFwiW05vZGVdIHRlc3QgdG8gcnVuIGJlZm9yZSBkZWNpZGluZyB0aGUgcmV0dXJuIHZhbHVlXCIsXG4gICAgICAgICAgICAgICAgY29uc2VxdWVudDogXCJbTm9kZV0gcmV0dXJuIGV4cHJlc3Npb24gaW4gdGhlIGV2ZW50IG9uIHRydXRoeSB0ZXN0IGV2YWx1YXRpb25cIixcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZTogXCJbTm9kZV0gcmV0dXJuIGV4cHJlc3Npb24gaW4gdGhlIGV2ZW50IG9mIGZhbHN5IHRlc3QgZXZhbHVhdGlvblwiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICBfd2Fsazoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhbGsodmlzaXRvcil7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdChzZWxmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uc2VxdWVudC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKGhlYXApe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY29tcHV0ZWRUeXBlO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkVHlwZSA9IHNlbGYuY29uc2VxdWVudC5yZXNvbHZlVHlwZShoZWFwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcHV0ZWRUeXBlID09PSBzZWxmLmFsdGVybmF0aXZlLnJlc29sdmVUeXBlKGhlYXApID8gY29tcHV0ZWRUeXBlIDogXCI/XCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fNzUpO1xuICAgIHZhciBBc3NpZ24gPSAo1ZDVj183NiA9IGZ1bmN0aW9uIEFzc2lnbigpIHtcbiAgICAgICAgQmluYXJ5LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzc2LCBCaW5hcnkpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzc2LnByb3RvdHlwZSwge1xuICAgICAgICByZXNvbHZlVHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogbWVtb2l6ZWQoZnVuY3Rpb24gcmVzb2x2ZVR5cGUoaGVhcCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wZXJhdG9yID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yaWdodC5yZXNvbHZlVHlwZShoZWFwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiP1wiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzc2KTtcbiAgICB2YXIgQXJyYXkgPSAo1ZDVj183NyA9IGZ1bmN0aW9uIEFycmF5KCkge1xuICAgICAgICBOb2RlLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzc3LCBOb2RlKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj183Ny5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBcIltOb2RlKl0gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgICAgICAgICAgfSAgICAgICAgfSxcbiAgICAgICAgX3dhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWxrKHZpc2l0b3Ipe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQoc2VsZiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciDVkNWPaXRyMjcsINWQ1Y9pZHgyNztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xuICAgICAgICAgICAgICAgICAgICDVkNWPaXRyMjcgPSDVkNWPX0l0ZXJhYmxlKHNlbGYuZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHgyNyA9IDA7INWQ1Y9pZHgyNyA8INWQ1Y9pdHIyNy5sZW5ndGg7INWQ1Y9pZHgyNysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9INWQ1Y9pdHIyN1vVkNWPaWR4MjddO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKGhlYXApe1xuICAgICAgICAgICAgICAgIHZhciDVkNWPaXRyMjgsINWQ1Y9pZHgyODtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkLCBlbGVtZW50LCBjdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiWz9dXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gc2VsZi5lbGVtZW50c1swXS5yZXNvbHZlVHlwZShoZWFwKTtcbiAgICAgICAgICAgICAgICDVkNWPaXRyMjggPSDVkNWPX0l0ZXJhYmxlKHNlbGYuZWxlbWVudHMuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDI4ID0gMDsg1ZDVj2lkeDI4IDwg1ZDVj2l0cjI4Lmxlbmd0aDsg1ZDVj2lkeDI4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9INWQ1Y9pdHIyOFvVkNWPaWR4MjhdO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gZWxlbWVudC5yZXNvbHZlVHlwZShoZWFwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWQuaW5kZXhPZihcIkZ1bmN0aW9uXCIpID09PSAwICYmIGN1cnJlbnQuaW5kZXhPZihcIkZ1bmN0aW9uXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiW0Z1bmN0aW9uXVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiWz9dXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgZXhwZWN0ZWQgKyBcIl1cIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj183Nyk7XG4gICAgdmFyIFR1cGxlVW5wYWNrID0gKNWQ1Y9fNzggPSBmdW5jdGlvbiBUdXBsZVVucGFjaygpIHtcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj183OCwgTm9kZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNzgucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50czogXCJbTm9kZSpdIGFycmF5IG9mIGVsZW1lbnRzIGJlaW5nIGFzc2lnbmVkIHRvXCIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IFwiW05vZGVdIHJpZ2h0LWhhbmQgc2lkZSBleHByZXNzaW9uXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsayh2aXNpdG9yKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjI5LCDVkNWPaWR4Mjk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcbiAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjI5ID0g1ZDVj19JdGVyYWJsZShzZWxmLmVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4MjkgPSAwOyDVkNWPaWR4MjkgPCDVkNWPaXRyMjkubGVuZ3RoOyDVkNWPaWR4MjkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSDVkNWPaXRyMjlb1ZDVj2lkeDI5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmlnaHQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj183OCk7XG4gICAgdmFyIE9iamVjdExpdGVyYWwgPSAo1ZDVj183OSA9IGZ1bmN0aW9uIE9iamVjdExpdGVyYWwoKSB7XG4gICAgICAgIE5vZGUucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fNzksIE5vZGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzc5LnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogXCJbT2JqZWN0UHJvcGVydHkqXSBhcnJheSBvZiBwcm9wZXJ0aWVzXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2Fsayh2aXNpdG9yKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHNlbGYsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjMwLCDVkNWPaWR4MzA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wO1xuICAgICAgICAgICAgICAgICAgICDVkNWPaXRyMzAgPSDVkNWPX0l0ZXJhYmxlKHNlbGYucHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDMwID0gMDsg1ZDVj2lkeDMwIDwg1ZDVj2l0cjMwLmxlbmd0aDsg1ZDVj2lkeDMwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgPSDVkNWPaXRyMzBb1ZDVj2lkeDMwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKGhlYXApe1xuICAgICAgICAgICAgICAgIHZhciDVkNWPaXRyMzEsINWQ1Y9pZHgzMTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0LCBzcHJlYWQsIGV4cGVjdGVkLCBlbGVtZW50LCBjdXJyZW50LCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLnByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIntTdHJpbmc6P31cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIHNwcmVhZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNlbGYucHJvcGVydGllc1tzdGFydF0gaW5zdGFuY2VvZiBVbmFyeVByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICBzcHJlYWQgPSBzZWxmLnByb3BlcnRpZXNbc3RhcnRdLmV4cHJlc3Npb24ucmVzb2x2ZVR5cGUoaGVhcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICjVkNWPX2luKFwiP1wiLCBzcHJlYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ7U3RyaW5nOj99XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKytzdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBzZWxmLnByb3BlcnRpZXNbc3RhcnRdLnZhbHVlLnJlc29sdmVUeXBlKGhlYXApO1xuICAgICAgICAgICAgICAgINWQ1Y9pdHIzMSA9INWQ1Y9fSXRlcmFibGUoc2VsZi5wcm9wZXJ0aWVzLnNsaWNlKHN0YXJ0ICsgMSkpO1xuICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDMxID0gMDsg1ZDVj2lkeDMxIDwg1ZDVj2l0cjMxLmxlbmd0aDsg1ZDVj2lkeDMxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9INWQ1Y9pdHIzMVvVkNWPaWR4MzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFVuYXJ5UHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ByZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwcmVhZCAhPT0gZWxlbWVudC5leHByZXNzaW9uLnJlc29sdmVUeXBlKGhlYXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIntTdHJpbmc6P31cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcmVhZCA9IGVsZW1lbnQuZXhwcmVzc2lvbi5yZXNvbHZlVHlwZShoZWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBlbGVtZW50LnZhbHVlLnJlc29sdmVUeXBlKGhlYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkLmluZGV4T2YoXCJGdW5jdGlvblwiKSA9PT0gMCAmJiBjdXJyZW50LmluZGV4T2YoXCJGdW5jdGlvblwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ7U3RyaW5nOkZ1bmN0aW9ufVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ7U3RyaW5nOj99XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gXCJ7U3RyaW5nOlwiICsgZXhwZWN0ZWQgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICBpZiAoc3ByZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcHJlYWQgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIntTdHJpbmc6P31cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzc5KTtcbiAgICB2YXIgT2JqZWN0UHJvcGVydHkgPSAo1ZDVj184MCA9IGZ1bmN0aW9uIE9iamVjdFByb3BlcnR5KCkge1xuICAgICAgICBOb2RlLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzgwLCBOb2RlKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj184MC5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGtleTogXCJbTm9kZV0gdGhlIHByb3BlcnR5IG5hbWUgb3IgZXhwcmVzc2lvbiBmb3IgY29tcHV0ZWQga2V5IFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIltOb2RlXSBwcm9wZXJ0eSB2YWx1ZS4gRm9yIHNldHRlcnMgYW5kIGdldHRlcnMgdGhpcyBpcyBhbiBGdW5jdGlvbi5cIlxuICAgICAgICAgICAgfSAgICAgICAgfSxcbiAgICAgICAgX3dhbGs6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWxrKHZpc2l0b3Ipe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQoc2VsZiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYua2V5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fODApO1xuICAgIHZhciBPYmplY3RLZXlWYWwgPSAo1ZDVj184MSA9IGZ1bmN0aW9uIE9iamVjdEtleVZhbCgpIHtcbiAgICAgICAgT2JqZWN0UHJvcGVydHkucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fODEsIE9iamVjdFByb3BlcnR5KSwg1ZDVj184MSk7XG4gICAgdmFyIE9iamVjdFNldHRlciA9ICjVkNWPXzgyID0gZnVuY3Rpb24gT2JqZWN0U2V0dGVyKCkge1xuICAgICAgICBBY2Nlc3Nvci5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj184MiwgQWNjZXNzb3IpLCDVkNWPXzgyKTtcbiAgICB2YXIgT2JqZWN0R2V0dGVyID0gKNWQ1Y9fODMgPSBmdW5jdGlvbiBPYmplY3RHZXR0ZXIoKSB7XG4gICAgICAgIEFjY2Vzc29yLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzgzLCBBY2Nlc3NvciksINWQ1Y9fODMpO1xuICAgIHZhciBTeW1ib2wgPSAo1ZDVj184NCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj184NCwgTm9kZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fODQucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIltzdHJpbmddIG5hbWUgb2YgdGhpcyBzeW1ib2xcIixcbiAgICAgICAgICAgICAgICBzY29wZTogXCJbU2NvcGUvU10gdGhlIGN1cnJlbnQgc2NvcGUgKG5vdCBuZWNlc3NhcmlseSB0aGUgZGVmaW5pdGlvbiBzY29wZSlcIixcbiAgICAgICAgICAgICAgICB0aGVkZWY6IFwiW1N5bWJvbERlZi9TXSB0aGUgZGVmaW5pdGlvbiBvZiB0aGlzIHN5bWJvbFwiXG4gICAgICAgICAgICB9ICAgICAgICB9XG4gICAgfSksINWQ1Y9fODQpO1xuICAgIHZhciBTeW1ib2xBbGlhcyA9ICjVkNWPXzg1ID0gZnVuY3Rpb24gU3ltYm9sQWxpYXMoKSB7XG4gICAgICAgIFN5bWJvbC5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj184NSwgU3ltYm9sKSwg1ZDVj184NSk7XG4gICAgdmFyIFN5bWJvbEFjY2Vzc29yID0gKNWQ1Y9fODYgPSBmdW5jdGlvbiBTeW1ib2xBY2Nlc3NvcigpIHtcbiAgICAgICAgU3ltYm9sLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzg2LCBTeW1ib2wpLCDVkNWPXzg2KTtcbiAgICB2YXIgU3ltYm9sRGVjbGFyYXRpb24gPSAo1ZDVj184NyA9IGZ1bmN0aW9uIFN5bWJvbERlY2xhcmF0aW9uKCkge1xuICAgICAgICBTeW1ib2wucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fODcsIFN5bWJvbCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fODcucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBpbml0OiBcIltOb2RlKi9TXSBhcnJheSBvZiBpbml0aWFsaXplcnMgZm9yIHRoaXMgZGVjbGFyYXRpb24uXCJcbiAgICAgICAgICAgIH0gICAgICAgIH1cbiAgICB9KSwg1ZDVj184Nyk7XG4gICAgdmFyIFN5bWJvbFZhciA9ICjVkNWPXzg4ID0gZnVuY3Rpb24gU3ltYm9sVmFyKCkge1xuICAgICAgICBTeW1ib2xEZWNsYXJhdGlvbi5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj184OCwgU3ltYm9sRGVjbGFyYXRpb24pLCDVkNWPXzg4KTtcbiAgICB2YXIgU3ltYm9sTm9ubG9jYWwgPSAo1ZDVj184OSA9IGZ1bmN0aW9uIFN5bWJvbE5vbmxvY2FsKCkge1xuICAgICAgICBTeW1ib2xEZWNsYXJhdGlvbi5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj184OSwgU3ltYm9sRGVjbGFyYXRpb24pLCDVkNWPXzg5KTtcbiAgICB2YXIgSW1wb3J0ZWRWYXIgPSAo1ZDVj185MCA9IGZ1bmN0aW9uIEltcG9ydGVkVmFyKCkge1xuICAgICAgICBTeW1ib2xWYXIucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fOTAsIFN5bWJvbFZhciksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fOTAucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBhbGlhczogXCJTeW1ib2xBbGlhcyB0aGUgYWxpYXMgZm9yIHRoaXMgaW1wb3J0ZWQgc3ltYm9sXCJcbiAgICAgICAgICAgIH0gICAgICAgIH1cbiAgICB9KSwg1ZDVj185MCk7XG4gICAgdmFyIFN5bWJvbENvbnN0ID0gKNWQ1Y9fOTEgPSBmdW5jdGlvbiBTeW1ib2xDb25zdCgpIHtcbiAgICAgICAgU3ltYm9sRGVjbGFyYXRpb24ucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fOTEsIFN5bWJvbERlY2xhcmF0aW9uKSwg1ZDVj185MSk7XG4gICAgdmFyIFN5bWJvbEZ1bmFyZyA9ICjVkNWPXzkyID0gZnVuY3Rpb24gU3ltYm9sRnVuYXJnKCkge1xuICAgICAgICBTeW1ib2xWYXIucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fOTIsIFN5bWJvbFZhciksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fOTIucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uOiBcIltBbm5vdGF0aW9uP10gYW5ub3RhdGlvbiBwcm92aWRlZCBmb3IgdGhpcyBhcmd1bWVudCwgaWYgYW55XCJcbiAgICAgICAgICAgIH0gICAgICAgIH1cbiAgICB9KSwg1ZDVj185Mik7XG4gICAgdmFyIFN5bWJvbERlZnVuID0gKNWQ1Y9fOTMgPSBmdW5jdGlvbiBTeW1ib2xEZWZ1bigpIHtcbiAgICAgICAgU3ltYm9sRGVjbGFyYXRpb24ucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fOTMsIFN5bWJvbERlY2xhcmF0aW9uKSwg1ZDVj185Myk7XG4gICAgdmFyIFN5bWJvbExhbWJkYSA9ICjVkNWPXzk0ID0gZnVuY3Rpb24gU3ltYm9sTGFtYmRhKCkge1xuICAgICAgICBTeW1ib2xEZWNsYXJhdGlvbi5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj185NCwgU3ltYm9sRGVjbGFyYXRpb24pLCDVkNWPXzk0KTtcbiAgICB2YXIgU3ltYm9sQ2F0Y2ggPSAo1ZDVj185NSA9IGZ1bmN0aW9uIFN5bWJvbENhdGNoKCkge1xuICAgICAgICBTeW1ib2xEZWNsYXJhdGlvbi5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj185NSwgU3ltYm9sRGVjbGFyYXRpb24pLCDVkNWPXzk1KTtcbiAgICB2YXIgTGFiZWwgPSAo1ZDVj185NiA9IGZ1bmN0aW9uIExhYmVsKCkge1xuICAgICAgICBTeW1ib2wucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fOTYsIFN5bWJvbCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fOTYucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBcIltMYWJlbFJlZipdIGEgbGlzdCBvZiBub2RlcyByZWZlcnJpbmcgdG8gdGhpcyBsYWJlbFwiXG4gICAgICAgICAgICB9ICAgICAgICB9XG4gICAgfSksINWQ1Y9fOTYpO1xuICAgIHZhciBTeW1ib2xSZWYgPSAo1ZDVj185NyA9IGZ1bmN0aW9uIFN5bWJvbFJlZigpIHtcbiAgICAgICAgU3ltYm9sLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzk3LCBTeW1ib2wpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzk3LnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgcGFyZW5zOiBcIltib29sZWFuL1NdIGlmIHRydWUsIHRoaXMgdmFyaWFibGUgaXMgd3JhcHBlZCBpbiBwYXJlbnRoZXNlc1wiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICByZXNvbHZlVHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogbWVtb2l6ZWQoZnVuY3Rpb24gcmVzb2x2ZVR5cGUoaGVhcCl7XG4gICAgICAgICAgICAgICAgdmFyINWQ1Y9pdHIzMiwg1ZDVj2lkeDMyO1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGU7XG4gICAgICAgICAgICAgICAg1ZDVj2l0cjMyID0g1ZDVj19JdGVyYWJsZShyZXZlcnNlZChoZWFwKSk7XG4gICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4MzIgPSAwOyDVkNWPaWR4MzIgPCDVkNWPaXRyMzIubGVuZ3RoOyDVkNWPaWR4MzIrKykge1xuICAgICAgICAgICAgICAgICAgICBzY29wZSA9INWQ1Y9pdHIzMlvVkNWPaWR4MzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAo1ZDVj19pbihzZWxmLm5hbWUsIHNjb3BlLnZhcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUudmFyc1tzZWxmLm5hbWVdW3Njb3BlLnZhcnNbc2VsZi5uYW1lXS5sZW5ndGgtMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLmFyZ3MgJiYg1ZDVj19pbihzZWxmLm5hbWUsIHNjb3BlLmFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuYXJnc1tzZWxmLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBcIj9cIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj185Nyk7XG4gICAgdmFyIFN5bWJvbENsYXNzUmVmID0gKNWQ1Y9fOTggPSBmdW5jdGlvbiBTeW1ib2xDbGFzc1JlZigpIHtcbiAgICAgICAgU3ltYm9sLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzk4LCBTeW1ib2wpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzk4LnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiW1N5bWJvbERlY2xhcmF0aW9uP10gdGhlIG5hbWUgb2YgdGhpcyBjbGFzc1wiXG4gICAgICAgICAgICB9ICAgICAgICB9XG4gICAgfSksINWQ1Y9fOTgpO1xuICAgIHZhciBMYWJlbFJlZiA9ICjVkNWPXzk5ID0gZnVuY3Rpb24gTGFiZWxSZWYoKSB7XG4gICAgICAgIFN5bWJvbC5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj185OSwgU3ltYm9sKSwg1ZDVj185OSk7XG4gICAgdmFyIFRoaXMgPSAo1ZDVj18xMDAgPSBmdW5jdGlvbiBUaGlzKCkge1xuICAgICAgICBTeW1ib2wucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTAwLCBTeW1ib2wpLCDVkNWPXzEwMCk7XG4gICAgdmFyIENvbnN0YW50ID0gKNWQ1Y9fMTAxID0gZnVuY3Rpb24gQ29uc3RhbnQoKSB7XG4gICAgICAgIE5vZGUucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTAxLCBOb2RlKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj18xMDEucHJvdG90eXBlLCB7XG4gICAgICAgIGdldFZhbHVlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzEwMSk7XG4gICAgdmFyIFN0cmluZyA9ICjVkNWPXzEwMiA9IGZ1bmN0aW9uIFN0cmluZygpIHtcbiAgICAgICAgQ29uc3RhbnQucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTAyLCBDb25zdGFudCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMTAyLnByb3RvdHlwZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiW3N0cmluZ10gdGhlIGNvbnRlbnRzIG9mIHRoaXMgc3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IFwiW3N0cmluZ10gc3RyaW5nIHR5cGUgbW9kaWZpZXJcIlxuICAgICAgICAgICAgfSAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlN0cmluZ1wiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzEwMik7XG4gICAgdmFyIFZlcmJhdGltID0gKNWQ1Y9fMTAzID0gZnVuY3Rpb24gVmVyYmF0aW0oKSB7XG4gICAgICAgIENvbnN0YW50LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzEwMywgQ29uc3RhbnQpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzEwMy5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIltzdHJpbmddIEEgc3RyaW5nIG9mIHJhdyBKUyBjb2RlXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIHJlc29sdmVUeXBlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBtZW1vaXplZChmdW5jdGlvbiByZXNvbHZlVHlwZSgpe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI/XCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fMTAzKTtcbiAgICB2YXIgTnVtYmVyID0gKNWQ1Y9fMTA0ID0gZnVuY3Rpb24gTnVtYmVyKCkge1xuICAgICAgICBDb25zdGFudC5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj18xMDQsIENvbnN0YW50KSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj18xMDQucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJbbnVtYmVyXSB0aGUgbnVtZXJpYyB2YWx1ZVwiXG4gICAgICAgICAgICB9ICAgICAgICB9LFxuICAgICAgICByZXNvbHZlVHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogbWVtb2l6ZWQoZnVuY3Rpb24gcmVzb2x2ZVR5cGUoKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTnVtYmVyXCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fMTA0KTtcbiAgICB2YXIgSWRlbnRpZmllciA9ICjVkNWPXzEwNSA9IGZ1bmN0aW9uIElkZW50aWZpZXIoKSB7XG4gICAgICAgIENvbnN0YW50LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzEwNSwgQ29uc3RhbnQpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzEwNS5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIltzdHJpbmddIHRoZSBuYW1lIG9mIHRoaXMga2V5XCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIHJlc29sdmVUeXBlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBtZW1vaXplZChmdW5jdGlvbiByZXNvbHZlVHlwZSgpe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJTdHJpbmdcIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18xMDUpO1xuICAgIHZhciBSZWdFeHAgPSAo1ZDVj18xMDYgPSBmdW5jdGlvbiBSZWdFeHAoKSB7XG4gICAgICAgIENvbnN0YW50LnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzEwNiwgQ29uc3RhbnQpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzEwNi5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIltSZWdFeHBdIHRoZSBhY3R1YWwgcmVnZXhwXCJcbiAgICAgICAgICAgIH0gICAgICAgIH0sXG4gICAgICAgIHJlc29sdmVUeXBlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBtZW1vaXplZChmdW5jdGlvbiByZXNvbHZlVHlwZSgpe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSZWdFeHBcIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18xMDYpO1xuICAgIHZhciBBdG9tID0gKNWQ1Y9fMTA3ID0gZnVuY3Rpb24gQXRvbSgpIHtcbiAgICAgICAgQ29uc3RhbnQucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTA3LCBDb25zdGFudCksINWQ1Y9fMTA3KTtcbiAgICB2YXIgTnVsbCA9ICjVkNWPXzEwOCA9IGZ1bmN0aW9uIE51bGwoKSB7XG4gICAgICAgIEF0b20ucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTA4LCBBdG9tKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj18xMDgucHJvdG90eXBlLCB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBudWxsICAgICAgICB9LFxuICAgICAgICByZXNvbHZlVHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogbWVtb2l6ZWQoZnVuY3Rpb24gcmVzb2x2ZVR5cGUoKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fMTA4KTtcbiAgICB2YXIgTm90QU51bWJlciA9ICjVkNWPXzEwOSA9IGZ1bmN0aW9uIE5vdEFOdW1iZXIoKSB7XG4gICAgICAgIEF0b20ucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTA5LCBBdG9tKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj18xMDkucHJvdG90eXBlLCB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiAwIC8gMCAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzEwOSk7XG4gICAgdmFyIFVuZGVmaW5lZCA9ICjVkNWPXzExMCA9IGZ1bmN0aW9uIFVuZGVmaW5lZCgpIHtcbiAgICAgICAgQXRvbS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj18xMTAsIEF0b20pLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzExMC5wcm90b3R5cGUsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMCAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pLCDVkNWPXzExMCk7XG4gICAgdmFyIEhvbGUgPSAo1ZDVj18xMTEgPSBmdW5jdGlvbiBIb2xlKCkge1xuICAgICAgICBBdG9tLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzExMSwgQXRvbSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMTExLnByb3RvdHlwZSwge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwICAgICAgICB9LFxuICAgICAgICByZXNvbHZlVHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogbWVtb2l6ZWQoZnVuY3Rpb24gcmVzb2x2ZVR5cGUoKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fMTExKTtcbiAgICB2YXIgSW5maW5pdHkgPSAo1ZDVj18xMTIgPSBmdW5jdGlvbiBJbmZpbml0eSgpIHtcbiAgICAgICAgQXRvbS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCDVkNWPX2V4dGVuZHMo1ZDVj18xMTIsIEF0b20pLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzExMi5wcm90b3R5cGUsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IDEgLyAwICAgICAgICB9LFxuICAgICAgICByZXNvbHZlVHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogbWVtb2l6ZWQoZnVuY3Rpb24gcmVzb2x2ZVR5cGUoKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTnVtYmVyXCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fMTEyKTtcbiAgICB2YXIgQm9vbGVhbiA9ICjVkNWPXzExMyA9IGZ1bmN0aW9uIEJvb2xlYW4oKSB7XG4gICAgICAgIEF0b20ucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwg1ZDVj19leHRlbmRzKNWQ1Y9fMTEzLCBBdG9tKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj18xMTMucHJvdG90eXBlLCB7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJbYm9vbGVhbl0gdmFsdWVcIlxuICAgICAgICAgICAgfSAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVR5cGU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IG1lbW9pemVkKGZ1bmN0aW9uIHJlc29sdmVUeXBlKCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkJvb2xlYW5cIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSwg1ZDVj18xMTMpO1xuICAgIHZhciBUcmVlV2Fsa2VyID0gKNWQ1Y9fMTE0ID0gZnVuY3Rpb24gVHJlZVdhbGtlcigpIHtcbiAgICAgICAgVHJlZVdhbGtlci5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzExNC5wcm90b3R5cGUsIHtcbiAgICAgICAgX19pbml0X186IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9faW5pdF9fKGNhbGxiYWNrKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2VsZi52aXNpdCA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHNlbGYuc3RhY2sgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3Zpc2l0OiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmlzaXQobm9kZSwgZGVzY2VuZCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgc2VsZi5zdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldCA9IHNlbGYudmlzaXQobm9kZSwgZGVzY2VuZCA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kLmNhbGwobm9kZSk7XG4gICAgICAgICAgICAgICAgfSA6IG5vb3ApO1xuICAgICAgICAgICAgICAgIGlmICghcmV0ICYmIGRlc2NlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZC5jYWxsKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyZW50KG4pe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zdGFja1tzZWxmLnN0YWNrLmxlbmd0aCAtIDIgLSAobiB8fCAwKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHB1c2g6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2gobm9kZSl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNlbGYuc3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcG9wOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwb3AoKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGY6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGYoKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3RhY2tbc2VsZi5zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmluZF9wYXJlbnQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRfcGFyZW50KHR5cGUpe1xuICAgICAgICAgICAgICAgIHZhciDVkNWPaXRyMzMsINWQ1Y9pZHgzMztcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrLCBpLCB4O1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc2VsZi5zdGFjaztcbiAgICAgICAgICAgICAgICDVkNWPaXRyMzMgPSDVkNWPX0l0ZXJhYmxlKHJhbmdlKHN0YWNrLmxlbmd0aCAtIDEsIC0xLCAtMSkpO1xuICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDMzID0gMDsg1ZDVj2lkeDMzIDwg1ZDVj2l0cjMzLmxlbmd0aDsg1ZDVj2lkeDMzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9INWQ1Y9pdHIzM1vVkNWPaWR4MzNdO1xuICAgICAgICAgICAgICAgICAgICB4ID0gc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluX2Jvb2xlYW5fY29udGV4dDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5fYm9vbGVhbl9jb250ZXh0KCl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBzdGFjaywgaSwgc2VsZiwgcDtcbiAgICAgICAgICAgICAgICBzdGFjayA9IHNlbGYuc3RhY2s7XG4gICAgICAgICAgICAgICAgaSA9IHN0YWNrLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzZWxmID0gc3RhY2tbLS1pXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHN0YWNrWy0taV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgSWYgJiYgcC5jb25kaXRpb24gPT09IHNlbGYgfHwgcCBpbnN0YW5jZW9mIENvbmRpdGlvbmFsICYmIHAuY29uZGl0aW9uID09PSBzZWxmIHx8IHAgaW5zdGFuY2VvZiBEV0xvb3AgJiYgcC5jb25kaXRpb24gPT09IHNlbGYgfHwgcCBpbnN0YW5jZW9mIFVuYXJ5UHJlZml4ICYmIHAub3BlcmF0b3IgPT09IFwiIVwiICYmIHAuZXhwcmVzc2lvbiA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIEJpbmFyeSAmJiAocC5vcGVyYXRvciA9PT0gXCImJlwiIHx8IHAub3BlcmF0b3IgPT09IFwifHxcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb29wY29udHJvbF90YXJnZXQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvb3Bjb250cm9sX3RhcmdldChsYWJlbCl7XG4gICAgICAgICAgICAgICAgdmFyINWQ1Y9pdHIzNCwg1ZDVj2lkeDM0LCDVkNWPaXRyMzUsINWQ1Y9pZHgzNTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrLCBpLCB4O1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc2VsZi5zdGFjaztcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjM0ID0g1ZDVj19JdGVyYWJsZShyYW5nZShzdGFjay5sZW5ndGggLSAxLCAtMSwgLTEpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4MzQgPSAwOyDVkNWPaWR4MzQgPCDVkNWPaXRyMzQubGVuZ3RoOyDVkNWPaWR4MzQrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9INWQ1Y9pdHIzNFvVkNWPaWR4MzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBMYWJlbGVkU3RhdGVtZW50ICYmIHgubGFiZWwubmFtZSA9PT0gbGFiZWwubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4LmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICDVkNWPaXRyMzUgPSDVkNWPX0l0ZXJhYmxlKHJhbmdlKHN0YWNrLmxlbmd0aCAtIDEsIC0xLCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHgzNSA9IDA7INWQ1Y9pZHgzNSA8INWQ1Y9pdHIzNS5sZW5ndGg7INWQ1Y9pZHgzNSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0g1ZDVj2l0cjM1W9WQ1Y9pZHgzNV07XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIFN3aXRjaCB8fCB4IGluc3RhbmNlb2YgRm9ySW4gfHwgeCBpbnN0YW5jZW9mIERXTG9vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksINWQ1Y9fMTE0KTtcbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJtZW1vaXplZFwiXSA9IG1lbW9pemVkO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiQVNUXCJdID0gQVNUO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiVG9rZW5cIl0gPSBUb2tlbjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIk5vZGVcIl0gPSBOb2RlO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU3RhdGVtZW50XCJdID0gU3RhdGVtZW50O1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiRGVidWdnZXJcIl0gPSBEZWJ1Z2dlcjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkRpcmVjdGl2ZVwiXSA9IERpcmVjdGl2ZTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIlNpbXBsZVN0YXRlbWVudFwiXSA9IFNpbXBsZVN0YXRlbWVudDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIndhbGtfYm9keVwiXSA9IHdhbGtfYm9keTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkJsb2NrXCJdID0gQmxvY2s7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJCbG9ja1N0YXRlbWVudFwiXSA9IEJsb2NrU3RhdGVtZW50O1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiRW1wdHlTdGF0ZW1lbnRcIl0gPSBFbXB0eVN0YXRlbWVudDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIlN0YXRlbWVudFdpdGhCb2R5XCJdID0gU3RhdGVtZW50V2l0aEJvZHk7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJMYWJlbGVkU3RhdGVtZW50XCJdID0gTGFiZWxlZFN0YXRlbWVudDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkRXTG9vcFwiXSA9IERXTG9vcDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkRvXCJdID0gRG87XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJXaGlsZVwiXSA9IFdoaWxlO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiRm9ySW5cIl0gPSBGb3JJbjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkZvckpTXCJdID0gRm9ySlM7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJMaXN0Q29tcHJlaGVuc2lvblwiXSA9IExpc3RDb21wcmVoZW5zaW9uO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiRGljdENvbXByZWhlbnNpb25cIl0gPSBEaWN0Q29tcHJlaGVuc2lvbjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIldpdGhcIl0gPSBXaXRoO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU2NvcGVcIl0gPSBTY29wZTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIlRvcExldmVsXCJdID0gVG9wTGV2ZWw7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJTcGxhdFwiXSA9IFNwbGF0O1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiSW1wb3J0XCJdID0gSW1wb3J0O1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiSW1wb3J0c1wiXSA9IEltcG9ydHM7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJEZWNvcmF0b3JcIl0gPSBEZWNvcmF0b3I7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJBbm5vdGF0aW9uXCJdID0gQW5ub3RhdGlvbjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkxhbWJkYVwiXSA9IExhbWJkYTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkFjY2Vzc29yXCJdID0gQWNjZXNzb3I7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJGdW5jdGlvblwiXSA9IEZ1bmN0aW9uO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiQ2xhc3NcIl0gPSBDbGFzcztcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIk1vZHVsZVwiXSA9IE1vZHVsZTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIk1ldGhvZFwiXSA9IE1ldGhvZDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkNvbnN0cnVjdG9yXCJdID0gQ29uc3RydWN0b3I7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJKdW1wXCJdID0gSnVtcDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkV4aXRcIl0gPSBFeGl0O1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiUmV0dXJuXCJdID0gUmV0dXJuO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiWWllbGRcIl0gPSBZaWVsZDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIlRocm93XCJdID0gVGhyb3c7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJMb29wQ29udHJvbFwiXSA9IExvb3BDb250cm9sO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiQnJlYWtcIl0gPSBCcmVhaztcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkNvbnRpbnVlXCJdID0gQ29udGludWU7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJJZlwiXSA9IElmO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU3dpdGNoXCJdID0gU3dpdGNoO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU3dpdGNoQnJhbmNoXCJdID0gU3dpdGNoQnJhbmNoO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiRGVmYXVsdFwiXSA9IERlZmF1bHQ7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJDYXNlXCJdID0gQ2FzZTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIlRyeVwiXSA9IFRyeTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkNhdGNoXCJdID0gQ2F0Y2g7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJFeGNlcHRcIl0gPSBFeGNlcHQ7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJGaW5hbGx5XCJdID0gRmluYWxseTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkRlZmluaXRpb25zXCJdID0gRGVmaW5pdGlvbnM7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJWYXJcIl0gPSBWYXI7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJDb25zdFwiXSA9IENvbnN0O1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiVmFyRGVmXCJdID0gVmFyRGVmO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiQmFzZUNhbGxcIl0gPSBCYXNlQ2FsbDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkNhbGxcIl0gPSBDYWxsO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiQ2xhc3NDYWxsXCJdID0gQ2xhc3NDYWxsO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiTmV3XCJdID0gTmV3O1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU2VxXCJdID0gU2VxO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiUHJvcEFjY2Vzc1wiXSA9IFByb3BBY2Nlc3M7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJEb3RcIl0gPSBEb3Q7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJTdWJcIl0gPSBTdWI7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJTbGljZVwiXSA9IFNsaWNlO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiVW5hcnlcIl0gPSBVbmFyeTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIlVuYXJ5UHJlZml4XCJdID0gVW5hcnlQcmVmaXg7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJVbmFyeVBvc3RmaXhcIl0gPSBVbmFyeVBvc3RmaXg7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJCaW5hcnlcIl0gPSBCaW5hcnk7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJSYW5nZVwiXSA9IFJhbmdlO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiRGVlcEVxdWFsaXR5XCJdID0gRGVlcEVxdWFsaXR5O1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiQ29uZGl0aW9uYWxcIl0gPSBDb25kaXRpb25hbDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkFzc2lnblwiXSA9IEFzc2lnbjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkFycmF5XCJdID0gQXJyYXk7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJUdXBsZVVucGFja1wiXSA9IFR1cGxlVW5wYWNrO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiT2JqZWN0TGl0ZXJhbFwiXSA9IE9iamVjdExpdGVyYWw7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJPYmplY3RQcm9wZXJ0eVwiXSA9IE9iamVjdFByb3BlcnR5O1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiT2JqZWN0S2V5VmFsXCJdID0gT2JqZWN0S2V5VmFsO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiT2JqZWN0U2V0dGVyXCJdID0gT2JqZWN0U2V0dGVyO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiT2JqZWN0R2V0dGVyXCJdID0gT2JqZWN0R2V0dGVyO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU3ltYm9sXCJdID0gU3ltYm9sO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU3ltYm9sQWxpYXNcIl0gPSBTeW1ib2xBbGlhcztcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIlN5bWJvbEFjY2Vzc29yXCJdID0gU3ltYm9sQWNjZXNzb3I7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJTeW1ib2xEZWNsYXJhdGlvblwiXSA9IFN5bWJvbERlY2xhcmF0aW9uO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU3ltYm9sVmFyXCJdID0gU3ltYm9sVmFyO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU3ltYm9sTm9ubG9jYWxcIl0gPSBTeW1ib2xOb25sb2NhbDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkltcG9ydGVkVmFyXCJdID0gSW1wb3J0ZWRWYXI7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJTeW1ib2xDb25zdFwiXSA9IFN5bWJvbENvbnN0O1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU3ltYm9sRnVuYXJnXCJdID0gU3ltYm9sRnVuYXJnO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU3ltYm9sRGVmdW5cIl0gPSBTeW1ib2xEZWZ1bjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIlN5bWJvbExhbWJkYVwiXSA9IFN5bWJvbExhbWJkYTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIlN5bWJvbENhdGNoXCJdID0gU3ltYm9sQ2F0Y2g7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJMYWJlbFwiXSA9IExhYmVsO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU3ltYm9sUmVmXCJdID0gU3ltYm9sUmVmO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiU3ltYm9sQ2xhc3NSZWZcIl0gPSBTeW1ib2xDbGFzc1JlZjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkxhYmVsUmVmXCJdID0gTGFiZWxSZWY7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJUaGlzXCJdID0gVGhpcztcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkNvbnN0YW50XCJdID0gQ29uc3RhbnQ7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJTdHJpbmdcIl0gPSBTdHJpbmc7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJWZXJiYXRpbVwiXSA9IFZlcmJhdGltO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiTnVtYmVyXCJdID0gTnVtYmVyO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiSWRlbnRpZmllclwiXSA9IElkZW50aWZpZXI7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJSZWdFeHBcIl0gPSBSZWdFeHA7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJBdG9tXCJdID0gQXRvbTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIk51bGxcIl0gPSBOdWxsO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wiYXN0XCJdW1wiTm90QU51bWJlclwiXSA9IE5vdEFOdW1iZXI7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJVbmRlZmluZWRcIl0gPSBVbmRlZmluZWQ7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJIb2xlXCJdID0gSG9sZTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIkluZmluaXR5XCJdID0gSW5maW5pdHk7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJhc3RcIl1bXCJCb29sZWFuXCJdID0gQm9vbGVhbjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcImFzdFwiXVtcIlRyZWVXYWxrZXJcIl0gPSBUcmVlV2Fsa2VyO1xufSkoKTtcblxuKGZ1bmN0aW9uKCl7XG4gICAgdmFyIF9fbmFtZV9fID0gXCJ0b2tlbml6ZXJcIjtcbiAgICB2YXIgRVM2X0tFWVdPUkRTLCBLRVlXT1JEUywgSlNfS0VZV09SRFMsIEtFWVdPUkRTX0FUT00sIFJFU0VSVkVEX1dPUkRTLCBLRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTiwgQUxMX0tFWVdPUkRTLCBPUEVSQVRPUl9DSEFSUywgUkVfSEVYX05VTUJFUiwgUkVfT0NUX05VTUJFUiwgUkVfREVDX05VTUJFUiwgT1BFUkFUT1JTLCBPUF9NQVAsIFdISVRFU1BBQ0VfQ0hBUlMsIFBVTkNfQkVGT1JFX0VYUFJFU1NJT04sIFBVTkNfQ0hBUlMsIFJFR0VYUF9NT0RJRklFUlMsIFVOSUNPREUsIElERU5USUZJRVJfUEFULCBTVFJJTkdfTU9ESUZJRVJTLCBVTkFSWV9QT1NURklYLCBQUkVDRURFTkNFLCBFWF9FT0Y7XG4gICAgdmFyIG1ha2VQcmVkaWNhdGUgPSDVkNWPX21vZHVsZXNbXCJ1dGlsc1wiXS5tYWtlUHJlZGljYXRlO1xuICAgIHZhciBQYXJzZUVycm9yID0g1ZDVj19tb2R1bGVzW1widXRpbHNcIl0uUGFyc2VFcnJvcjtcbiAgICBcbiAgICB2YXIgYXN0ID0g1ZDVj19tb2R1bGVzW1wiYXN0XCJdO1xuICAgIFxuICAgIGZ1bmN0aW9uIGNoYXJhY3RlcnMoc3RyXykge1xuICAgICAgICByZXR1cm4gc3RyXy5zcGxpdChcIlwiKTtcbiAgICB9XG4gICAgRVM2X0tFWVdPUkRTID0gXCJhc3luYyBhd2FpdCB5aWVsZFwiO1xuICAgIEtFWVdPUkRTID0gXCJhcyBicmVhayBjYXNlIGNsYXNzIGNvbnN0IGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZGVmIGRlbCBkbyBlbGlmIGVsc2UgZXhjZXB0IFwiICsgXCJmaW5hbGx5IGZvciBmcm9tIGlmIGltcG9ydCBpbiBpcyBuZXcgbm9ubG9jYWwgcGFzcyByYWlzZSByZXR1cm4gc3dpdGNoIHRpbCB0byBcIiArIFwidHJ5IHZvaWQgd2hpbGUgd2l0aCBvciBhbmQgbm90IFwiICsgRVM2X0tFWVdPUkRTO1xuICAgIEpTX0tFWVdPUkRTID0gXCJ2YXIgZnVuY3Rpb24gaW5zdGFuY2VvZiB0eXBlb2YgY2F0Y2ggZGVsZXRlIHRocm93XCIuc3BsaXQoXCIgXCIpO1xuICAgIEtFWVdPUkRTX0FUT00gPSBcIkZhbHNlIE5vbmUgVHJ1ZVwiO1xuICAgIFJFU0VSVkVEX1dPUkRTID0gXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIFwiICsgXCJpbXBsZW1lbnRzIGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIFwiICsgXCJzeW5jaHJvbml6ZWQgdGhpcyB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlIFwiICsgS0VZV09SRFNfQVRPTSArIFwiIFwiICsgS0VZV09SRFM7XG4gICAgS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04gPSBcInJldHVybiBuZXcgZGVsIHJhaXNlIGVsaWYgZWxzZSBpZlwiO1xuICAgIEFMTF9LRVlXT1JEUyA9IFJFU0VSVkVEX1dPUkRTICsgXCIgXCIgKyBLRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTjtcbiAgICBLRVlXT1JEUyA9IG1ha2VQcmVkaWNhdGUoS0VZV09SRFMpO1xuICAgIEVTNl9LRVlXT1JEUyA9IG1ha2VQcmVkaWNhdGUoRVM2X0tFWVdPUkRTKTtcbiAgICBSRVNFUlZFRF9XT1JEUyA9IG1ha2VQcmVkaWNhdGUoUkVTRVJWRURfV09SRFMpO1xuICAgIEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OID0gbWFrZVByZWRpY2F0ZShLRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTik7XG4gICAgS0VZV09SRFNfQVRPTSA9IG1ha2VQcmVkaWNhdGUoS0VZV09SRFNfQVRPTSk7XG4gICAgT1BFUkFUT1JfQ0hBUlMgPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXCIrLSomJT08PiE/fH5eQFwiKSk7XG4gICAgUkVfSEVYX05VTUJFUiA9IC9eMHhbMC05YS1mXSskL2k7XG4gICAgUkVfT0NUX05VTUJFUiA9IC9eMFswLTddKyQvO1xuICAgIFJFX0RFQ19OVU1CRVIgPSAvXlxcZCpcXC4/XFxkKig/OmVbKy1dP1xcZCooPzpcXGRcXC4/fFxcLj9cXGQpXFxkKik/JC9pO1xuICAgIE9QRVJBVE9SUyA9IG1ha2VQcmVkaWNhdGUoWyBcImluXCIsIFwiaW5zdGFuY2VvZlwiLCBcInR5cGVvZlwiLCBcIm5ld1wiLCBcInZvaWRcIiwgXCJkZWxcIiwgXCIrK1wiLCBcIi0tXCIsIFwiK1wiLCBcIi1cIiwgXCJub3RcIiwgXCJ+XCIsIFwiJlwiLCBcInxcIiwgXCJeXCIsIFwiKipcIiwgXCIqXCIsIFwiL1wiLCBcIi8vXCIsIFwiJVwiLCBcIj4+XCIsIFwiPDxcIiwgXCI+Pj5cIiwgXCI8XCIsIFwiPlwiLCBcIjw9XCIsIFwiPj1cIiwgXCI9PVwiLCBcIj09PVwiLCBcImlzXCIsIFwiIT1cIiwgXCIhPT1cIiwgXCI/XCIsIFwiPVwiLCBcIis9XCIsIFwiLT1cIiwgXCIvPVwiLCBcIi8vPVwiLCBcIio9XCIsIFwiJT1cIiwgXCI+Pj1cIiwgXCI8PD1cIiwgXCI+Pj49XCIsIFwifD1cIiwgXCJePVwiLCBcIiY9XCIsIFwiYW5kXCIsIFwib3JcIiwgXCJ0aWxcIiwgXCJ0b1wiLCBcIkBcIiwgXCItPlwiIF0pO1xuICAgIE9QX01BUCA9IHtcbiAgICAgICAgXCJvclwiOiBcInx8XCIsXG4gICAgICAgIFwiYW5kXCI6IFwiJiZcIixcbiAgICAgICAgXCJub3RcIjogXCIhXCIsXG4gICAgICAgIFwiZGVsXCI6IFwiZGVsZXRlXCIsXG4gICAgICAgIFwiTm9uZVwiOiBcIm51bGxcIixcbiAgICAgICAgXCJpc1wiOiBcIj09PVwiXG4gICAgfTtcbiAgICBXSElURVNQQUNFX0NIQVJTID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFwiIMKgXFxuXFxyXFx0XFxmXHUwMDBi4oCL4aCO4oCA4oCB4oCC4oCD4oCE4oCF4oCG4oCH4oCI4oCJ4oCK4oCv4oGf44CAXCIpKTtcbiAgICBQVU5DX0JFRk9SRV9FWFBSRVNTSU9OID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFwiW3soLC47OlwiKSk7XG4gICAgUFVOQ19DSEFSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIltde30oKSw7OlwiKSk7XG4gICAgUkVHRVhQX01PRElGSUVSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcImdtc2l5XCIpKTtcbiAgICBVTklDT0RFID0ge1xuICAgICAgICBsZXR0ZXI6IG5ldyBSZWdFeHAoXCJbXFxcXHUwMDQxLVxcXFx1MDA1QVxcXFx1MDA2MS1cXFxcdTAwN0FcXFxcdTAwQUFcXFxcdTAwQjVcXFxcdTAwQkFcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyQzFcXFxcdTAyQzYtXFxcXHUwMkQxXFxcXHUwMkUwLVxcXFx1MDJFNFxcXFx1MDJFQ1xcXFx1MDJFRVxcXFx1MDM3MC1cXFxcdTAzNzRcXFxcdTAzNzZcXFxcdTAzNzdcXFxcdTAzN0EtXFxcXHUwMzdEXFxcXHUwMzg2XFxcXHUwMzg4LVxcXFx1MDM4QVxcXFx1MDM4Q1xcXFx1MDM4RS1cXFxcdTAzQTFcXFxcdTAzQTMtXFxcXHUwM0Y1XFxcXHUwM0Y3LVxcXFx1MDQ4MVxcXFx1MDQ4QS1cXFxcdTA1MjNcXFxcdTA1MzEtXFxcXHUwNTU2XFxcXHUwNTU5XFxcXHUwNTYxLVxcXFx1MDU4N1xcXFx1MDVEMC1cXFxcdTA1RUFcXFxcdTA1RjAtXFxcXHUwNUYyXFxcXHUwNjIxLVxcXFx1MDY0QVxcXFx1MDY2RVxcXFx1MDY2RlxcXFx1MDY3MS1cXFxcdTA2RDNcXFxcdTA2RDVcXFxcdTA2RTVcXFxcdTA2RTZcXFxcdTA2RUVcXFxcdTA2RUZcXFxcdTA2RkEtXFxcXHUwNkZDXFxcXHUwNkZGXFxcXHUwNzEwXFxcXHUwNzEyLVxcXFx1MDcyRlxcXFx1MDc0RC1cXFxcdTA3QTVcXFxcdTA3QjFcXFxcdTA3Q0EtXFxcXHUwN0VBXFxcXHUwN0Y0XFxcXHUwN0Y1XFxcXHUwN0ZBXFxcXHUwOTA0LVxcXFx1MDkzOVxcXFx1MDkzRFxcXFx1MDk1MFxcXFx1MDk1OC1cXFxcdTA5NjFcXFxcdTA5NzFcXFxcdTA5NzJcXFxcdTA5N0ItXFxcXHUwOTdGXFxcXHUwOTg1LVxcXFx1MDk4Q1xcXFx1MDk4RlxcXFx1MDk5MFxcXFx1MDk5My1cXFxcdTA5QThcXFxcdTA5QUEtXFxcXHUwOUIwXFxcXHUwOUIyXFxcXHUwOUI2LVxcXFx1MDlCOVxcXFx1MDlCRFxcXFx1MDlDRVxcXFx1MDlEQ1xcXFx1MDlERFxcXFx1MDlERi1cXFxcdTA5RTFcXFxcdTA5RjBcXFxcdTA5RjFcXFxcdTBBMDUtXFxcXHUwQTBBXFxcXHUwQTBGXFxcXHUwQTEwXFxcXHUwQTEzLVxcXFx1MEEyOFxcXFx1MEEyQS1cXFxcdTBBMzBcXFxcdTBBMzJcXFxcdTBBMzNcXFxcdTBBMzVcXFxcdTBBMzZcXFxcdTBBMzhcXFxcdTBBMzlcXFxcdTBBNTktXFxcXHUwQTVDXFxcXHUwQTVFXFxcXHUwQTcyLVxcXFx1MEE3NFxcXFx1MEE4NS1cXFxcdTBBOERcXFxcdTBBOEYtXFxcXHUwQTkxXFxcXHUwQTkzLVxcXFx1MEFBOFxcXFx1MEFBQS1cXFxcdTBBQjBcXFxcdTBBQjJcXFxcdTBBQjNcXFxcdTBBQjUtXFxcXHUwQUI5XFxcXHUwQUJEXFxcXHUwQUQwXFxcXHUwQUUwXFxcXHUwQUUxXFxcXHUwQjA1LVxcXFx1MEIwQ1xcXFx1MEIwRlxcXFx1MEIxMFxcXFx1MEIxMy1cXFxcdTBCMjhcXFxcdTBCMkEtXFxcXHUwQjMwXFxcXHUwQjMyXFxcXHUwQjMzXFxcXHUwQjM1LVxcXFx1MEIzOVxcXFx1MEIzRFxcXFx1MEI1Q1xcXFx1MEI1RFxcXFx1MEI1Ri1cXFxcdTBCNjFcXFxcdTBCNzFcXFxcdTBCODNcXFxcdTBCODUtXFxcXHUwQjhBXFxcXHUwQjhFLVxcXFx1MEI5MFxcXFx1MEI5Mi1cXFxcdTBCOTVcXFxcdTBCOTlcXFxcdTBCOUFcXFxcdTBCOUNcXFxcdTBCOUVcXFxcdTBCOUZcXFxcdTBCQTNcXFxcdTBCQTRcXFxcdTBCQTgtXFxcXHUwQkFBXFxcXHUwQkFFLVxcXFx1MEJCOVxcXFx1MEJEMFxcXFx1MEMwNS1cXFxcdTBDMENcXFxcdTBDMEUtXFxcXHUwQzEwXFxcXHUwQzEyLVxcXFx1MEMyOFxcXFx1MEMyQS1cXFxcdTBDMzNcXFxcdTBDMzUtXFxcXHUwQzM5XFxcXHUwQzNEXFxcXHUwQzU4XFxcXHUwQzU5XFxcXHUwQzYwXFxcXHUwQzYxXFxcXHUwQzg1LVxcXFx1MEM4Q1xcXFx1MEM4RS1cXFxcdTBDOTBcXFxcdTBDOTItXFxcXHUwQ0E4XFxcXHUwQ0FBLVxcXFx1MENCM1xcXFx1MENCNS1cXFxcdTBDQjlcXFxcdTBDQkRcXFxcdTBDREVcXFxcdTBDRTBcXFxcdTBDRTFcXFxcdTBEMDUtXFxcXHUwRDBDXFxcXHUwRDBFLVxcXFx1MEQxMFxcXFx1MEQxMi1cXFxcdTBEMjhcXFxcdTBEMkEtXFxcXHUwRDM5XFxcXHUwRDNEXFxcXHUwRDYwXFxcXHUwRDYxXFxcXHUwRDdBLVxcXFx1MEQ3RlxcXFx1MEQ4NS1cXFxcdTBEOTZcXFxcdTBEOUEtXFxcXHUwREIxXFxcXHUwREIzLVxcXFx1MERCQlxcXFx1MERCRFxcXFx1MERDMC1cXFxcdTBEQzZcXFxcdTBFMDEtXFxcXHUwRTMwXFxcXHUwRTMyXFxcXHUwRTMzXFxcXHUwRTQwLVxcXFx1MEU0NlxcXFx1MEU4MVxcXFx1MEU4MlxcXFx1MEU4NFxcXFx1MEU4N1xcXFx1MEU4OFxcXFx1MEU4QVxcXFx1MEU4RFxcXFx1MEU5NC1cXFxcdTBFOTdcXFxcdTBFOTktXFxcXHUwRTlGXFxcXHUwRUExLVxcXFx1MEVBM1xcXFx1MEVBNVxcXFx1MEVBN1xcXFx1MEVBQVxcXFx1MEVBQlxcXFx1MEVBRC1cXFxcdTBFQjBcXFxcdTBFQjJcXFxcdTBFQjNcXFxcdTBFQkRcXFxcdTBFQzAtXFxcXHUwRUM0XFxcXHUwRUM2XFxcXHUwRURDXFxcXHUwRUREXFxcXHUwRjAwXFxcXHUwRjQwLVxcXFx1MEY0N1xcXFx1MEY0OS1cXFxcdTBGNkNcXFxcdTBGODgtXFxcXHUwRjhCXFxcXHUxMDAwLVxcXFx1MTAyQVxcXFx1MTAzRlxcXFx1MTA1MC1cXFxcdTEwNTVcXFxcdTEwNUEtXFxcXHUxMDVEXFxcXHUxMDYxXFxcXHUxMDY1XFxcXHUxMDY2XFxcXHUxMDZFLVxcXFx1MTA3MFxcXFx1MTA3NS1cXFxcdTEwODFcXFxcdTEwOEVcXFxcdTEwQTAtXFxcXHUxMEM1XFxcXHUxMEQwLVxcXFx1MTBGQVxcXFx1MTBGQ1xcXFx1MTEwMC1cXFxcdTExNTlcXFxcdTExNUYtXFxcXHUxMUEyXFxcXHUxMUE4LVxcXFx1MTFGOVxcXFx1MTIwMC1cXFxcdTEyNDhcXFxcdTEyNEEtXFxcXHUxMjREXFxcXHUxMjUwLVxcXFx1MTI1NlxcXFx1MTI1OFxcXFx1MTI1QS1cXFxcdTEyNURcXFxcdTEyNjAtXFxcXHUxMjg4XFxcXHUxMjhBLVxcXFx1MTI4RFxcXFx1MTI5MC1cXFxcdTEyQjBcXFxcdTEyQjItXFxcXHUxMkI1XFxcXHUxMkI4LVxcXFx1MTJCRVxcXFx1MTJDMFxcXFx1MTJDMi1cXFxcdTEyQzVcXFxcdTEyQzgtXFxcXHUxMkQ2XFxcXHUxMkQ4LVxcXFx1MTMxMFxcXFx1MTMxMi1cXFxcdTEzMTVcXFxcdTEzMTgtXFxcXHUxMzVBXFxcXHUxMzgwLVxcXFx1MTM4RlxcXFx1MTNBMC1cXFxcdTEzRjRcXFxcdTE0MDEtXFxcXHUxNjZDXFxcXHUxNjZGLVxcXFx1MTY3NlxcXFx1MTY4MS1cXFxcdTE2OUFcXFxcdTE2QTAtXFxcXHUxNkVBXFxcXHUxNzAwLVxcXFx1MTcwQ1xcXFx1MTcwRS1cXFxcdTE3MTFcXFxcdTE3MjAtXFxcXHUxNzMxXFxcXHUxNzQwLVxcXFx1MTc1MVxcXFx1MTc2MC1cXFxcdTE3NkNcXFxcdTE3NkUtXFxcXHUxNzcwXFxcXHUxNzgwLVxcXFx1MTdCM1xcXFx1MTdEN1xcXFx1MTdEQ1xcXFx1MTgyMC1cXFxcdTE4NzdcXFxcdTE4ODAtXFxcXHUxOEE4XFxcXHUxOEFBXFxcXHUxOTAwLVxcXFx1MTkxQ1xcXFx1MTk1MC1cXFxcdTE5NkRcXFxcdTE5NzAtXFxcXHUxOTc0XFxcXHUxOTgwLVxcXFx1MTlBOVxcXFx1MTlDMS1cXFxcdTE5QzdcXFxcdTFBMDAtXFxcXHUxQTE2XFxcXHUxQjA1LVxcXFx1MUIzM1xcXFx1MUI0NS1cXFxcdTFCNEJcXFxcdTFCODMtXFxcXHUxQkEwXFxcXHUxQkFFXFxcXHUxQkFGXFxcXHUxQzAwLVxcXFx1MUMyM1xcXFx1MUM0RC1cXFxcdTFDNEZcXFxcdTFDNUEtXFxcXHUxQzdEXFxcXHUxRDAwLVxcXFx1MURCRlxcXFx1MUUwMC1cXFxcdTFGMTVcXFxcdTFGMTgtXFxcXHUxRjFEXFxcXHUxRjIwLVxcXFx1MUY0NVxcXFx1MUY0OC1cXFxcdTFGNERcXFxcdTFGNTAtXFxcXHUxRjU3XFxcXHUxRjU5XFxcXHUxRjVCXFxcXHUxRjVEXFxcXHUxRjVGLVxcXFx1MUY3RFxcXFx1MUY4MC1cXFxcdTFGQjRcXFxcdTFGQjYtXFxcXHUxRkJDXFxcXHUxRkJFXFxcXHUxRkMyLVxcXFx1MUZDNFxcXFx1MUZDNi1cXFxcdTFGQ0NcXFxcdTFGRDAtXFxcXHUxRkQzXFxcXHUxRkQ2LVxcXFx1MUZEQlxcXFx1MUZFMC1cXFxcdTFGRUNcXFxcdTFGRjItXFxcXHUxRkY0XFxcXHUxRkY2LVxcXFx1MUZGQ1xcXFx1MjA3MVxcXFx1MjA3RlxcXFx1MjA5MC1cXFxcdTIwOTRcXFxcdTIxMDJcXFxcdTIxMDdcXFxcdTIxMEEtXFxcXHUyMTEzXFxcXHUyMTE1XFxcXHUyMTE5LVxcXFx1MjExRFxcXFx1MjEyNFxcXFx1MjEyNlxcXFx1MjEyOFxcXFx1MjEyQS1cXFxcdTIxMkRcXFxcdTIxMkYtXFxcXHUyMTM5XFxcXHUyMTNDLVxcXFx1MjEzRlxcXFx1MjE0NS1cXFxcdTIxNDlcXFxcdTIxNEVcXFxcdTIxODNcXFxcdTIxODRcXFxcdTJDMDAtXFxcXHUyQzJFXFxcXHUyQzMwLVxcXFx1MkM1RVxcXFx1MkM2MC1cXFxcdTJDNkZcXFxcdTJDNzEtXFxcXHUyQzdEXFxcXHUyQzgwLVxcXFx1MkNFNFxcXFx1MkQwMC1cXFxcdTJEMjVcXFxcdTJEMzAtXFxcXHUyRDY1XFxcXHUyRDZGXFxcXHUyRDgwLVxcXFx1MkQ5NlxcXFx1MkRBMC1cXFxcdTJEQTZcXFxcdTJEQTgtXFxcXHUyREFFXFxcXHUyREIwLVxcXFx1MkRCNlxcXFx1MkRCOC1cXFxcdTJEQkVcXFxcdTJEQzAtXFxcXHUyREM2XFxcXHUyREM4LVxcXFx1MkRDRVxcXFx1MkREMC1cXFxcdTJERDZcXFxcdTJERDgtXFxcXHUyRERFXFxcXHUyRTJGXFxcXHUzMDA1XFxcXHUzMDA2XFxcXHUzMDMxLVxcXFx1MzAzNVxcXFx1MzAzQlxcXFx1MzAzQ1xcXFx1MzA0MS1cXFxcdTMwOTZcXFxcdTMwOUQtXFxcXHUzMDlGXFxcXHUzMEExLVxcXFx1MzBGQVxcXFx1MzBGQy1cXFxcdTMwRkZcXFxcdTMxMDUtXFxcXHUzMTJEXFxcXHUzMTMxLVxcXFx1MzE4RVxcXFx1MzFBMC1cXFxcdTMxQjdcXFxcdTMxRjAtXFxcXHUzMUZGXFxcXHUzNDAwXFxcXHU0REI1XFxcXHU0RTAwXFxcXHU5RkMzXFxcXHVBMDAwLVxcXFx1QTQ4Q1xcXFx1QTUwMC1cXFxcdUE2MENcXFxcdUE2MTAtXFxcXHVBNjFGXFxcXHVBNjJBXFxcXHVBNjJCXFxcXHVBNjQwLVxcXFx1QTY1RlxcXFx1QTY2Mi1cXFxcdUE2NkVcXFxcdUE2N0YtXFxcXHVBNjk3XFxcXHVBNzE3LVxcXFx1QTcxRlxcXFx1QTcyMi1cXFxcdUE3ODhcXFxcdUE3OEJcXFxcdUE3OENcXFxcdUE3RkItXFxcXHVBODAxXFxcXHVBODAzLVxcXFx1QTgwNVxcXFx1QTgwNy1cXFxcdUE4MEFcXFxcdUE4MEMtXFxcXHVBODIyXFxcXHVBODQwLVxcXFx1QTg3M1xcXFx1QTg4Mi1cXFxcdUE4QjNcXFxcdUE5MEEtXFxcXHVBOTI1XFxcXHVBOTMwLVxcXFx1QTk0NlxcXFx1QUEwMC1cXFxcdUFBMjhcXFxcdUFBNDAtXFxcXHVBQTQyXFxcXHVBQTQ0LVxcXFx1QUE0QlxcXFx1QUMwMFxcXFx1RDdBM1xcXFx1RjkwMC1cXFxcdUZBMkRcXFxcdUZBMzAtXFxcXHVGQTZBXFxcXHVGQTcwLVxcXFx1RkFEOVxcXFx1RkIwMC1cXFxcdUZCMDZcXFxcdUZCMTMtXFxcXHVGQjE3XFxcXHVGQjFEXFxcXHVGQjFGLVxcXFx1RkIyOFxcXFx1RkIyQS1cXFxcdUZCMzZcXFxcdUZCMzgtXFxcXHVGQjNDXFxcXHVGQjNFXFxcXHVGQjQwXFxcXHVGQjQxXFxcXHVGQjQzXFxcXHVGQjQ0XFxcXHVGQjQ2LVxcXFx1RkJCMVxcXFx1RkJEMy1cXFxcdUZEM0RcXFxcdUZENTAtXFxcXHVGRDhGXFxcXHVGRDkyLVxcXFx1RkRDN1xcXFx1RkRGMC1cXFxcdUZERkJcXFxcdUZFNzAtXFxcXHVGRTc0XFxcXHVGRTc2LVxcXFx1RkVGQ1xcXFx1RkYyMS1cXFxcdUZGM0FcXFxcdUZGNDEtXFxcXHVGRjVBXFxcXHVGRjY2LVxcXFx1RkZCRVxcXFx1RkZDMi1cXFxcdUZGQzdcXFxcdUZGQ0EtXFxcXHVGRkNGXFxcXHVGRkQyLVxcXFx1RkZEN1xcXFx1RkZEQS1cXFxcdUZGRENdXCIpLFxuICAgICAgICBub25fc3BhY2luZ19tYXJrOiBuZXcgUmVnRXhwKFwiW1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTA0ODMtXFxcXHUwNDg3XFxcXHUwNTkxLVxcXFx1MDVCRFxcXFx1MDVCRlxcXFx1MDVDMVxcXFx1MDVDMlxcXFx1MDVDNFxcXFx1MDVDNVxcXFx1MDVDN1xcXFx1MDYxMC1cXFxcdTA2MUFcXFxcdTA2NEItXFxcXHUwNjVFXFxcXHUwNjcwXFxcXHUwNkQ2LVxcXFx1MDZEQ1xcXFx1MDZERi1cXFxcdTA2RTRcXFxcdTA2RTdcXFxcdTA2RThcXFxcdTA2RUEtXFxcXHUwNkVEXFxcXHUwNzExXFxcXHUwNzMwLVxcXFx1MDc0QVxcXFx1MDdBNi1cXFxcdTA3QjBcXFxcdTA3RUItXFxcXHUwN0YzXFxcXHUwODE2LVxcXFx1MDgxOVxcXFx1MDgxQi1cXFxcdTA4MjNcXFxcdTA4MjUtXFxcXHUwODI3XFxcXHUwODI5LVxcXFx1MDgyRFxcXFx1MDkwMC1cXFxcdTA5MDJcXFxcdTA5M0NcXFxcdTA5NDEtXFxcXHUwOTQ4XFxcXHUwOTREXFxcXHUwOTUxLVxcXFx1MDk1NVxcXFx1MDk2MlxcXFx1MDk2M1xcXFx1MDk4MVxcXFx1MDlCQ1xcXFx1MDlDMS1cXFxcdTA5QzRcXFxcdTA5Q0RcXFxcdTA5RTJcXFxcdTA5RTNcXFxcdTBBMDFcXFxcdTBBMDJcXFxcdTBBM0NcXFxcdTBBNDFcXFxcdTBBNDJcXFxcdTBBNDdcXFxcdTBBNDhcXFxcdTBBNEItXFxcXHUwQTREXFxcXHUwQTUxXFxcXHUwQTcwXFxcXHUwQTcxXFxcXHUwQTc1XFxcXHUwQTgxXFxcXHUwQTgyXFxcXHUwQUJDXFxcXHUwQUMxLVxcXFx1MEFDNVxcXFx1MEFDN1xcXFx1MEFDOFxcXFx1MEFDRFxcXFx1MEFFMlxcXFx1MEFFM1xcXFx1MEIwMVxcXFx1MEIzQ1xcXFx1MEIzRlxcXFx1MEI0MS1cXFxcdTBCNDRcXFxcdTBCNERcXFxcdTBCNTZcXFxcdTBCNjJcXFxcdTBCNjNcXFxcdTBCODJcXFxcdTBCQzBcXFxcdTBCQ0RcXFxcdTBDM0UtXFxcXHUwQzQwXFxcXHUwQzQ2LVxcXFx1MEM0OFxcXFx1MEM0QS1cXFxcdTBDNERcXFxcdTBDNTVcXFxcdTBDNTZcXFxcdTBDNjJcXFxcdTBDNjNcXFxcdTBDQkNcXFxcdTBDQkZcXFxcdTBDQzZcXFxcdTBDQ0NcXFxcdTBDQ0RcXFxcdTBDRTJcXFxcdTBDRTNcXFxcdTBENDEtXFxcXHUwRDQ0XFxcXHUwRDREXFxcXHUwRDYyXFxcXHUwRDYzXFxcXHUwRENBXFxcXHUwREQyLVxcXFx1MERENFxcXFx1MERENlxcXFx1MEUzMVxcXFx1MEUzNC1cXFxcdTBFM0FcXFxcdTBFNDctXFxcXHUwRTRFXFxcXHUwRUIxXFxcXHUwRUI0LVxcXFx1MEVCOVxcXFx1MEVCQlxcXFx1MEVCQ1xcXFx1MEVDOC1cXFxcdTBFQ0RcXFxcdTBGMThcXFxcdTBGMTlcXFxcdTBGMzVcXFxcdTBGMzdcXFxcdTBGMzlcXFxcdTBGNzEtXFxcXHUwRjdFXFxcXHUwRjgwLVxcXFx1MEY4NFxcXFx1MEY4NlxcXFx1MEY4N1xcXFx1MEY5MC1cXFxcdTBGOTdcXFxcdTBGOTktXFxcXHUwRkJDXFxcXHUwRkM2XFxcXHUxMDJELVxcXFx1MTAzMFxcXFx1MTAzMi1cXFxcdTEwMzdcXFxcdTEwMzlcXFxcdTEwM0FcXFxcdTEwM0RcXFxcdTEwM0VcXFxcdTEwNThcXFxcdTEwNTlcXFxcdTEwNUUtXFxcXHUxMDYwXFxcXHUxMDcxLVxcXFx1MTA3NFxcXFx1MTA4MlxcXFx1MTA4NVxcXFx1MTA4NlxcXFx1MTA4RFxcXFx1MTA5RFxcXFx1MTM1RlxcXFx1MTcxMi1cXFxcdTE3MTRcXFxcdTE3MzItXFxcXHUxNzM0XFxcXHUxNzUyXFxcXHUxNzUzXFxcXHUxNzcyXFxcXHUxNzczXFxcXHUxN0I3LVxcXFx1MTdCRFxcXFx1MTdDNlxcXFx1MTdDOS1cXFxcdTE3RDNcXFxcdTE3RERcXFxcdTE4MEItXFxcXHUxODBEXFxcXHUxOEE5XFxcXHUxOTIwLVxcXFx1MTkyMlxcXFx1MTkyN1xcXFx1MTkyOFxcXFx1MTkzMlxcXFx1MTkzOS1cXFxcdTE5M0JcXFxcdTFBMTdcXFxcdTFBMThcXFxcdTFBNTZcXFxcdTFBNTgtXFxcXHUxQTVFXFxcXHUxQTYwXFxcXHUxQTYyXFxcXHUxQTY1LVxcXFx1MUE2Q1xcXFx1MUE3My1cXFxcdTFBN0NcXFxcdTFBN0ZcXFxcdTFCMDAtXFxcXHUxQjAzXFxcXHUxQjM0XFxcXHUxQjM2LVxcXFx1MUIzQVxcXFx1MUIzQ1xcXFx1MUI0MlxcXFx1MUI2Qi1cXFxcdTFCNzNcXFxcdTFCODBcXFxcdTFCODFcXFxcdTFCQTItXFxcXHUxQkE1XFxcXHUxQkE4XFxcXHUxQkE5XFxcXHUxQzJDLVxcXFx1MUMzM1xcXFx1MUMzNlxcXFx1MUMzN1xcXFx1MUNEMC1cXFxcdTFDRDJcXFxcdTFDRDQtXFxcXHUxQ0UwXFxcXHUxQ0UyLVxcXFx1MUNFOFxcXFx1MUNFRFxcXFx1MURDMC1cXFxcdTFERTZcXFxcdTFERkQtXFxcXHUxREZGXFxcXHUyMEQwLVxcXFx1MjBEQ1xcXFx1MjBFMVxcXFx1MjBFNS1cXFxcdTIwRjBcXFxcdTJDRUYtXFxcXHUyQ0YxXFxcXHUyREUwLVxcXFx1MkRGRlxcXFx1MzAyQS1cXFxcdTMwMkZcXFxcdTMwOTlcXFxcdTMwOUFcXFxcdUE2NkZcXFxcdUE2N0NcXFxcdUE2N0RcXFxcdUE2RjBcXFxcdUE2RjFcXFxcdUE4MDJcXFxcdUE4MDZcXFxcdUE4MEJcXFxcdUE4MjVcXFxcdUE4MjZcXFxcdUE4QzRcXFxcdUE4RTAtXFxcXHVBOEYxXFxcXHVBOTI2LVxcXFx1QTkyRFxcXFx1QTk0Ny1cXFxcdUE5NTFcXFxcdUE5ODAtXFxcXHVBOTgyXFxcXHVBOUIzXFxcXHVBOUI2LVxcXFx1QTlCOVxcXFx1QTlCQ1xcXFx1QUEyOS1cXFxcdUFBMkVcXFxcdUFBMzFcXFxcdUFBMzJcXFxcdUFBMzVcXFxcdUFBMzZcXFxcdUFBNDNcXFxcdUFBNENcXFxcdUFBQjBcXFxcdUFBQjItXFxcXHVBQUI0XFxcXHVBQUI3XFxcXHVBQUI4XFxcXHVBQUJFXFxcXHVBQUJGXFxcXHVBQUMxXFxcXHVBQkU1XFxcXHVBQkU4XFxcXHVBQkVEXFxcXHVGQjFFXFxcXHVGRTAwLVxcXFx1RkUwRlxcXFx1RkUyMC1cXFxcdUZFMjZdXCIpLFxuICAgICAgICBzcGFjZV9jb21iaW5pbmdfbWFyazogbmV3IFJlZ0V4cChcIltcXFxcdTA5MDNcXFxcdTA5M0UtXFxcXHUwOTQwXFxcXHUwOTQ5LVxcXFx1MDk0Q1xcXFx1MDk0RVxcXFx1MDk4MlxcXFx1MDk4M1xcXFx1MDlCRS1cXFxcdTA5QzBcXFxcdTA5QzdcXFxcdTA5QzhcXFxcdTA5Q0JcXFxcdTA5Q0NcXFxcdTA5RDdcXFxcdTBBMDNcXFxcdTBBM0UtXFxcXHUwQTQwXFxcXHUwQTgzXFxcXHUwQUJFLVxcXFx1MEFDMFxcXFx1MEFDOVxcXFx1MEFDQlxcXFx1MEFDQ1xcXFx1MEIwMlxcXFx1MEIwM1xcXFx1MEIzRVxcXFx1MEI0MFxcXFx1MEI0N1xcXFx1MEI0OFxcXFx1MEI0QlxcXFx1MEI0Q1xcXFx1MEI1N1xcXFx1MEJCRVxcXFx1MEJCRlxcXFx1MEJDMVxcXFx1MEJDMlxcXFx1MEJDNi1cXFxcdTBCQzhcXFxcdTBCQ0EtXFxcXHUwQkNDXFxcXHUwQkQ3XFxcXHUwQzAxLVxcXFx1MEMwM1xcXFx1MEM0MS1cXFxcdTBDNDRcXFxcdTBDODJcXFxcdTBDODNcXFxcdTBDQkVcXFxcdTBDQzAtXFxcXHUwQ0M0XFxcXHUwQ0M3XFxcXHUwQ0M4XFxcXHUwQ0NBXFxcXHUwQ0NCXFxcXHUwQ0Q1XFxcXHUwQ0Q2XFxcXHUwRDAyXFxcXHUwRDAzXFxcXHUwRDNFLVxcXFx1MEQ0MFxcXFx1MEQ0Ni1cXFxcdTBENDhcXFxcdTBENEEtXFxcXHUwRDRDXFxcXHUwRDU3XFxcXHUwRDgyXFxcXHUwRDgzXFxcXHUwRENGLVxcXFx1MEREMVxcXFx1MEREOC1cXFxcdTBEREZcXFxcdTBERjJcXFxcdTBERjNcXFxcdTBGM0VcXFxcdTBGM0ZcXFxcdTBGN0ZcXFxcdTEwMkJcXFxcdTEwMkNcXFxcdTEwMzFcXFxcdTEwMzhcXFxcdTEwM0JcXFxcdTEwM0NcXFxcdTEwNTZcXFxcdTEwNTdcXFxcdTEwNjItXFxcXHUxMDY0XFxcXHUxMDY3LVxcXFx1MTA2RFxcXFx1MTA4M1xcXFx1MTA4NFxcXFx1MTA4Ny1cXFxcdTEwOENcXFxcdTEwOEZcXFxcdTEwOUEtXFxcXHUxMDlDXFxcXHUxN0I2XFxcXHUxN0JFLVxcXFx1MTdDNVxcXFx1MTdDN1xcXFx1MTdDOFxcXFx1MTkyMy1cXFxcdTE5MjZcXFxcdTE5MjktXFxcXHUxOTJCXFxcXHUxOTMwXFxcXHUxOTMxXFxcXHUxOTMzLVxcXFx1MTkzOFxcXFx1MTlCMC1cXFxcdTE5QzBcXFxcdTE5QzhcXFxcdTE5QzlcXFxcdTFBMTktXFxcXHUxQTFCXFxcXHUxQTU1XFxcXHUxQTU3XFxcXHUxQTYxXFxcXHUxQTYzXFxcXHUxQTY0XFxcXHUxQTZELVxcXFx1MUE3MlxcXFx1MUIwNFxcXFx1MUIzNVxcXFx1MUIzQlxcXFx1MUIzRC1cXFxcdTFCNDFcXFxcdTFCNDNcXFxcdTFCNDRcXFxcdTFCODJcXFxcdTFCQTFcXFxcdTFCQTZcXFxcdTFCQTdcXFxcdTFCQUFcXFxcdTFDMjQtXFxcXHUxQzJCXFxcXHUxQzM0XFxcXHUxQzM1XFxcXHUxQ0UxXFxcXHUxQ0YyXFxcXHVBODIzXFxcXHVBODI0XFxcXHVBODI3XFxcXHVBODgwXFxcXHVBODgxXFxcXHVBOEI0LVxcXFx1QThDM1xcXFx1QTk1MlxcXFx1QTk1M1xcXFx1QTk4M1xcXFx1QTlCNFxcXFx1QTlCNVxcXFx1QTlCQVxcXFx1QTlCQlxcXFx1QTlCRC1cXFxcdUE5QzBcXFxcdUFBMkZcXFxcdUFBMzBcXFxcdUFBMzNcXFxcdUFBMzRcXFxcdUFBNERcXFxcdUFBN0JcXFxcdUFCRTNcXFxcdUFCRTRcXFxcdUFCRTZcXFxcdUFCRTdcXFxcdUFCRTlcXFxcdUFCRUFcXFxcdUFCRUNdXCIpLFxuICAgICAgICBjb25uZWN0b3JfcHVuY3R1YXRpb246IG5ldyBSZWdFeHAoXCJbXFxcXHUwMDVGXFxcXHUyMDNGXFxcXHUyMDQwXFxcXHUyMDU0XFxcXHVGRTMzXFxcXHVGRTM0XFxcXHVGRTRELVxcXFx1RkU0RlxcXFx1RkYzRl1cIilcbiAgICB9O1xuICAgIElERU5USUZJRVJfUEFUID0gL15bYS16XyRdW19hLXowLTkkXSokL2k7XG4gICAgU1RSSU5HX01PRElGSUVSUyA9IFwidXJmVVJGXCI7XG4gICAgVU5BUllfUE9TVEZJWCA9IG1ha2VQcmVkaWNhdGUoWyBcIi0tXCIsIFwiKytcIiBdKTtcbiAgICBQUkVDRURFTkNFID0gZnVuY3Rpb24oYSwgcmV0KSB7XG4gICAgICAgIHZhciBpLCBiLCBqO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYiA9IGFbaV07XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJldFtiW2pdXSA9IGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfShbIFsgXCJ8fFwiIF0sIFsgXCImJlwiIF0sIFsgXCJ8XCIgXSwgWyBcIl5cIiBdLCBbIFwiJlwiIF0sIFsgXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCIgXSwgWyBcIjxcIiwgXCI+XCIsIFwiPD1cIiwgXCI+PVwiLCBcImluXCIsIFwiaW5zdGFuY2VvZlwiIF0sIFsgXCI+PlwiLCBcIjw8XCIsIFwiPj4+XCIgXSwgWyBcIitcIiwgXCItXCIgXSwgWyBcIipcIiwgXCIvXCIsIFwiLy9cIiwgXCIlXCIgXSwgWyBcIioqXCIgXSBdLCB7fSk7XG4gICAgZnVuY3Rpb24gaXNfbGV0dGVyKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIgfHwgY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwIHx8IGNvZGUgPj0gMTcwICYmIFVOSUNPREUubGV0dGVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzX2RpZ2l0KGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNfYWxwaGFudW1lcmljX2NoYXIoY29kZSkge1xuICAgICAgICByZXR1cm4gaXNfZGlnaXQoY29kZSkgfHwgaXNfbGV0dGVyKGNvZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc191bmljb2RlX2NvbWJpbmluZ19tYXJrKGNoKSB7XG4gICAgICAgIHJldHVybiBVTklDT0RFLm5vbl9zcGFjaW5nX21hcmsudGVzdChjaCkgfHwgVU5JQ09ERS5zcGFjZV9jb21iaW5pbmdfbWFyay50ZXN0KGNoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNfdW5pY29kZV9jb25uZWN0b3JfcHVuY3R1YXRpb24oY2gpIHtcbiAgICAgICAgcmV0dXJuIFVOSUNPREUuY29ubmVjdG9yX3B1bmN0dWF0aW9uLnRlc3QoY2gpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc19zdHJpbmdfbW9kaWZpZXIodmFsKSB7XG4gICAgICAgIHZhciDVkNWPaXRyMzYsINWQ1Y9pZHgzNjtcbiAgICAgICAgdmFyIGNoO1xuICAgICAgICDVkNWPaXRyMzYgPSDVkNWPX0l0ZXJhYmxlKHZhbCk7XG4gICAgICAgIGZvciAo1ZDVj2lkeDM2ID0gMDsg1ZDVj2lkeDM2IDwg1ZDVj2l0cjM2Lmxlbmd0aDsg1ZDVj2lkeDM2KyspIHtcbiAgICAgICAgICAgIGNoID0g1ZDVj2l0cjM2W9WQ1Y9pZHgzNl07XG4gICAgICAgICAgICBpZiAo1ZDVj19pbihjaCwgU1RSSU5HX01PRElGSUVSUykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzX2lkZW50aWZpZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gIVJFU0VSVkVEX1dPUkRTKG5hbWUpICYmIElERU5USUZJRVJfUEFULnRlc3QobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzX2lkZW50aWZpZXJfc3RhcnQoY29kZSkge1xuICAgICAgICByZXR1cm4gY29kZSA9PT0gMzYgfHwgY29kZSA9PT0gOTUgfHwgaXNfbGV0dGVyKGNvZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc19pZGVudGlmaWVyX2NoYXIoY2gpIHtcbiAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICByZXR1cm4gaXNfaWRlbnRpZmllcl9zdGFydChjb2RlKSB8fCBpc19kaWdpdChjb2RlKSB8fCBjb2RlID09PSA4MjA0IHx8IGNvZGUgPT09IDgyMDUgfHwgaXNfdW5pY29kZV9jb21iaW5pbmdfbWFyayhjaCkgfHwgaXNfdW5pY29kZV9jb25uZWN0b3JfcHVuY3R1YXRpb24oY2gpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZV9qc19udW1iZXIobnVtKSB7XG4gICAgICAgIGlmIChSRV9IRVhfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bS5zdWJzdHIoMiksIDE2KTtcbiAgICAgICAgfSBlbHNlIGlmIChSRV9PQ1RfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bS5zdWJzdHIoMSksIDgpO1xuICAgICAgICB9IGVsc2UgaWYgKFJFX0RFQ19OVU1CRVIudGVzdChudW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChudW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzX3Rva2VuKHRva2VuLCB0eXBlLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IHR5cGUgJiYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHZvaWQgMCB8fCB0b2tlbi52YWx1ZSA9PT0gdmFsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24ganNfZXJyb3IobWVzc2FnZSwgZmlsZW5hbWUsIGxpbmUsIGNvbCwgcG9zLCBpc19lb2YpIHtcbiAgICAgICAgYXN0Lk5vZGUud2FybihcIkVSUk9SOsKge21lc3NhZ2V9wqBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwge1xuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgIGZpbGU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgIGNvbDogY29sXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihtZXNzYWdlLCBsaW5lLCBjb2wsIHBvcywgaXNfZW9mKTtcbiAgICB9XG4gICAgRVhfRU9GID0ge307XG4gICAgZnVuY3Rpb24gdG9rZW5pemVyKCRURVhULCBmaWxlbmFtZSkge1xuICAgICAgICB2YXIg1ZDVj18xMTUsINWQ1Y9fMTE2LCDVkNWPXzExNztcbiAgICAgICAgdmFyIFM7XG4gICAgICAgIFMgPSB7XG4gICAgICAgICAgICB0ZXh0OiAkVEVYVC5yZXBsYWNlKC9cXHJcXG4/fFtcXG5cXHUyMDI4XFx1MjAyOV0vZywgXCJcXG5cIikucmVwbGFjZSgvXFx1RkVGRi9nLCBcIlwiKSxcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICAgIHBvczogMCxcbiAgICAgICAgICAgIHRva3BvczogMCxcbiAgICAgICAgICAgIGxpbmU6IDEsXG4gICAgICAgICAgICB0b2tsaW5lOiAwLFxuICAgICAgICAgICAgY29sOiAwLFxuICAgICAgICAgICAgdG9rY29sOiAwLFxuICAgICAgICAgICAgbmV3bGluZV9iZWZvcmU6IGZhbHNlLFxuICAgICAgICAgICAgcmVnZXhfYWxsb3dlZDogZmFsc2UsXG4gICAgICAgICAgICBjb21tZW50c19iZWZvcmU6IFtdLFxuICAgICAgICAgICAgd2hpdGVzcGFjZV9iZWZvcmU6IFtdLFxuICAgICAgICAgICAgbmV3YmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgZW5kYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgaW5kZW50YXRpb25fbWF0dGVyczogWyB0cnVlIF0sXG4gICAgICAgICAgICBjYWNoZWRfd2hpdGVzcGFjZTogXCJcIixcbiAgICAgICAgICAgIHByZXY6IHZvaWQgMCxcbiAgICAgICAgICAgIGluZGV4X29yX3NsaWNlOiBbIGZhbHNlIF0sXG4gICAgICAgICAgICBleHBlY3Rfb2JqZWN0X2xpdGVyYWxfa2V5OiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgICAgICAgcmV0dXJuIFMudGV4dC5jaGFyQXQoUy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByZXZDaGFyKCkge1xuICAgICAgICAgICAgcmV0dXJuIFMudGV4dC5jaGFyQXQoUy50b2twb3MgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBuZXh0KHNpZ25hbF9lb2YsIGluX3N0cmluZykge1xuICAgICAgICAgICAgdmFyIGNoO1xuICAgICAgICAgICAgY2ggPSBTLnRleHQuY2hhckF0KFMucG9zKTtcbiAgICAgICAgICAgICsrUy5wb3M7XG4gICAgICAgICAgICBpZiAoc2lnbmFsX2VvZiAmJiAhY2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFWF9FT0Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gUy5uZXdsaW5lX2JlZm9yZSB8fCAhaW5fc3RyaW5nO1xuICAgICAgICAgICAgICAgICsrUy5saW5lO1xuICAgICAgICAgICAgICAgIFMuY29sID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKytTLmNvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmaW5kKHdoYXQsIHNpZ25hbF9lb2YpIHtcbiAgICAgICAgICAgIHZhciBwb3M7XG4gICAgICAgICAgICBwb3MgPSBTLnRleHQuaW5kZXhPZih3aGF0LCBTLnBvcyk7XG4gICAgICAgICAgICBpZiAoc2lnbmFsX2VvZiAmJiBwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVhfRU9GO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFydF90b2tlbigpIHtcbiAgICAgICAgICAgIFMudG9rbGluZSA9IFMubGluZTtcbiAgICAgICAgICAgIFMudG9rY29sID0gUy5jb2w7XG4gICAgICAgICAgICBTLnRva3BvcyA9IFMucG9zO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRva2VuKGZ1bGxfdHlwZSwgdmFsdWUsIGlzX2NvbW1lbnQsIGtlZXBfbmV3bGluZSkge1xuICAgICAgICAgICAgdmFyIGZ1bGxfdHlwZSwgdHlwZSwgc3VidHlwZSwgdmFsdWUsIHJldCwgaTtcbiAgICAgICAgICAgIGZ1bGxfdHlwZSA9IGZ1bGxfdHlwZS5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICB0eXBlID0gZnVsbF90eXBlWzBdO1xuICAgICAgICAgICAgc3VidHlwZSA9IGZ1bGxfdHlwZVsxXTtcbiAgICAgICAgICAgIFMucmVnZXhfYWxsb3dlZCA9IHR5cGUgPT09IFwib3BlcmF0b3JcIiAmJiAhVU5BUllfUE9TVEZJWFt2YWx1ZV0gfHwgdHlwZSA9PT0gXCJrZXl3b3JkXCIgJiYgS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04odmFsdWUpIHx8IHR5cGUgPT09IFwicHVuY1wiICYmIFBVTkNfQkVGT1JFX0VYUFJFU1NJT04odmFsdWUpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwib3BlcmF0b3JcIiAmJiB2YWx1ZSA9PT0gXCJpc1wiICYmIFMudGV4dC5zdWJzdHIoUy5wb3MpLnRyaW1MZWZ0KCkuc3Vic3RyKDAsIDQpLnRyaW1SaWdodCgpID09PSBcIm5vdFwiKSB7XG4gICAgICAgICAgICAgICAgbmV4dF90b2tlbigpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIhPT1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIm9wZXJhdG9yXCIgJiYgT1BfTUFQW3ZhbHVlXSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gT1BfTUFQW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHN1YnR5cGU6IHN1YnR5cGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGxpbmU6IFMudG9rbGluZSxcbiAgICAgICAgICAgICAgICBjb2w6IFMudG9rY29sLFxuICAgICAgICAgICAgICAgIHBvczogUy50b2twb3MsXG4gICAgICAgICAgICAgICAgZW5kcG9zOiBTLnBvcyxcbiAgICAgICAgICAgICAgICBuZXdsaW5lX2JlZm9yZTogUy5uZXdsaW5lX2JlZm9yZSxcbiAgICAgICAgICAgICAgICBmaWxlOiBmaWxlbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghaXNfY29tbWVudCkge1xuICAgICAgICAgICAgICAgIHJldC5jb21tZW50c19iZWZvcmUgPSBTLmNvbW1lbnRzX2JlZm9yZTtcbiAgICAgICAgICAgICAgICBTLmNvbW1lbnRzX2JlZm9yZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4ocmV0LmNvbW1lbnRzX2JlZm9yZSk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXQubmV3bGluZV9iZWZvcmUgPSByZXQubmV3bGluZV9iZWZvcmUgfHwgcmV0LmNvbW1lbnRzX2JlZm9yZVtpXS5uZXdsaW5lX2JlZm9yZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtlZXBfbmV3bGluZSkge1xuICAgICAgICAgICAgICAgIFMubmV3bGluZV9iZWZvcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInB1bmNcIikge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCI6XCIgJiYgIVMuaW5kZXhfb3Jfc2xpY2VbUy5pbmRleF9vcl9zbGljZS5sZW5ndGgtMV0gJiYgIVMuZXhwZWN0X29iamVjdF9saXRlcmFsX2tleSAmJiAoIVMudGV4dC5zdWJzdHJpbmcoUy5wb3MgKyAxLCBmaW5kKFwiXFxuXCIpKS50cmltKCkgfHwgIVMudGV4dC5zdWJzdHJpbmcoUy5wb3MgKyAxLCBmaW5kKFwiI1wiKSkudHJpbSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBTLm5ld2Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgUy5pbmRlbnRhdGlvbl9tYXR0ZXJzLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFMucHJldiAmJiBTLnByZXYudHlwZSA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMuaW5kZXhfb3Jfc2xpY2UucHVzaCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMuaW5kZXhfb3Jfc2xpY2UucHVzaChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgUy5pbmRlbnRhdGlvbl9tYXR0ZXJzLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IFwie1wiIHx8IHZhbHVlID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICBTLmluZGVudGF0aW9uX21hdHRlcnMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgUy5pbmRleF9vcl9zbGljZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgUy5pbmRlbnRhdGlvbl9tYXR0ZXJzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IFwifVwiIHx8IHZhbHVlID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICBTLmluZGVudGF0aW9uX21hdHRlcnMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUy5wcmV2ID0gbmV3IGFzdC5Ub2tlbihyZXQpO1xuICAgICAgICAgICAgcmV0dXJuIFMucHJldjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwYXJzZV93aGl0ZXNwYWNlKCkge1xuICAgICAgICAgICAgdmFyIGxlYWRpbmdfd2hpdGVzcGFjZSwgd2hpdGVzcGFjZV9leGlzdHMsIGNoO1xuICAgICAgICAgICAgbGVhZGluZ193aGl0ZXNwYWNlID0gXCJcIjtcbiAgICAgICAgICAgIHdoaXRlc3BhY2VfZXhpc3RzID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoV0hJVEVTUEFDRV9DSEFSUyhwZWVrKCkpKSB7XG4gICAgICAgICAgICAgICAgd2hpdGVzcGFjZV9leGlzdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoID0gbmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICBsZWFkaW5nX3doaXRlc3BhY2UgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYWRpbmdfd2hpdGVzcGFjZSArPSBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGVlaygpICE9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIGlmICghd2hpdGVzcGFjZV9leGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhZGluZ193aGl0ZXNwYWNlID0gUy5jYWNoZWRfd2hpdGVzcGFjZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBTLmNhY2hlZF93aGl0ZXNwYWNlID0gbGVhZGluZ193aGl0ZXNwYWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoUy5uZXdsaW5lX2JlZm9yZSB8fCBTLmVuZGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0X2luZGVudF90b2tlbihsZWFkaW5nX3doaXRlc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0ZXN0X2luZGVudF90b2tlbihsZWFkaW5nX3doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIHZhciBtb3N0X3JlY2VudDtcbiAgICAgICAgICAgIG1vc3RfcmVjZW50ID0gUy53aGl0ZXNwYWNlX2JlZm9yZVtTLndoaXRlc3BhY2VfYmVmb3JlLmxlbmd0aCAtIDFdIHx8IFwiXCI7XG4gICAgICAgICAgICBTLmVuZGJsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoUy5pbmRlbnRhdGlvbl9tYXR0ZXJzW1MuaW5kZW50YXRpb25fbWF0dGVycy5sZW5ndGgtMV0gJiYgbGVhZGluZ193aGl0ZXNwYWNlICE9PSBtb3N0X3JlY2VudCkge1xuICAgICAgICAgICAgICAgIGlmIChTLm5ld2Jsb2NrICYmIGxlYWRpbmdfd2hpdGVzcGFjZSAmJiBsZWFkaW5nX3doaXRlc3BhY2UuaW5kZXhPZihtb3N0X3JlY2VudCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgUy5uZXdibG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBTLndoaXRlc3BhY2VfYmVmb3JlLnB1c2gobGVhZGluZ193aGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb3N0X3JlY2VudCAmJiBtb3N0X3JlY2VudC5pbmRleE9mKGxlYWRpbmdfd2hpdGVzcGFjZSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgUy5lbmRibG9jayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIFMud2hpdGVzcGFjZV9iZWZvcmUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBUb2tlbml6ZXJFcnJvcihcIkluY29uc2lzdGVudCBpbmRlbnRhdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfd2hpbGUocHJlZCkge1xuICAgICAgICAgICAgdmFyIHJldCwgaSwgY2g7XG4gICAgICAgICAgICByZXQgPSBcIlwiO1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKGNoID0gcGVlaygpKSAmJiBwcmVkKGNoLCBpKSkge1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICByZXQgKz0gbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBUb2tlbml6ZXJFcnJvcihlcnIsIGlzX2VvZikge1xuICAgICAgICAgICAganNfZXJyb3IoZXJyLCBmaWxlbmFtZSwgUy50b2tsaW5lLCBTLnRva2NvbCwgUy50b2twb3MsIGlzX2VvZik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVhZF9udW0ocHJlZml4KSB7XG4gICAgICAgICAgICB2YXIgaGFzX2UsIGFmdGVyX2UsIGhhc194LCBoYXNfZG90LCBudW0sIHZhbGlkO1xuICAgICAgICAgICAgaGFzX2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGFmdGVyX2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGhhc194ID0gZmFsc2U7XG4gICAgICAgICAgICBoYXNfZG90ID0gcHJlZml4ID09PSBcIi5cIjtcbiAgICAgICAgICAgIG51bSA9IHJlYWRfd2hpbGUoZnVuY3Rpb24oY2gsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSwgdG1wXywgaGFzX3gsIGhhc19lLCBoYXNfZG90O1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIHRtcF8gPSBjb2RlO1xuICAgICAgICAgICAgICAgIGlmICh0bXBfID09PSAxMjAgfHwgdG1wXyA9PT0gODgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc194ID8gZmFsc2UgOiBoYXNfeCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSAxMDEgfHwgdG1wXyA9PT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc194ID8gdHJ1ZSA6IGhhc19lID8gZmFsc2UgOiBoYXNfZSA9IGFmdGVyX2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyX2UgfHwgaSA9PT0gMCAmJiAhcHJlZml4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gNDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyX2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBhZnRlcl9lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhaGFzX2RvdCAmJiAhaGFzX3ggJiYgIWhhc19lID8gaGFzX2RvdCA9IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzX2FscGhhbnVtZXJpY19jaGFyKGNvZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICAgICAgbnVtID0gcHJlZml4ICsgbnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWQgPSBwYXJzZV9qc19udW1iZXIobnVtKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4odmFsaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwibnVtXCIsIHZhbGlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgVG9rZW5pemVyRXJyb3IoXCJJbnZhbGlkIHN5bnRheDogXCIgKyBudW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfZXNjYXBlZF9jaGFyKGluX3N0cmluZywgZGlnZXN0ZXIpIHtcbiAgICAgICAgICAgIHZhciBkaWdlc3RlciwgY2gsIHRtcF87XG4gICAgICAgICAgICBkaWdlc3RlciA9IGRpZ2VzdGVyIHx8IGZ1bmN0aW9uKGluX3N0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KHRydWUsIGluX3N0cik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2ggPSBkaWdlc3Rlcihpbl9zdHJpbmcpO1xuICAgICAgICAgICAgdG1wXyA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAodG1wXyA9PT0gMTEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxuXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IDExNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcclwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSAxMTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcXHRcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gOTgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcXGJcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gMTE4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXHUwMDBiXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IDEwMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcZlwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSA0OCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcMFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSAxMjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShoZXhfYnl0ZXMoMiwgZGlnZXN0ZXIpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gMTE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaGV4X2J5dGVzKDQsIGRpZ2VzdGVyKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoZXhfYnl0ZXMobiwgZGlnZXN0ZXIpIHtcbiAgICAgICAgICAgIHZhciBudW0sIGksIGRpZ2l0O1xuICAgICAgICAgICAgbnVtID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkaWdpdCA9IHBhcnNlSW50KGRpZ2VzdGVyKCksIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZGlnaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIFRva2VuaXplckVycm9yKFwiSW52YWxpZCBoZXgtY2hhcmFjdGVyIHBhdHRlcm4gaW4gc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW0gPSBudW0gPDwgNCB8IGRpZ2l0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHJlYWRfc3RyaW5nID0gKNWQ1Y9fMTE1ID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcobW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbl90eXBlLCBxdW90ZSwgcmV0LCBpLCB0bXAsIGZpbmRfbmV3bGluZXMsIGNoO1xuICAgICAgICAgICAgdG9rZW5fdHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgICB0b2tlbl90eXBlICs9IFwiOlwiICsgbW9kaWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdW90ZSA9IG5leHQoKTtcbiAgICAgICAgICAgIHJldCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAocGVlaygpID09PSBxdW90ZSkge1xuICAgICAgICAgICAgICAgIG5leHQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBlZWsoKSA9PT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGZpbmQocXVvdGUgKyBxdW90ZSArIHF1b3RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBTLnRleHQuc3Vic3RyaW5nKFMucG9zLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMucG9zID0gaSArIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodG1wLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXBbMF0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IHJlYWRfZXNjYXBlZF9jaGFyKHRydWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSB0bXBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSB0bXAuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSB0bXBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5kX25ld2xpbmVzID0gcmV0Lm1hdGNoKC9cXG4vZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluZF9uZXdsaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFMubGluZSArPSBmaW5kX25ld2xpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbih0b2tlbl90eXBlLCByZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuKHRva2VuX3R5cGUsIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBuZXh0KHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICBUb2tlbml6ZXJFcnJvcihcIkVuZCBvZiBsaW5lIHdoaWxlIHNjYW5uaW5nIHN0cmluZyBsaXRlcmFsLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHJlYWRfZXNjYXBlZF9jaGFyKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldCArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbih0b2tlbl90eXBlLCByZXQpO1xuICAgICAgICB9LCDVkNWPXzExNSA9IHdpdGhfZW9mX2Vycm9yKFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKSjVkNWPXzExNSksINWQ1Y9fMTE1KTtcbiAgICAgICAgZnVuY3Rpb24gcmVhZF9saW5lX2NvbW1lbnQoc2hlYmFuZykge1xuICAgICAgICAgICAgc2hlYmFuZyA9IHNoZWJhbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogc2hlYmFuZztcbiAgICAgICAgICAgIHZhciBpLCByZXQ7XG4gICAgICAgICAgICBpZiAoIXNoZWJhbmcpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gZmluZChcIlxcblwiKTtcbiAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldCA9IFMudGV4dC5zdWJzdHIoUy5wb3MpO1xuICAgICAgICAgICAgICAgIFMucG9zID0gUy50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gUy50ZXh0LnN1YnN0cmluZyhTLnBvcywgaSk7XG4gICAgICAgICAgICAgICAgUy5wb3MgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRva2VuKHNoZWJhbmcgPyBcInNoZWJhbmdcIiA6IFwiY29tbWVudDpsaW5lXCIsIHJldCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciByZWFkX211bHRpbGluZV9jb21tZW50ID0gKNWQ1Y9fMTE2ID0gZnVuY3Rpb24gcmVhZF9tdWx0aWxpbmVfY29tbWVudCgpIHtcbiAgICAgICAgICAgIHZhciBpLCB0ZXh0LCBhLCBuO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgaSA9IGZpbmQoXCIqL1wiLCB0cnVlKTtcbiAgICAgICAgICAgIHRleHQgPSBTLnRleHQuc3Vic3RyaW5nKFMucG9zLCBpKTtcbiAgICAgICAgICAgIGEgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgbiA9IGEubGVuZ3RoO1xuICAgICAgICAgICAgUy5wb3MgPSBpICsgMjtcbiAgICAgICAgICAgIFMubGluZSArPSBuIC0gMTtcbiAgICAgICAgICAgIGlmIChuID4gMSkge1xuICAgICAgICAgICAgICAgIFMuY29sID0gYVtuIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBTLmNvbCArPSBhW24gLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTLmNvbCArPSAyO1xuICAgICAgICAgICAgUy5uZXdsaW5lX2JlZm9yZSA9IFMubmV3bGluZV9iZWZvcmUgfHwg1ZDVj19pbihcIlxcblwiLCB0ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbihcImNvbW1lbnQ6bXVsdGlsaW5lXCIsIHRleHQsIHRydWUpO1xuICAgICAgICB9LCDVkNWPXzExNiA9IHdpdGhfZW9mX2Vycm9yKFwiVW50ZXJtaW5hdGVkIG11bHRpbGluZSBjb21tZW50XCIpKNWQ1Y9fMTE2KSwg1ZDVj18xMTYpO1xuICAgICAgICBmdW5jdGlvbiByZWFkX25hbWUoKSB7XG4gICAgICAgICAgICB2YXIgYmFja3NsYXNoLCBuYW1lLCBlc2NhcGVkLCBjaCwgaGV4O1xuICAgICAgICAgICAgYmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICgoY2ggPSBwZWVrKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiYWNrc2xhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFMudGV4dC5jaGFyQXQoUy5wb3MgKyAxKSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFMucG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBiYWNrc2xhc2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc19pZGVudGlmaWVyX2NoYXIoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICs9IG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoICE9PSBcInVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgVG9rZW5pemVyRXJyb3IoXCJFeHBlY3RpbmcgVW5pY29kZUVzY2FwZVNlcXVlbmNlIC0tIHVYWFhYXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoID0gcmVhZF9lc2NhcGVkX2NoYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc19pZGVudGlmaWVyX2NoYXIoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbml6ZXJFcnJvcihcIlVuaWNvZGUgY2hhcjogXCIgKyBjaC5jaGFyQ29kZUF0KDApICsgXCIgaXMgbm90IHZhbGlkIGluIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmFtZSArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgYmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEtFWVdPUkRTKG5hbWUpICYmIGVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICBoZXggPSBuYW1lLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiXFxcXHVcIiArIFwiMDAwMFwiLnN1YnN0cihoZXgubGVuZ3RoKSArIGhleCArIG5hbWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHJlYWRfcmVnZXhwID0gKNWQ1Y9fMTE3ID0gZnVuY3Rpb24gcmVhZF9yZWdleHAocmVnZXhwKSB7XG4gICAgICAgICAgICB2YXIgcHJldl9iYWNrc2xhc2gsIGluX2NsYXNzLCB2ZXJib3NlX3JlZ2V4cCwgaW5fY29tbWVudCwgbW9kcywgY2gsIHJlZ2V4cDtcbiAgICAgICAgICAgIHByZXZfYmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBpbl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgdmVyYm9zZV9yZWdleHAgPSBmYWxzZTtcbiAgICAgICAgICAgIGluX2NvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChwZWVrKCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgbmV4dCh0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICB2ZXJib3NlX3JlZ2V4cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5leHQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kcyA9IHJlYWRfbmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4oXCJyZWdleHBcIiwgbmV3IFJlZ0V4cChyZWdleHAsIG1vZHMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2ggPSBuZXh0KHRydWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluX2NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbl9jb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2X2JhY2tzbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICByZWdleHAgKz0gXCJcXFxcXCIgKyBjaDtcbiAgICAgICAgICAgICAgICAgICAgcHJldl9iYWNrc2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgICBpbl9jbGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4cCArPSBjaDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIl1cIiAmJiBpbl9jbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBpbl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZWdleHAgKz0gY2g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluX2NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlX3JlZ2V4cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZWsoKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleHAgKz0gXCJcXFxcL1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgIT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwICs9IFwiXFxcXC9cXFxcL1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICBwcmV2X2JhY2tzbGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2ZXJib3NlX3JlZ2V4cCAmJiAhaW5fY2xhc3MgJiYg1ZDVj19pbihjaCwgXCIgXFxuXFxyXFx0XCIpKSB7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2ZXJib3NlX3JlZ2V4cCAmJiAhaW5fY2xhc3MgJiYgY2ggPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluX2NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4cCArPSBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RzID0gcmVhZF9uYW1lKCk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4oXCJyZWdleHBcIiwgbmV3IFJlZ0V4cChyZWdleHAsIG1vZHMpKTtcbiAgICAgICAgfSwg1ZDVj18xMTcgPSB3aXRoX2VvZl9lcnJvcihcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIiko1ZDVj18xMTcpLCDVkNWPXzExNyk7XG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfb3BlcmF0b3IocHJlZml4KSB7XG4gICAgICAgICAgICB2YXIgb3A7XG4gICAgICAgICAgICBmdW5jdGlvbiBncm93KG9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpZ2dlcjtcbiAgICAgICAgICAgICAgICBpZiAoIXBlZWsoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpZ2dlciA9IG9wICsgcGVlaygpO1xuICAgICAgICAgICAgICAgIGlmIChPUEVSQVRPUlMoYmlnZ2VyKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBncm93KGJpZ2dlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gZ3JvdyhwcmVmaXggfHwgbmV4dCgpKTtcbiAgICAgICAgICAgIGlmICjVkNWPX2luKG9wLCBbIFwiKytcIiwgXCItLVwiLCBcIj09PVwiLCBcIiE9PVwiIF0pKSB7XG4gICAgICAgICAgICAgICAgVG9rZW5pemVyRXJyb3IoXCJJbnZhbGlkIG9wZXJhdG9yIMKrXCIgKyBvcCArIFwiwrtcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wID09PSBcIi0+XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4oXCJwdW5jXCIsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbihcIm9wZXJhdG9yXCIsIG9wKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVfc2xhc2goKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gUy5yZWdleF9hbGxvd2VkID8gcmVhZF9yZWdleHAoXCJcIikgOiByZWFkX29wZXJhdG9yKFwiL1wiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVfZG90KCkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGlzX2RpZ2l0KHBlZWsoKS5jaGFyQ29kZUF0KDApKSA/IHJlYWRfbnVtKFwiLlwiKSA6IHRva2VuKFwicHVuY1wiLCBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVhZF93b3JkKCkge1xuICAgICAgICAgICAgdmFyIHdvcmQ7XG4gICAgICAgICAgICB3b3JkID0gcmVhZF9uYW1lKCk7XG4gICAgICAgICAgICByZXR1cm4gS0VZV09SRFNfQVRPTSh3b3JkKSA/IHRva2VuKFwiYXRvbVwiLCB3b3JkKSA6ICFLRVlXT1JEUyh3b3JkKSA/IHRva2VuKFwibmFtZVwiLCB3b3JkKSA6IE9QRVJBVE9SUyh3b3JkKSAmJiBwcmV2Q2hhcigpICE9PSBcIi5cIiA/IHRva2VuKFwib3BlcmF0b3JcIiwgd29yZCkgOiB0b2tlbihcImtleXdvcmRcIiwgd29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd2l0aF9lb2ZfZXJyb3IoZW9mX2Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udCh4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAo1ZDVj19FeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleCA9INWQ1Y9fRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4ID09PSBFWF9FT0YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUb2tlbml6ZXJFcnJvcihlb2ZfZXJyb3IsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyDVkNWPX0V4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5leHRfdG9rZW4oZm9yY2VfcmVnZXhwKSB7XG4gICAgICAgICAgICB2YXIgaW5kZW50LCBjaCwgY29kZSwgdG1wXywgcmVnZXhfYWxsb3dlZCwgdG9rLCBtb2RzLCBzdHJpbmdfdG9rO1xuICAgICAgICAgICAgaWYgKCEo1ZDVj19pbihmb3JjZV9yZWdleHAsIFtudWxsLCB2b2lkIDBdKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZF9yZWdleHAoZm9yY2VfcmVnZXhwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGVudCA9IHBhcnNlX3doaXRlc3BhY2UoKTtcbiAgICAgICAgICAgIGlmIChpbmRlbnQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwicHVuY1wiLCBcIn1cIiwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRfdG9rZW4oKTtcbiAgICAgICAgICAgIGNoID0gcGVlaygpO1xuICAgICAgICAgICAgaWYgKCFjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbihcImVvZlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgdG1wXyA9IGNvZGU7XG4gICAgICAgICAgICBpZiAodG1wXyA9PT0gMzQgfHwgdG1wXyA9PT0gMzkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZF9zdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gMzUpIHtcbiAgICAgICAgICAgICAgICBpZiAoUy5wb3MgPT09IDAgJiYgUy50ZXh0LmNoYXJBdCgxKSA9PT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRfbGluZV9jb21tZW50KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWdleF9hbGxvd2VkID0gUy5yZWdleF9hbGxvd2VkO1xuICAgICAgICAgICAgICAgIFMuY29tbWVudHNfYmVmb3JlLnB1c2gocmVhZF9saW5lX2NvbW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgUy5yZWdleF9hbGxvd2VkID0gcmVnZXhfYWxsb3dlZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dF90b2tlbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSA0Nikge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVfZG90KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IDQ3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZV9zbGFzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzX2RpZ2l0KGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRfbnVtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUFVOQ19DSEFSUyhjaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4oXCJwdW5jXCIsIG5leHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoT1BFUkFUT1JfQ0hBUlMoY2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRfb3BlcmF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlID09PSA5MiAmJiBTLnRleHQuY2hhckF0KFMucG9zICsgMSkgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIFMubmV3bGluZV9iZWZvcmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dF90b2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDkyIHx8IGlzX2lkZW50aWZpZXJfc3RhcnQoY29kZSkpIHtcbiAgICAgICAgICAgICAgICB0b2sgPSByZWFkX3dvcmQoKTtcbiAgICAgICAgICAgICAgICBpZiAo1ZDVj19pbihwZWVrKCksIFwiJ1xcXCJcIikgJiYgaXNfc3RyaW5nX21vZGlmaWVyKHRvay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kcyA9IHRvay52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdfdG9rID0gcmVhZF9zdHJpbmcobW9kcyk7XG4gICAgICAgICAgICAgICAgICAgIHRvay5lbmRwb3MgPSBzdHJpbmdfdG9rLmVuZHBvcztcbiAgICAgICAgICAgICAgICAgICAgdG9rLnZhbHVlID0gc3RyaW5nX3Rvay52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdG9rLnN1YnR5cGUgPSBzdHJpbmdfdG9rLnN1YnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHRvay50eXBlID0gc3RyaW5nX3Rvay50eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVG9rZW5pemVyRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlciDCq1wiICsgY2ggKyBcIsK7XCIpO1xuICAgICAgICB9XG4gICAgICAgIG5leHRfdG9rZW4uY29udGV4dCA9IGZ1bmN0aW9uKG5jKSB7XG4gICAgICAgICAgICBpZiAobmMpIHtcbiAgICAgICAgICAgICAgICBTID0gbmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5leHRfdG9rZW47XG4gICAgfVxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcIkVTNl9LRVlXT1JEU1wiXSA9IEVTNl9LRVlXT1JEUztcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcIktFWVdPUkRTXCJdID0gS0VZV09SRFM7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl1bXCJKU19LRVlXT1JEU1wiXSA9IEpTX0tFWVdPUkRTO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widG9rZW5pemVyXCJdW1wiS0VZV09SRFNfQVRPTVwiXSA9IEtFWVdPUkRTX0FUT007XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl1bXCJSRVNFUlZFRF9XT1JEU1wiXSA9IFJFU0VSVkVEX1dPUkRTO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widG9rZW5pemVyXCJdW1wiS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT05cIl0gPSBLRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcIkFMTF9LRVlXT1JEU1wiXSA9IEFMTF9LRVlXT1JEUztcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcIk9QRVJBVE9SX0NIQVJTXCJdID0gT1BFUkFUT1JfQ0hBUlM7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl1bXCJSRV9IRVhfTlVNQkVSXCJdID0gUkVfSEVYX05VTUJFUjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcIlJFX09DVF9OVU1CRVJcIl0gPSBSRV9PQ1RfTlVNQkVSO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widG9rZW5pemVyXCJdW1wiUkVfREVDX05VTUJFUlwiXSA9IFJFX0RFQ19OVU1CRVI7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl1bXCJPUEVSQVRPUlNcIl0gPSBPUEVSQVRPUlM7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl1bXCJPUF9NQVBcIl0gPSBPUF9NQVA7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl1bXCJXSElURVNQQUNFX0NIQVJTXCJdID0gV0hJVEVTUEFDRV9DSEFSUztcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcIlBVTkNfQkVGT1JFX0VYUFJFU1NJT05cIl0gPSBQVU5DX0JFRk9SRV9FWFBSRVNTSU9OO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widG9rZW5pemVyXCJdW1wiUFVOQ19DSEFSU1wiXSA9IFBVTkNfQ0hBUlM7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl1bXCJSRUdFWFBfTU9ESUZJRVJTXCJdID0gUkVHRVhQX01PRElGSUVSUztcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcIlVOSUNPREVcIl0gPSBVTklDT0RFO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widG9rZW5pemVyXCJdW1wiSURFTlRJRklFUl9QQVRcIl0gPSBJREVOVElGSUVSX1BBVDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcIlNUUklOR19NT0RJRklFUlNcIl0gPSBTVFJJTkdfTU9ESUZJRVJTO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widG9rZW5pemVyXCJdW1wiVU5BUllfUE9TVEZJWFwiXSA9IFVOQVJZX1BPU1RGSVg7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl1bXCJQUkVDRURFTkNFXCJdID0gUFJFQ0VERU5DRTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcIkVYX0VPRlwiXSA9IEVYX0VPRjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcImNoYXJhY3RlcnNcIl0gPSBjaGFyYWN0ZXJzO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widG9rZW5pemVyXCJdW1wiaXNfbGV0dGVyXCJdID0gaXNfbGV0dGVyO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widG9rZW5pemVyXCJdW1wiaXNfZGlnaXRcIl0gPSBpc19kaWdpdDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcImlzX2FscGhhbnVtZXJpY19jaGFyXCJdID0gaXNfYWxwaGFudW1lcmljX2NoYXI7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl1bXCJpc191bmljb2RlX2NvbWJpbmluZ19tYXJrXCJdID0gaXNfdW5pY29kZV9jb21iaW5pbmdfbWFyaztcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcImlzX3VuaWNvZGVfY29ubmVjdG9yX3B1bmN0dWF0aW9uXCJdID0gaXNfdW5pY29kZV9jb25uZWN0b3JfcHVuY3R1YXRpb247XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl1bXCJpc19zdHJpbmdfbW9kaWZpZXJcIl0gPSBpc19zdHJpbmdfbW9kaWZpZXI7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl1bXCJpc19pZGVudGlmaWVyXCJdID0gaXNfaWRlbnRpZmllcjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcImlzX2lkZW50aWZpZXJfc3RhcnRcIl0gPSBpc19pZGVudGlmaWVyX3N0YXJ0O1xuXG4gICAg1ZDVj19tb2R1bGVzW1widG9rZW5pemVyXCJdW1wiaXNfaWRlbnRpZmllcl9jaGFyXCJdID0gaXNfaWRlbnRpZmllcl9jaGFyO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widG9rZW5pemVyXCJdW1wicGFyc2VfanNfbnVtYmVyXCJdID0gcGFyc2VfanNfbnVtYmVyO1xuXG4gICAg1ZDVj19tb2R1bGVzW1widG9rZW5pemVyXCJdW1wiaXNfdG9rZW5cIl0gPSBpc190b2tlbjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXVtcImpzX2Vycm9yXCJdID0ganNfZXJyb3I7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl1bXCJ0b2tlbml6ZXJcIl0gPSB0b2tlbml6ZXI7XG59KSgpO1xuXG4oZnVuY3Rpb24oKXtcbiAgICB2YXIgX19uYW1lX18gPSBcInBhcnNlclwiO1xuICAgIHZhciBOQVRJVkVfQ0xBU1NFUywgQ09NTU9OX1NUQVRJQywgQ0xBU1NfTUFQLCBrZXksIEJBU0VMSUIsIFNURExJQiwgVU5BUllfUFJFRklYLCBBU1NJR05NRU5ULCBTVEFURU1FTlRTX1dJVEhfTEFCRUxTLCBBVE9NSUNfU1RBUlRfVE9LRU47XG4gICAgdmFyIG1ha2VQcmVkaWNhdGUgPSDVkNWPX21vZHVsZXNbXCJ1dGlsc1wiXS5tYWtlUHJlZGljYXRlO1xuICAgIHZhciBkZWZhdWx0cyA9INWQ1Y9fbW9kdWxlc1tcInV0aWxzXCJdLmRlZmF1bHRzO1xuICAgIHZhciBJbXBvcnRFcnJvciA9INWQ1Y9fbW9kdWxlc1tcInV0aWxzXCJdLkltcG9ydEVycm9yO1xuICAgIHZhciBqc19lcnJvciA9INWQ1Y9fbW9kdWxlc1tcInV0aWxzXCJdLmpzX2Vycm9yO1xuICAgIHZhciBSQVBZRF9QUkVGSVggPSDVkNWPX21vZHVsZXNbXCJ1dGlsc1wiXS5SQVBZRF9QUkVGSVg7XG4gICAgXG4gICAgdmFyIGFzdCA9INWQ1Y9fbW9kdWxlc1tcImFzdFwiXTtcbiAgICBcbiAgICB2YXIgdG9rZW5pemVyID0g1ZDVj19tb2R1bGVzW1widG9rZW5pemVyXCJdO1xuICAgIFxuICAgIGZ1bmN0aW9uIGFycmF5X3RvX2hhc2goYSkge1xuICAgICAgICB2YXIgcmV0LCBpO1xuICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbihhKTsgaSsrKSB7XG4gICAgICAgICAgICByZXRbYVtpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIE5BVElWRV9DTEFTU0VTID0ge1xuICAgICAgICBcIkltYWdlXCI6IHt9LFxuICAgICAgICBcIlJlZ0V4cFwiOiB7fSxcbiAgICAgICAgXCJFcnJvclwiOiB7fSxcbiAgICAgICAgXCJPYmplY3RcIjoge1xuICAgICAgICAgICAgc3RhdGljOiBbIFwiYXNzaWduXCIsIFwiZ2V0T3duUHJvcGVydHlOYW1lc1wiLCBcImtleXNcIiwgXCJjcmVhdGVcIiwgXCJkZWZpbmVQcm9wZXJ0eVwiLCBcImRlZmluZVByb3BlcnRpZXNcIiwgXCJnZXRQcm90b3R5cGVPZlwiLCBcInNldFByb3RvdHlwZU9mXCIgXVxuICAgICAgICB9LFxuICAgICAgICBcIlN0cmluZ1wiOiB7XG4gICAgICAgICAgICBzdGF0aWM6IFsgXCJmcm9tQ2hhckNvZGVcIiBdXG4gICAgICAgIH0sXG4gICAgICAgIFwiQXJyYXlcIjoge1xuICAgICAgICAgICAgc3RhdGljOiBbIFwiaXNBcnJheVwiLCBcImZyb21cIiwgXCJvZlwiIF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJOdW1iZXJcIjoge1xuICAgICAgICAgICAgc3RhdGljOiBbIFwiaXNGaW5pdGVcIiwgXCJpc05hTlwiIF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJGdW5jdGlvblwiOiB7fSxcbiAgICAgICAgXCJEYXRlXCI6IHtcbiAgICAgICAgICAgIHN0YXRpYzogWyBcIlVUQ1wiLCBcIm5vd1wiLCBcInBhcnNlXCIgXVxuICAgICAgICB9LFxuICAgICAgICBcIkJvb2xlYW5cIjoge30sXG4gICAgICAgIFwiQXJyYXlCdWZmZXJcIjoge30sXG4gICAgICAgIFwiRGF0YVZpZXdcIjoge30sXG4gICAgICAgIFwiRmxvYXQzMkFycmF5XCI6IHt9LFxuICAgICAgICBcIkZsb2F0NjRBcnJheVwiOiB7fSxcbiAgICAgICAgXCJJbnQxNkFycmF5XCI6IHt9LFxuICAgICAgICBcIkludDMyQXJyYXlcIjoge30sXG4gICAgICAgIFwiSW50OEFycmF5XCI6IHt9LFxuICAgICAgICBcIlVpbnQxNkFycmF5XCI6IHt9LFxuICAgICAgICBcIlVpbnQzMkFycmF5XCI6IHt9LFxuICAgICAgICBcIlVpbnQ4QXJyYXlcIjoge30sXG4gICAgICAgIFwiVWludDhDbGFtcGVkQXJyYXlcIjoge30sXG4gICAgICAgIFwiTWFwXCI6IHt9LFxuICAgICAgICBcIldlYWtNYXBcIjoge30sXG4gICAgICAgIFwiU2V0XCI6IHt9LFxuICAgICAgICBcIldlYWtTZXRcIjoge30sXG4gICAgICAgIFwiQXNzZXJ0aW9uRXJyb3JcIjoge30sXG4gICAgICAgIFwiSW5kZXhFcnJvclwiOiB7fSxcbiAgICAgICAgXCJLZXlFcnJvclwiOiB7fSxcbiAgICAgICAgXCJUeXBlRXJyb3JcIjoge30sXG4gICAgICAgIFwiVmFsdWVFcnJvclwiOiB7fVxuICAgIH07XG4gICAgQ09NTU9OX1NUQVRJQyA9IFsgXCJjYWxsXCIsIFwiYXBwbHlcIiwgXCJiaW5kXCIsIFwidG9TdHJpbmdcIiBdO1xuICAgIENMQVNTX01BUCA9IHt9O1xuICAgIEJBU0VMSUIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciDVkNWPaWR4MzcsINWQ1Y9pdHIzNyA9INWQ1Y9fSXRlcmFibGUoWyBcImFic1wiLCBcImFsbFwiLCBcImFueVwiLCBcImJpblwiLCBcImJpbmRcIiwgXCJyZWJpbmRfYWxsXCIsIFwiY21wXCIsIFwiY2hyXCIsIFwiZGlyXCIsIFwiZW51bWVyYXRlXCIsIFwiZXNsaWNlXCIsIFwiZXh0ZW5kc1wiLCBcImZpbHRlclwiLCBcImhleFwiLCBcImluXCIsIFwiaXRlcmFibGVcIiwgXCJsZW5cIiwgXCJtYXBcIiwgXCJtYXhcIiwgXCJtaW5cIiwgXCJtZXJnZVwiLCBcIm1peGluXCIsIFwicHJpbnRcIiwgXCJyYW5nZVwiLCBcInJlZHVjZVwiLCBcInJldmVyc2VkXCIsIFwic29ydGVkXCIsIFwic3VtXCIsIFwidHlwZVwiLCBcInppcFwiLCBcImdldGF0dHJcIiwgXCJzZXRhdHRyXCIsIFwiaGFzYXR0clwiLCBcImVxXCIsIFwia3dhcmdzXCIsIFwiQXNzZXJ0aW9uRXJyb3JcIiwgXCJJbmRleEVycm9yXCIsIFwiS2V5RXJyb3JcIiwgXCJUeXBlRXJyb3JcIiwgXCJWYWx1ZUVycm9yXCIgXSksINWQ1Y9yZXMgPSB7fSwga2V5O1xuICAgICAgICBmb3IgKNWQ1Y9pZHgzNyA9IDA7INWQ1Y9pZHgzNyA8INWQ1Y9pdHIzNy5sZW5ndGg7INWQ1Y9pZHgzNysrKSB7XG4gICAgICAgICAgICBrZXkgPSDVkNWPaXRyMzdb1ZDVj2lkeDM3XTtcbiAgICAgICAgICAgINWQ1Y9yZXNba2V5XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuINWQ1Y9yZXM7XG4gICAgfSkoKTtcbiAgICBTVERMSUIgPSBbIFwiYWJzXCIsIFwiYmluXCIsIFwiY21wXCIsIFwiY2hyXCIsIFwiZGlyXCIsIFwiaGV4XCIsIFwibWF4XCIsIFwibWluXCIsIFwibWVyZ2VcIiwgXCJtaXhpblwiLCBcInByaW50XCIsIFwicmFuZ2VcIiwgXCJyZWR1Y2VcIiwgXCJnZXRhdHRyXCIsIFwic2V0YXR0clwiLCBcImhhc2F0dHJcIiwgXCJlcVwiLCBcImJpbmRcIiwgXCJyZWJpbmRfYWxsXCIsIFwidHlwZVwiLCBcImFsbFwiLCBcImFueVwiLCBcImVudW1lcmF0ZVwiLCBcImZpbHRlclwiLCBcImxlblwiLCBcIm1hcFwiLCBcInJldmVyc2VkXCIsIFwic3VtXCIsIFwiemlwXCIsIFwiQXNzZXJ0aW9uRXJyb3JcIiwgXCJJbmRleEVycm9yXCIsIFwiS2V5RXJyb3JcIiwgXCJUeXBlRXJyb3JcIiwgXCJWYWx1ZUVycm9yXCIgXTtcbiAgICBmdW5jdGlvbiBoYXNfc2ltcGxlX2RlY29yYXRvcihkZWNvcmF0b3JzLCBuYW1lKSB7XG4gICAgICAgIHZhciByZW1vdmUsIHM7XG4gICAgICAgIHJlbW92ZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY29yYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBkZWNvcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKHMgaW5zdGFuY2VvZiBhc3QuU3ltYm9sUmVmICYmICFzLnBhcmVucyAmJiBzLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmUucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVtb3ZlLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVjb3JhdG9ycy5zcGxpY2UocmVtb3ZlW2ldLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgVU5BUllfUFJFRklYID0gbWFrZVByZWRpY2F0ZShbIFwidHlwZW9mXCIsIFwidm9pZFwiLCBcImRlbGV0ZVwiLCBcIi0tXCIsIFwiKytcIiwgXCIhXCIsIFwiflwiLCBcIi1cIiwgXCIrXCIsIFwiKlwiLCBcIkBcIiBdKTtcbiAgICBBU1NJR05NRU5UID0gbWFrZVByZWRpY2F0ZShbIFwiPVwiLCBcIis9XCIsIFwiLT1cIiwgXCIvPVwiLCBcIi8vPVwiLCBcIio9XCIsIFwiJT1cIiwgXCI+Pj1cIiwgXCI8PD1cIiwgXCI+Pj49XCIsIFwifD1cIiwgXCJePVwiLCBcIiY9XCIgXSk7XG4gICAgU1RBVEVNRU5UU19XSVRIX0xBQkVMUyA9IGFycmF5X3RvX2hhc2goWyBcImZvclwiLCBcImRvXCIsIFwid2hpbGVcIiwgXCJzd2l0Y2hcIiBdKTtcbiAgICBBVE9NSUNfU1RBUlRfVE9LRU4gPSBhcnJheV90b19oYXNoKFsgXCJhdG9tXCIsIFwibnVtXCIsIFwic3RyaW5nXCIsIFwicmVnZXhwXCIsIFwibmFtZVwiIF0pO1xuICAgIGZ1bmN0aW9uIHBhcnNlKCRURVhULCBvcHRpb25zKSB7XG4gICAgICAgIHZhciDVkNWPaXRyMzgsINWQ1Y9pZHgzOCwg1ZDVj18xMTgsINWQ1Y9fMTE5LCDVkNWPXzEyMDtcbiAgICAgICAgdmFyIG9wdGlvbnMsIG1vZHVsZV9pZCwgaW1wb3J0X2RpcnMsIElNUE9SVEVELCBJTVBPUlRJTkcsIFMsIGNuYW1lLCBvYmo7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgICAgICBzdHJpY3Q6IGZhbHNlLFxuICAgICAgICAgICAgZmlsZW5hbWU6IG51bGwsXG4gICAgICAgICAgICBhdXRvX2JpbmQ6IGZhbHNlLFxuICAgICAgICAgICAgbW9kdWxlX2lkOiBcIl9fbWFpbl9fXCIsXG4gICAgICAgICAgICBlczY6IGZhbHNlLFxuICAgICAgICAgICAgdG9wbGV2ZWw6IG51bGwsXG4gICAgICAgICAgICBpbXBvcnRfZGlyczogW10sXG4gICAgICAgICAgICBkcm9wRGVjb3JhdG9yczogW10sXG4gICAgICAgICAgICBkcm9wSW1wb3J0czogW10sXG4gICAgICAgICAgICBkcm9wRG9jc3RyaW5nczogZmFsc2UsXG4gICAgICAgICAgICBjbGFzc2VzOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBtb2R1bGVfaWQgPSBvcHRpb25zLm1vZHVsZV9pZDtcbiAgICAgICAgaW1wb3J0X2RpcnMgPSBvcHRpb25zLmltcG9ydF9kaXJzLnNsaWNlKDApO1xuICAgICAgICBpZiAob3B0aW9ucy5saWJkaXIpIHtcbiAgICAgICAgICAgIGltcG9ydF9kaXJzLnB1c2gob3B0aW9ucy5saWJkaXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmJhc2VkaXIpIHtcbiAgICAgICAgICAgIGltcG9ydF9kaXJzLnVuc2hpZnQob3B0aW9ucy5iYXNlZGlyKTtcbiAgICAgICAgfVxuICAgICAgICBJTVBPUlRFRCA9IG9wdGlvbnMuSU1QT1JURUQgfHwge307XG4gICAgICAgIElNUE9SVElORyA9IG9wdGlvbnMuSU1QT1JUSU5HIHx8IHt9O1xuICAgICAgICBJTVBPUlRJTkdbbW9kdWxlX2lkXSA9IHRydWU7XG4gICAgICAgIFMgPSB7XG4gICAgICAgICAgICBpbnB1dDogdHlwZW9mICRURVhUID09PSBcInN0cmluZ1wiID8gdG9rZW5pemVyLnRva2VuaXplcigkVEVYVCwgb3B0aW9ucy5maWxlbmFtZSkgOiAkVEVYVCxcbiAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgICAgIHBlZWtlZDogbnVsbCxcbiAgICAgICAgICAgIGluX2RpcmVjdGl2ZXM6IHRydWUsXG4gICAgICAgICAgICBpbl9sb29wOiAwLFxuICAgICAgICAgICAgaW5fc2NvcGU6IFsge1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgdmFyczoge30sXG4gICAgICAgICAgICAgICAgbm9ubG9jYWw6IHt9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uczoge30sXG4gICAgICAgICAgICAgICAgY2xhc3Nlczoge31cbiAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgIGxhYmVsczogW10sXG4gICAgICAgICAgICBkZWNvcmF0b3JzOiBbXSxcbiAgICAgICAgICAgIGluX3NlcTogZmFsc2UsXG4gICAgICAgICAgICBpbl9kZWNvcmF0b3I6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLmNsYXNzZXMpIHtcbiAgICAgICAgICAgINWQ1Y9pdHIzOCA9INWQ1Y9fSXRlcmFibGUob3B0aW9ucy5jbGFzc2VzKTtcbiAgICAgICAgICAgIGZvciAo1ZDVj2lkeDM4ID0gMDsg1ZDVj2lkeDM4IDwg1ZDVj2l0cjM4Lmxlbmd0aDsg1ZDVj2lkeDM4KyspIHtcbiAgICAgICAgICAgICAgICBjbmFtZSA9INWQ1Y9pdHIzOFvVkNWPaWR4MzhdO1xuICAgICAgICAgICAgICAgIG9iaiA9IG9wdGlvbnMuY2xhc3Nlc1tjbmFtZV07XG4gICAgICAgICAgICAgICAgUy5pbl9zY29wZVswXS5jbGFzc2VzW2NuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzdGF0aWNcIjogb2JqLnN0YXRpYyxcbiAgICAgICAgICAgICAgICAgICAgXCJib3VuZFwiOiBvYmouYm91bmRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFMudG9rZW4gPSBuZXh0KCk7XG4gICAgICAgIGZ1bmN0aW9uIGlzXyh0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuaXplci5pc190b2tlbihTLnRva2VuLCB0eXBlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGVlaygpIHtcbiAgICAgICAgICAgIHJldHVybiBTLnBlZWtlZCB8fCAoUy5wZWVrZWQgPSBTLmlucHV0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICBTLnByZXYgPSBTLnRva2VuO1xuICAgICAgICAgICAgaWYgKFMucGVla2VkKSB7XG4gICAgICAgICAgICAgICAgUy50b2tlbiA9IFMucGVla2VkO1xuICAgICAgICAgICAgICAgIFMucGVla2VkID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgUy50b2tlbiA9IFMuaW5wdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFMuaW5fZGlyZWN0aXZlcyA9IFMuaW5fZGlyZWN0aXZlcyAmJiAoUy50b2tlbi50eXBlID09PSBcInN0cmluZ1wiIHx8IGlzXyhcInB1bmNcIiwgXCI7XCIpKTtcbiAgICAgICAgICAgIHJldHVybiBTLnRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgICAgICByZXR1cm4gUy5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyb2FrKG1zZywgbGluZSwgY29sLCBwb3MsIGlzX2VvZikge1xuICAgICAgICAgICAgdmFyIGN0eDtcbiAgICAgICAgICAgIGN0eCA9IFMuaW5wdXQuY29udGV4dCgpO1xuICAgICAgICAgICAgdG9rZW5pemVyLmpzX2Vycm9yKG1zZywgY3R4LmZpbGVuYW1lLCBsaW5lICE9PSB2b2lkIDAgPyBsaW5lIDogY3R4LnRva2xpbmUsIGNvbCAhPT0gdm9pZCAwID8gY29sIDogY3R4LnRva2NvbCwgcG9zICE9PSB2b2lkIDAgPyBwb3MgOiBjdHgudG9rcG9zLCBpc19lb2YpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRva2VuX2Vycm9yKHRva2VuLCBtc2cpIHtcbiAgICAgICAgICAgIHZhciBpc19lb2Y7XG4gICAgICAgICAgICBpc19lb2YgPSB0b2tlbi50eXBlID09PSBcImVvZlwiID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgY3JvYWsobXNnLCB0b2tlbi5saW5lLCB0b2tlbi5jb2wsIHZvaWQgMCwgaXNfZW9mKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bmV4cGVjdGVkKHRva2VuKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gUy50b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuX2Vycm9yKHRva2VuLCBcIlVuZXhwZWN0ZWQgdG9rZW46IFwiICsgdG9rZW4udHlwZSArIFwiIMKrXCIgKyB0b2tlbi52YWx1ZSArIFwiwrtcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhwZWN0X3Rva2VuKHR5cGUsIHZhbCkge1xuICAgICAgICAgICAgaWYgKGlzXyh0eXBlLCB2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuX2Vycm9yKFMudG9rZW4sIFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIFMudG9rZW4udHlwZSArIFwiIMKrXCIgKyBTLnRva2VuLnZhbHVlICsgXCLCu1wiICsgXCIsIGV4cGVjdGVkIFwiICsgdHlwZSArIFwiIMKrXCIgKyB2YWwgKyBcIsK7XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGV4cGVjdChwdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0X3Rva2VuKFwicHVuY1wiLCBwdW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5faW5zZXJ0X3NlbWljb2xvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhb3B0aW9ucy5zdHJpY3QgJiYgKFMudG9rZW4ubmV3bGluZV9iZWZvcmUgfHwgaXNfKFwiZW9mXCIpIHx8IGlzXyhcInB1bmNcIiwgXCJ9XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZW1pY29sb24oKSB7XG4gICAgICAgICAgICBpZiAoaXNfKFwicHVuY1wiLCBcIjtcIikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgUy50b2tlbi5uZXdsaW5lX2JlZm9yZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFyZW50aGVzaXNlZCgpIHtcbiAgICAgICAgICAgIHZhciBleHA7XG4gICAgICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICAgICAgZXhwID0gZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVtYmVkX3Rva2VucyhwYXJzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQsIGV4cHIsIGVuZDtcbiAgICAgICAgICAgICAgICBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlcigpO1xuICAgICAgICAgICAgICAgIGlmIChleHByID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICAgICAgZXhwci5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIGV4cHIuZW5kID0gZW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc19uZXN0ZWRfY29tcGFyaXNvbihzdG10KSB7XG4gICAgICAgICAgICB2YXIgY29tcGFyYXRvcnM7XG4gICAgICAgICAgICBjb21wYXJhdG9ycyA9IHtcbiAgICAgICAgICAgICAgICBcIjxcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIj5cIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIjw9XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCI+PVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiPT1cIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIiE9XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCI9PT1cIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIiE9PVwiOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN0bXQgaW5zdGFuY2VvZiBhc3QuQmluYXJ5ICYmINWQ1Y9faW4oc3RtdC5vcGVyYXRvciwgY29tcGFyYXRvcnMpICYmIHN0bXQubGVmdCBpbnN0YW5jZW9mIGFzdC5CaW5hcnkgJiYg1ZDVj19pbihzdG10LmxlZnQub3BlcmF0b3IsIGNvbXBhcmF0b3JzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2Nhbl9mb3JfdG9wX2xldmVsX2NhbGxhYmxlcyhib2R5KSB7XG4gICAgICAgICAgICB2YXIg1ZDVj2l0cjM5LCDVkNWPaWR4Mzk7XG4gICAgICAgICAgICB2YXIgYW5zLCBuYW1lLCBvYmosIHgsIG9wdDtcbiAgICAgICAgICAgIGFucyA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYm9keSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBib2R5W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgYXN0LkZ1bmN0aW9uIHx8IG9iaiBpbnN0YW5jZW9mIGFzdC5DbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5zLnB1c2gob2JqLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihvYmouc3RhcnQsIFwiVG9wLWxldmVsIGZ1bmN0aW9ucyBtdXN0IGhhdmUgbmFtZXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgYXN0LlNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICDVkNWPaXRyMzkgPSDVkNWPX0l0ZXJhYmxlKFsgXCJib2R5XCIsIFwiYWx0ZXJuYXRpdmVcIiBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDM5ID0gMDsg1ZDVj2lkeDM5IDwg1ZDVj2l0cjM5Lmxlbmd0aDsg1ZDVj2lkeDM5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0g1ZDVj2l0cjM5W9WQ1Y9pZHgzOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0ID0gb2JqW3hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5zID0gYW5zLmNvbmNhdChzY2FuX2Zvcl90b3BfbGV2ZWxfY2FsbGFibGVzKG9wdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0IGluc3RhbmNlb2YgYXN0LkFzc2lnbiAmJiAhKG9wdC5yaWdodCBpbnN0YW5jZW9mIGFzdC5TY29wZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5zID0gYW5zLmNvbmNhdChzY2FuX2Zvcl90b3BfbGV2ZWxfY2FsbGFibGVzKG9wdC5yaWdodCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYm9keS5ib2R5KSB7XG4gICAgICAgICAgICAgICAgYW5zID0gYW5zLmNvbmNhdChzY2FuX2Zvcl90b3BfbGV2ZWxfY2FsbGFibGVzKGJvZHkuYm9keSkpO1xuICAgICAgICAgICAgICAgIGlmIChib2R5LmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFucyA9IGFucy5jb25jYXQoc2Nhbl9mb3JfdG9wX2xldmVsX2NhbGxhYmxlcyhib2R5LmFsdGVybmF0aXZlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFucztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHN0YXRlbWVudCA9ICjVkNWPXzExOCA9IGZ1bmN0aW9uIHN0YXRlbWVudCgpIHtcbiAgICAgICAgICAgIHZhciB0bXBfLCBkaXIsIHN0YXQsIHR5cGUsIHN0YXJ0LCBmdW5jLCBjaGFpbiwgY3RvciwgcmVzdWx0LCBleHBlY3RlZFR5cGUsIGFjdHVhbFR5cGUsIHRtcDtcbiAgICAgICAgICAgIGlmIChpc18oXCJvcGVyYXRvclwiLCBcIi9cIikgfHwgaXNfKFwib3BlcmF0b3JcIiwgXCIvPVwiKSkge1xuICAgICAgICAgICAgICAgIFMucGVla2VkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBTLnRva2VuID0gUy5pbnB1dChTLnRva2VuLnZhbHVlLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcF8gPSBTLnRva2VuLnR5cGU7XG4gICAgICAgICAgICBpZiAodG1wXyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGRpciA9IFMuaW5fZGlyZWN0aXZlcztcbiAgICAgICAgICAgICAgICBzdGF0ID0gc2ltcGxlX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgJiYgc3RhdC5ib2R5IGluc3RhbmNlb2YgYXN0LlN0cmluZyAmJiAhaXNfKFwicHVuY1wiLCBcIixcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3QuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdGF0LmJvZHkudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcInNoZWJhbmdcIikge1xuICAgICAgICAgICAgICAgIHRtcF8gPSBTLnRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzdC5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG1wX1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcIm51bVwiIHx8IHRtcF8gPT09IFwicmVnZXhwXCIgfHwgdG1wXyA9PT0gXCJvcGVyYXRvclwiIHx8IHRtcF8gPT09IFwiYXRvbVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsZV9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gXCJwdW5jXCIpIHtcbiAgICAgICAgICAgICAgICB0bXBfID0gUy50b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG1wXyA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3QuQmxvY2tTdGF0ZW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFMudG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBibG9ja18oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gXCJ7XCIgfHwgdG1wXyA9PT0gXCJbXCIgfHwgdG1wXyA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsZV9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3QuRW1wdHlTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgICAgIGlmICjVkNWPX2luKFMudG9rZW4udmFsdWUsIFsgXCJzZXRcIiwgXCJnZXRcIiBdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZXM2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIkNsYXNzIGdldHRlcnMvc2V0dGVycyByZXF1aXJlIEVTNiBjb21waWxhdGlvbiBtb2RlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBTLnRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IFMudG9rZW4uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc29yXyh0eXBlLCBzdGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbml6ZXIuaXNfdG9rZW4ocGVlaygpLCBcInB1bmNcIiwgXCI6XCIpID8gbGFiZWxlZF9zdGF0ZW1lbnQoKSA6IHNpbXBsZV9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gXCJrZXl3b3JkXCIpIHtcbiAgICAgICAgICAgICAgICB0bXBfID0gUy50b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5pemVyLkVTNl9LRVlXT1JEUyh0bXBfKSAmJiAhb3B0aW9ucy5lczYpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IocHJldigpLCBcIsKrXCIgKyB0bXBfICsgXCLCuyBrZXl3b3JkIG5vdCBzdXBwb3J0ZWQgd2l0aCBFUzUgb3V0cHV0LCB1c2UgLS1lY21hc2NyaXB0NiBjb21waWxhdGlvbiBmbGFnXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRtcF8gPT09IFwiYnJlYWtcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnJlYWtfY29udChhc3QuQnJlYWspO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBicmVha19jb250KGFzdC5Db250aW51ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcImRlYnVnZ2VyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXN0LkRlYnVnZ2VyKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcImRvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3QuRG8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogaW5fbG9vcChzdGF0ZW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0X3Rva2VuKFwia2V5d29yZFwiLCBcIndoaWxlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0uY2FsbCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IFwid2hpbGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzdC5XaGlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb246IGV4cHJlc3Npb24odHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBpbl9sb29wKHN0YXRlbWVudClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcImZvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc18oXCJuYW1lXCIsIFwiSlNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JfanMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9yXygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gXCJmcm9tXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydF8odHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcImltcG9ydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRfKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgICAgICAgICArK0JBU0VMSUJbXCJleHRlbmRzXCJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hdXRvX2JpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrQkFTRUxJQltcInJlYmluZF9hbGxcIl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzXygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gXCJkZWZcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uXyhTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTFdLnR5cGUgPT09IFwiY2xhc3NcIiA/IFMuaW5fc2NvcGVbUy5pbl9zY29wZS5sZW5ndGgtMV0ubmFtZSA6IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZnVuYy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBmdW5jLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSBzdWJzY3JpcHRzKGZ1bmMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhaW4gPT09IGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3QuU2ltcGxlU3RhdGVtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcImlmXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlmXygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gXCJwYXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXN0LkVtcHR5U3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcInJldHVyblwiIHx8IHRtcF8gPT09IFwieWllbGRcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0xXS50eXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodG1wXyA9PT0gXCJ5aWVsZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTFdLmdlbmVyYXRvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdG9yID0gYXN0LllpZWxkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RvciA9IGFzdC5SZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGN0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlzXyhcInB1bmNcIiwgXCI7XCIpID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KCkgOiBjYW5faW5zZXJ0X3NlbWljb2xvbigpID8gbnVsbCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0xXS5yZXR1cm5fYW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRUeXBlID0gUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0xXS5yZXR1cm5fYW5ub3RhdGlvbi5yZXNvbHZlVHlwZShTLmluX3Njb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbFR5cGUgPSByZXN1bHQucmVzb2x2ZVR5cGUoUy5pbl9zY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISjVkNWPX2luKGFjdHVhbFR5cGUsIFsgZXhwZWN0ZWRUeXBlLCBcIj9cIiBdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIlR5cGUgYW5ub3RhdGlvbiBzdGF0ZXMgdGhhdCBmdW5jdGlvbiByZXR1cm5zIFwiICsgZXhwZWN0ZWRUeXBlICsgXCIsIGFjdHVhbCByZXR1cm5lZCB0eXBlIGlzIFwiICsgYWN0dWFsVHlwZSArIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcInN3aXRjaFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXN0LlN3aXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBwYXJlbnRoZXNpc2VkKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBpbl9sb29wKHN3aXRjaF9ib2R5XylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcInJhaXNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFMudG9rZW4ubmV3bGluZV9iZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXN0LlRocm93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IGFzdC5TeW1ib2xDYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwi1ZDVj19FeGNlcHRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0bXAgPSBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3QuVGhyb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRtcFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IFwidHJ5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeV8oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IFwibm9ubG9jYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSBub25sb2NhbF8oKTtcbiAgICAgICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcImNvbnN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gY29uc3RfKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gXCJ3aXRoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3QuV2l0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBwYXJlbnRoZXNpc2VkKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBzdGF0ZW1lbnQoKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCDVkNWPXzExOCA9IGVtYmVkX3Rva2VucyjVkNWPXzExOCksINWQ1Y9fMTE4KTtcbiAgICAgICAgZnVuY3Rpb24gbGFiZWxlZF9zdGF0ZW1lbnQoKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwsIHN0YXQ7XG4gICAgICAgICAgICBsYWJlbCA9IGFzX3N5bWJvbChhc3QuTGFiZWwpO1xuICAgICAgICAgICAgaWYgKGZpbmRfaWYoZnVuY3Rpb24obCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsLm5hbWUgPT09IGxhYmVsLm5hbWU7XG4gICAgICAgICAgICB9LCBTLmxhYmVscykpIHtcbiAgICAgICAgICAgICAgICBjcm9hayhcIkxhYmVsIFwiICsgbGFiZWwubmFtZSArIFwiIGRlZmluZWQgdHdpY2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgUy5sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgICAgICBzdGF0ID0gc3RhdGVtZW50KCk7XG4gICAgICAgICAgICBTLmxhYmVscy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0LkxhYmVsZWRTdGF0ZW1lbnQoe1xuICAgICAgICAgICAgICAgIGJvZHk6IHN0YXQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzaW1wbGVfc3RhdGVtZW50KHRtcCkge1xuICAgICAgICAgICAgdmFyIHRtcDtcbiAgICAgICAgICAgIHRtcCA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0LlNpbXBsZVN0YXRlbWVudCh7XG4gICAgICAgICAgICAgICAgYm9keTogdG1wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBicmVha19jb250KHR5cGVfKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWw7XG4gICAgICAgICAgICBsYWJlbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWNhbl9pbnNlcnRfc2VtaWNvbG9uKCkpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGFzX3N5bWJvbChhc3QuTGFiZWxSZWYsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhYmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaW5kX2lmKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwubmFtZSA9PT0gbGFiZWwubmFtZTtcbiAgICAgICAgICAgICAgICB9LCBTLmxhYmVscykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJVbmRlZmluZWQgbGFiZWwgXCIgKyBsYWJlbC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFMuaW5fbG9vcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNyb2FrKNWQ1Y9fdHlwZSh0eXBlXykgKyBcIiBub3QgaW5zaWRlIGEgbG9vcCBvciBzd2l0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHlwZV8oe1xuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2VxX3RvX2FycmF5KHNlcSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3QuQXJyYXkoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzZXEuc3RhcnQsXG4gICAgICAgICAgICAgICAgZWxlbWVudHM6IHNlcS50b19hcnJheSgpLFxuICAgICAgICAgICAgICAgIGVuZDogc2VxLmVuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9yXyhsaXN0X2NvbXApIHtcbiAgICAgICAgICAgIHZhciBpbml0O1xuICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWlzXyhcInB1bmNcIiwgXCI7XCIpKSB7XG4gICAgICAgICAgICAgICAgaW5pdCA9IGV4cHJlc3Npb24odHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGluaXQgaW5zdGFuY2VvZiBhc3QuU2VxKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBzZXFfdG9fYXJyYXkoaW5pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc18oXCJvcGVyYXRvclwiLCBcImluXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0IGluc3RhbmNlb2YgYXN0LlZhciAmJiBpbml0LmRlZmluaXRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiT25seSBvbmUgdmFyaWFibGUgZGVjbGFyYXRpb24gYWxsb3dlZCBpbiBmb3IuLmluIGxvb3BcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9yX2luKGluaXQsIGxpc3RfY29tcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvcl9pbihpbml0LCBsaXN0X2NvbXApIHtcbiAgICAgICAgICAgIHZhciDVkNWPaXRyNDAsINWQ1Y9pZHg0MCwg1ZDVj3VwazE7XG4gICAgICAgICAgICB2YXIgbGhzLCBvYmosIGksIGVsZW1lbnQsIHZhbHVlO1xuICAgICAgICAgICAgbGhzID0gaW5pdCBpbnN0YW5jZW9mIGFzdC5WYXIgPyBpbml0LmRlZmluaXRpb25zWzBdLm5hbWUgOiBudWxsO1xuICAgICAgICAgICAgb2JqID0gZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgICAgIGlmIChpbml0IGluc3RhbmNlb2YgYXN0LkFycmF5KSB7XG4gICAgICAgICAgICAgICAg1ZDVj2l0cjQwID0g1ZDVj19JdGVyYWJsZShlbnVtZXJhdGUoaW5pdC5lbGVtZW50cykpO1xuICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDQwID0gMDsg1ZDVj2lkeDQwIDwg1ZDVj2l0cjQwLmxlbmd0aDsg1ZDVj2lkeDQwKyspIHtcbiAgICAgICAgICAgICAgICAgICAg1ZDVj3VwazEgPSDVkNWPaXRyNDBb1ZDVj2lkeDQwXTtcbiAgICAgICAgICAgICAgICAgICAgaSA9INWQ1Y91cGsxWzBdO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0g1ZDVj3VwazFbMV07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIGFzdC5DYWxsICYmIG9iai5leHByZXNzaW9uIGluc3RhbmNlb2YgYXN0LlN5bWJvbFJlZiAmJiBvYmouZXhwcmVzc2lvbi5uYW1lID09PSBcImVudW1lcmF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCJOdW1iZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXJrX2xvY2FsX2Fzc2lnbm1lbnQoZWxlbWVudCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBhc3QuQ2FsbCAmJiBvYmouZXhwcmVzc2lvbiBpbnN0YW5jZW9mIGFzdC5TeW1ib2xSZWYgJiYgb2JqLmV4cHJlc3Npb24ubmFtZSA9PT0gXCJyYW5nZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCJOdW1iZXJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFya19sb2NhbF9hc3NpZ25tZW50KGluaXQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsrQkFTRUxJQltcIml0ZXJhYmxlXCJdO1xuICAgICAgICAgICAgaWYgKGxpc3RfY29tcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGxocyxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmpcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3QuRm9ySW4oe1xuICAgICAgICAgICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgICAgICAgICAgbmFtZTogbGhzLFxuICAgICAgICAgICAgICAgIG9iamVjdDogb2JqLFxuICAgICAgICAgICAgICAgIGJvZHk6IGluX2xvb3Aoc3RhdGVtZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9yX2pzKCkge1xuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbjtcbiAgICAgICAgICAgIGNvbmRpdGlvbiA9IGV4cHJlc3Npb24odHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdC5Gb3JKUyh7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiBjb25kaXRpb24sXG4gICAgICAgICAgICAgICAgYm9keTogaW5fbG9vcChzdGF0ZW1lbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRfY2xhc3NfaW5fc2NvcGUoZXhwcikge1xuICAgICAgICAgICAgdmFyINWQ1Y9pdHI0MSwg1ZDVj2lkeDQxLCDVkNWPaXRyNDIsINWQ1Y9pZHg0MjtcbiAgICAgICAgICAgIHZhciBzLCByZWZlcmVuY2VkX3BhdGgsIGV4cHIsIGNsYXNzX25hbWU7XG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIGFzdC5TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAo1ZDVj19pbihleHByLm5hbWUsIE5BVElWRV9DTEFTU0VTKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTkFUSVZFX0NMQVNTRVNbZXhwci5uYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAg1ZDVj2l0cjQxID0g1ZDVj19JdGVyYWJsZShyYW5nZShTLmluX3Njb3BlLmxlbmd0aCAtIDEsIC0xLCAtMSkpO1xuICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDQxID0gMDsg1ZDVj2lkeDQxIDwg1ZDVj2l0cjQxLmxlbmd0aDsg1ZDVj2lkeDQxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9INWQ1Y9pdHI0MVvVkNWPaWR4NDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAo1ZDVj19pbihleHByLm5hbWUsIFMuaW5fc2NvcGVbc10uY2xhc3NlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTLmluX3Njb3BlW3NdLmNsYXNzZXNbZXhwci5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIGFzdC5Eb3QpIHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VkX3BhdGggPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZXhwciBpbnN0YW5jZW9mIGFzdC5Eb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlZF9wYXRoLnVuc2hpZnQoZXhwci5wcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIGV4cHIgPSBleHByLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgYXN0LlN5bWJvbFJlZikge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VkX3BhdGgudW5zaGlmdChleHByLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuKHJlZmVyZW5jZWRfcGF0aCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc19uYW1lID0gcmVmZXJlbmNlZF9wYXRoLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjQyID0g1ZDVj19JdGVyYWJsZShyYW5nZShTLmluX3Njb3BlLmxlbmd0aCAtIDEsIC0xLCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4NDIgPSAwOyDVkNWPaWR4NDIgPCDVkNWPaXRyNDIubGVuZ3RoOyDVkNWPaWR4NDIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSDVkNWPaXRyNDJb1ZDVj2lkeDQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAo1ZDVj19pbihjbGFzc19uYW1lLCBTLmluX3Njb3BlW3NdLmNsYXNzZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTLmluX3Njb3BlW3NdLmNsYXNzZXNbY2xhc3NfbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRvX2ltcG9ydChrZXkpIHtcbiAgICAgICAgICAgIHZhciDVkNWPaXRyNDQsINWQ1Y9pZHg0NCwg1ZDVj3VwazM7XG4gICAgICAgICAgICB2YXIgcGFja2FnZV9tb2R1bGVfaWQsIGZpbGVuYW1lLCBzcmNfY29kZSwgbW9kcGF0aCwgbG9jYXRpb24sIGRhdGEsIGNvbnRlbnRzO1xuICAgICAgICAgICAgaWYgKNWQ1Y9faW4oa2V5LCBJTVBPUlRFRCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSU1QT1JUSU5HW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW1wb3J0RXJyb3IoXCJEZXRlY3RlZCBhIHJlY3Vyc2l2ZSBpbXBvcnQgb2Y6IFwiICsga2V5ICsgXCIgd2hpbGUgaW1wb3J0aW5nOiBcIiArIG1vZHVsZV9pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWNrYWdlX21vZHVsZV9pZCA9IGtleS5zcGxpdChcIi5cIikuc2xpY2UoMCwgLTEpLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgaWYgKGxlbihwYWNrYWdlX21vZHVsZV9pZCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZG9faW1wb3J0KHBhY2thZ2VfbW9kdWxlX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNhZmVfcmVhZChiYXNlX3BhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjQzLCDVkNWPaWR4NDMsINWQ1Y91cGsyO1xuICAgICAgICAgICAgICAgIHZhciBpLCBwYXRoO1xuICAgICAgICAgICAgICAgINWQ1Y9pdHI0MyA9INWQ1Y9fSXRlcmFibGUoZW51bWVyYXRlKFsgYmFzZV9wYXRoICsgXCIucHlqXCIsIGJhc2VfcGF0aCArIFwiL19faW5pdF9fLnB5alwiIF0pKTtcbiAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHg0MyA9IDA7INWQ1Y9pZHg0MyA8INWQ1Y9pdHI0My5sZW5ndGg7INWQ1Y9pZHg0MysrKSB7XG4gICAgICAgICAgICAgICAgICAgINWQ1Y91cGsyID0g1ZDVj2l0cjQzW9WQ1Y9pZHg0M107XG4gICAgICAgICAgICAgICAgICAgIGkgPSDVkNWPdXBrMlswXTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9INWQ1Y91cGsyWzFdO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgb3B0aW9ucy5yZWFkZmlsZShwYXRoLCBcInV0Zi04XCIpLCBwYXRoIF07XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKNWQ1Y9fRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9INWQ1Y9fRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXCJFTk9FTlRcIiB8fCBlLmNvZGUgPT09IFwiRVBFUk1cIiB8fCBlLmNvZGUgPT09IFwiRUFDQ0VTU1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93INWQ1Y9fRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3JjX2NvZGUgPSBmaWxlbmFtZSA9IG51bGw7XG4gICAgICAgICAgICBtb2RwYXRoID0ga2V5LnJlcGxhY2UoL1xcLi9nLCBcIi9cIik7XG4gICAgICAgICAgICDVkNWPaXRyNDQgPSDVkNWPX0l0ZXJhYmxlKGltcG9ydF9kaXJzKTtcbiAgICAgICAgICAgIGZvciAo1ZDVj2lkeDQ0ID0gMDsg1ZDVj2lkeDQ0IDwg1ZDVj2l0cjQ0Lmxlbmd0aDsg1ZDVj2lkeDQ0KyspIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9INWQ1Y9pdHI0NFvVkNWPaWR4NDRdO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICDVkNWPdXBrMyA9IHNhZmVfcmVhZChsb2NhdGlvbiArIFwiL1wiICsgbW9kcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSDVkNWPdXBrM1swXTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSDVkNWPdXBrM1sxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY19jb2RlID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNyY19jb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJGYWlsZWQgSW1wb3J0OiAnXCIgKyBrZXkgKyBcIicgbW9kdWxlIGRvZXNuJ3QgZXhpc3QgaW4gYW55IG9mIHRoZSBpbXBvcnQgZGlyZWN0b3JpZXM6IFwiICsgaW1wb3J0X2RpcnMuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGVudHMgPSBwYXJzZShzcmNfY29kZSwge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICB0b3BsZXZlbDogbnVsbCxcbiAgICAgICAgICAgICAgICByZWFkZmlsZTogb3B0aW9ucy5yZWFkZmlsZSB8fCByZXF1aXJlKFwiZnNcIikucmVhZEZpbGVTeW5jLFxuICAgICAgICAgICAgICAgIGJhc2VkaXI6IG9wdGlvbnMuYmFzZWRpcixcbiAgICAgICAgICAgICAgICBsaWJkaXI6IG9wdGlvbnMubGliZGlyLFxuICAgICAgICAgICAgICAgIG1vZHVsZV9pZDoga2V5LFxuICAgICAgICAgICAgICAgIElNUE9SVEVEOiBJTVBPUlRFRCxcbiAgICAgICAgICAgICAgICBJTVBPUlRJTkc6IElNUE9SVElORyxcbiAgICAgICAgICAgICAgICBhdXRvX2JpbmQ6IG9wdGlvbnMuYXV0b19iaW5kLFxuICAgICAgICAgICAgICAgIGVzNjogb3B0aW9ucy5lczYsXG4gICAgICAgICAgICAgICAgaW1wb3J0X2RpcnM6IG9wdGlvbnMuaW1wb3J0X2RpcnMsXG4gICAgICAgICAgICAgICAgZHJvcERlY29yYXRvcnM6IG9wdGlvbnMuZHJvcERlY29yYXRvcnMsXG4gICAgICAgICAgICAgICAgZHJvcEltcG9ydHM6IG9wdGlvbnMuZHJvcEltcG9ydHMsXG4gICAgICAgICAgICAgICAgZHJvcERvY3N0cmluZ3M6IG9wdGlvbnMuZHJvcERvY3N0cmluZ3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGxlbihwYWNrYWdlX21vZHVsZV9pZCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgSU1QT1JURURbcGFja2FnZV9tb2R1bGVfaWRdLnN1Ym1vZHVsZXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGltcG9ydF8oZnJvbV9pbXBvcnQpIHtcbiAgICAgICAgICAgIHZhciDVkNWPaXRyNDUsINWQ1Y9pZHg0NSwg1ZDVj2l0cjQ2LCDVkNWPaWR4NDY7XG4gICAgICAgICAgICB2YXIgYW5zLCBuYW1lLCB0bXAsIGtleSwgYWxpYXMsIGltcCwgY2xhc3NlcywgYXJnbmFtZXMsIGFuYW1lLCBhcmd2YXIsIG9iaiwgaTtcbiAgICAgICAgICAgIGFucyA9IG5ldyBhc3QuSW1wb3J0cyh7XG4gICAgICAgICAgICAgICAgXCJpbXBvcnRzXCI6IFtdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gbmFtZSA9IGV4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgICAgIGtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRtcCBpbnN0YW5jZW9mIGFzdC5Eb3QpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gXCIuXCIgKyB0bXAucHJvcGVydHkgKyBrZXk7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXkgPSB0bXAubmFtZSArIGtleTtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBEZWNvcmF0b3JPckltcG9ydChrZXksIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXN0LkVtcHR5U3RhdGVtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcmV2KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWxpYXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghZnJvbV9pbXBvcnQgJiYgaXNfKFwia2V5d29yZFwiLCBcImFzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYWxpYXMgPSBhc19zeW1ib2woYXN0LlN5bWJvbEFsaWFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW1wID0gbmV3IGFzdC5JbXBvcnQoe1xuICAgICAgICAgICAgICAgICAgICBcIm1vZHVsZVwiOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBcImtleVwiOiBrZXksXG4gICAgICAgICAgICAgICAgICAgIFwiYWxpYXNcIjogYWxpYXMsXG4gICAgICAgICAgICAgICAgICAgIFwiYXJnbmFtZXNcIjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgXCJib2R5XCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElNUE9SVEVEW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhbnMuaW1wb3J0cy5wdXNoKGltcCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21faW1wb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfKFwicHVuY1wiLCBcIixcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgINWQ1Y9pdHI0NSA9INWQ1Y9fSXRlcmFibGUoYW5zW1wiaW1wb3J0c1wiXSk7XG4gICAgICAgICAgICBmb3IgKNWQ1Y9pZHg0NSA9IDA7INWQ1Y9pZHg0NSA8INWQ1Y9pdHI0NS5sZW5ndGg7INWQ1Y9pZHg0NSsrKSB7XG4gICAgICAgICAgICAgICAgaW1wID0g1ZDVj2l0cjQ1W9WQ1Y9pZHg0NV07XG4gICAgICAgICAgICAgICAgZG9faW1wb3J0KGltcC5rZXkpO1xuICAgICAgICAgICAgICAgIGNsYXNzZXMgPSBJTVBPUlRFRFtrZXldLmNsYXNzZXM7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21faW1wb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdF90b2tlbihcImtleXdvcmRcIiwgXCJpbXBvcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIGltcC5hcmduYW1lcyA9IGFyZ25hbWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmFtZSA9IGFzX3N5bWJvbChhc3QuSW1wb3J0ZWRWYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzXyhcImtleXdvcmRcIiwgXCJhc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmFtZS5hbGlhcyA9IGFzX3N5bWJvbChhc3QuU3ltYm9sQWxpYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnbmFtZXMucHVzaChhbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfKFwicHVuY1wiLCBcIixcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgINWQ1Y9pdHI0NiA9INWQ1Y9fSXRlcmFibGUoYXJnbmFtZXMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHg0NiA9IDA7INWQ1Y9pZHg0NiA8INWQ1Y9pdHI0Ni5sZW5ndGg7INWQ1Y9pZHg0NisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd2YXIgPSDVkNWPaXRyNDZb1ZDVj2lkeDQ2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGNsYXNzZXNbYXJndmFyLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGFyZ3Zhci5hbGlhcyA/IGFyZ3Zhci5hbGlhcy5uYW1lIDogYXJndmFyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0xXS5jbGFzc2VzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RhdGljXCI6IG9iai5zdGF0aWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYm91bmRcIjogb2JqLmJvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSBpbiBjbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBjbGFzc2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIGFzdC5DbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGltcC5hbGlhcyA/IGltcC5hbGlhcy5uYW1lIDogaW1wLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTFdLmNsYXNzZXNba2V5ICsgXCIuXCIgKyBvYmoubmFtZS5uYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdGF0aWNcIjogb2JqLnN0YXRpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJib3VuZFwiOiBvYmouYm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFucztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbGFzc18oKSB7XG4gICAgICAgICAgICB2YXIg1ZDVj2l0cjQ5LCDVkNWPaWR4NDk7XG4gICAgICAgICAgICB2YXIgc3RhcnQsIG5hbWUsIGV4dGVybmFsZGVjb3JhdG9yLCBjbGFzc19kZXRhaWxzLCBwYXJlbnQsIGRvY3N0cmluZywgZGVmaW5pdGlvbiwgaSwgc3RtdCwgY2xhc3NfdmFyX25hbWVzLCB2aXNpdG9yO1xuICAgICAgICAgICAgc3RhcnQgPSBwcmV2KCk7XG4gICAgICAgICAgICBuYW1lID0gYXNfc3ltYm9sKGFzdC5TeW1ib2xEZWZ1bik7XG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRlcm5hbGRlY29yYXRvciA9IGhhc19zaW1wbGVfZGVjb3JhdG9yKFMuZGVjb3JhdG9ycywgXCJleHRlcm5hbFwiKTtcbiAgICAgICAgICAgIGNsYXNzX2RldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgXCJzdGF0aWNcIjogW10sXG4gICAgICAgICAgICAgICAgXCJib3VuZFwiOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBkb2NzdHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgZGVmaW5pdGlvbiA9IG5ldyBhc3QuQ2xhc3Moe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIG1vZHVsZV9pZDogbW9kdWxlX2lkLFxuICAgICAgICAgICAgICAgIHBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdG9tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfKFwicHVuY1wiLCBcIihcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc18oXCJwdW5jXCIsIFwiKVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFMuaW5fcGFyZW50aGVzaXplZF9leHByID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXRvbSA9IGV4cHJfYXRvbShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gYXRvbS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0b207XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0oKSxcbiAgICAgICAgICAgICAgICBsb2NhbHZhcnM6IFtdLFxuICAgICAgICAgICAgICAgIHN0YXRpYzogY2xhc3NfZGV0YWlscy5zdGF0aWMsXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWw6IGV4dGVybmFsZGVjb3JhdG9yLFxuICAgICAgICAgICAgICAgIGJvdW5kOiBjbGFzc19kZXRhaWxzLmJvdW5kLFxuICAgICAgICAgICAgICAgIHN0YXRlbWVudHM6IFtdLFxuICAgICAgICAgICAgICAgIGRlY29yYXRvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjQ3LCDVkNWPaWR4NDc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkLCBkZWNvcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjQ3ID0g1ZDVj19JdGVyYWJsZShTLmRlY29yYXRvcnMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHg0NyA9IDA7INWQ1Y9pZHg0NyA8INWQ1Y9pdHI0Ny5sZW5ndGg7INWQ1Y9pZHg0NysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0b3IgPSDVkNWPaXRyNDdb1ZDVj2lkeDQ3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNvcmF0b3IgPT09IFwia3dhcmdzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK0JBU0VMSUJbXCJrd2FyZ3NcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnB1c2gobmV3IGFzdC5EZWNvcmF0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGRlY29yYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFMuZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICB9KCksXG4gICAgICAgICAgICAgICAgYm9keTogZnVuY3Rpb24obG9vcCwgbGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhO1xuICAgICAgICAgICAgICAgICAgICBTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTFdLmNsYXNzZXNbbmFtZS5uYW1lXSA9IGNsYXNzX2RldGFpbHM7XG4gICAgICAgICAgICAgICAgICAgIFMuaW5fc2NvcGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNsYXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vbmxvY2FsOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXM6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBTLmluX2RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBTLmluX2xvb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICBTLmxhYmVscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBhID0gYmxvY2tfKCk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3N0cmluZyA9IFMuaW5fc2NvcGVbUy5pbl9zY29wZS5sZW5ndGgtMV0uZG9jc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBTLmluX3Njb3BlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBTLmluX2xvb3AgPSBsb29wO1xuICAgICAgICAgICAgICAgICAgICBTLmxhYmVscyA9IGxhYmVscztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfShTLmluX2xvb3AsIFMubGFiZWxzKSxcbiAgICAgICAgICAgICAgICBkb2NzdHJpbmc6IGRvY3N0cmluZyxcbiAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGkgaW4gZGVmaW5pdGlvbi5ib2R5KSB7XG4gICAgICAgICAgICAgICAgc3RtdCA9IGRlZmluaXRpb24uYm9keVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RtdCBpbnN0YW5jZW9mIGFzdC5NZXRob2QgJiYgc3RtdC5uYW1lLm5hbWUgPT09IFwiX19pbml0X19cIikge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uLmluaXQgPSBzdG10O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzc192YXJfbmFtZXMgPSB7fTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhbGtlcigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpdCA9IGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyINWQ1Y9pdHI0OCwg1ZDVj2lkeDQ4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgYXN0Lk1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NfdmFyX25hbWVzW25vZGUubmFtZS5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGFzdC5Bc3NpZ24gJiYgbm9kZS5sZWZ0IGluc3RhbmNlb2YgYXN0LlN5bWJvbFJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NfdmFyX25hbWVzW25vZGUubGVmdC5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjQ4ID0g1ZDVj19JdGVyYWJsZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4NDggPSAwOyDVkNWPaWR4NDggPCDVkNWPaXRyNDgubGVuZ3RoOyDVkNWPaWR4NDgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSDVkNWPaXRyNDhb1ZDVj2lkeDQ4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlW2NoaWxkXSBpbnN0YW5jZW9mIGFzdC5TeW1ib2xSZWYgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNsYXNzX3Zhcl9uYW1lcywgbm9kZVtjaGlsZF0ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlW2NoaWxkXSA9IG5ldyBhc3QuU3ltYm9sQ2xhc3NSZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBub2RlW2NoaWxkXS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2NlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NlbmQuY2FsbChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aXNpdG9yID0gbmV3IHdhbGtlcigpO1xuICAgICAgICAgICAg1ZDVj2l0cjQ5ID0g1ZDVj19JdGVyYWJsZShkZWZpbml0aW9uLmJvZHkpO1xuICAgICAgICAgICAgZm9yICjVkNWPaWR4NDkgPSAwOyDVkNWPaWR4NDkgPCDVkNWPaXRyNDkubGVuZ3RoOyDVkNWPaWR4NDkrKykge1xuICAgICAgICAgICAgICAgIHN0bXQgPSDVkNWPaXRyNDlb1ZDVj2lkeDQ5XTtcbiAgICAgICAgICAgICAgICBpZiAoIShzdG10IGluc3RhbmNlb2YgYXN0LkNsYXNzKSAmJiAhKHN0bXQgaW5zdGFuY2VvZiBhc3QuTWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICBzdG10LndhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24uc3RhdGVtZW50cy5wdXNoKHN0bXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChTLmluX3Njb3BlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIENMQVNTX01BUFtkZWZpbml0aW9uLm5hbWUubmFtZV0gPSBkZWZpbml0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZnVuY3Rpb25fKGluX2NsYXNzLCBjdG9yKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQsIGlzX2FjY2Vzc29yLCBuYW1lLCBnZW5lcmF0b3IsIGxvY2FsdmFycywgc3RhdGljbWV0aG9kLCBmdW5jdGlvbl9hcmdzLCByZXR1cm5fYW5ub3RhdGlvbiwgaGFzX3NwZWNpYWxfZGVjb3JhdG9yLCBjdG9yLCBkb2NzdHJpbmcsIGNhbGxzU3VwZXIsIGRlZmluaXRpb247XG4gICAgICAgICAgICBzdGFydCA9IHByZXYoKTtcbiAgICAgICAgICAgIGlzX2FjY2Vzc29yID0gY3RvciA9PT0gYXN0Lk9iamVjdEdldHRlciB8fCBjdG9yID09PSBhc3QuT2JqZWN0U2V0dGVyO1xuICAgICAgICAgICAgbmFtZSA9IGlzXyhcIm5hbWVcIikgPyBhc19zeW1ib2woaW5fY2xhc3MgPyBhc3QuU3ltYm9sRGVmdW4gOiBpc19hY2Nlc3NvciA/IGFzdC5TeW1ib2xBY2Nlc3NvciA6IGFzdC5TeW1ib2xMYW1iZGEpIDogaXNfYWNjZXNzb3IgJiYgKGlzXyhcInN0cmluZ1wiKSB8fCBpc18oXCJudW1cIikpID8gYXNfYXRvbV9ub2RlKCkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGluX2NsYXNzICYmICFuYW1lKSB7XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgJiYg1ZDVj19pbihuYW1lLm5hbWUsIHRva2VuaXplci5KU19LRVlXT1JEUykpIHtcbiAgICAgICAgICAgICAgICBuYW1lLm5hbWUgKz0gXCJfXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5lcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgIGxvY2FsdmFycyA9IG51bGw7XG4gICAgICAgICAgICBzdGF0aWNtZXRob2QgPSBmYWxzZTtcbiAgICAgICAgICAgIGZ1bmN0aW9uX2FyZ3MgPSB7fTtcbiAgICAgICAgICAgIHJldHVybl9hbm5vdGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghUy5pbl9kZWNvcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBoYXNfc3BlY2lhbF9kZWNvcmF0b3IgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNfc2ltcGxlX2RlY29yYXRvcihTLmRlY29yYXRvcnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGluX2NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNfc3BlY2lhbF9kZWNvcmF0b3IoXCJzdGF0aWNtZXRob2RcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMuaW5fc2NvcGVbUy5pbl9zY29wZS5sZW5ndGgtMl0uY2xhc3Nlc1tpbl9jbGFzc10uc3RhdGljLnB1c2gobmFtZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY21ldGhvZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc19zcGVjaWFsX2RlY29yYXRvcihcImJpbmRcIikgfHwgbmFtZS5uYW1lICE9PSBcIl9faW5pdF9fXCIgJiYgb3B0aW9ucy5hdXRvX2JpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrQkFTRUxJQltcImJpbmRcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICBTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTJdLmNsYXNzZXNbaW5fY2xhc3NdLmJvdW5kW25hbWUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0KFwiKFwiKTtcbiAgICAgICAgICAgIGlmICghY3Rvcikge1xuICAgICAgICAgICAgICAgIGN0b3IgPSBpbl9jbGFzcyA/IG5hbWUubmFtZSA9PT0gXCJfX2luaXRfX1wiID8gYXN0LkNvbnN0cnVjdG9yIDogYXN0Lk1ldGhvZCA6IGFzdC5GdW5jdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3N0cmluZyA9IG51bGw7XG4gICAgICAgICAgICBjYWxsc1N1cGVyID0gbnVsbDtcbiAgICAgICAgICAgIGRlZmluaXRpb24gPSBuZXcgY3Rvcih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgYXJnbmFtZXM6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRzLCBmaXJzdCwgc2Vlbl9uYW1lcywgZGVmX2xpbmUsIHZhbCwgZXhwcjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZWVuX25hbWVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGRlZl9saW5lID0gUy5pbnB1dC5jb250ZXh0KCkudG9rbGluZTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0X2FyZygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lX3Rva2VuLCBuYW1lX2N0eCwgbnRvaywgYW5ub3RhdGlvbiwgc3ltLCBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWVuX25hbWVzLCBTLnRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKHByZXYoKSwgXCJDYW4ndCByZXBlYXQgcGFyYW1ldGVyIG5hbWVzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFMudG9rZW4udmFsdWUgPT09IFwiYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihwcmV2KCksIFwiQ2FuJ3QgdXNlIHRoZSBuYW1lIGFyZ3VtZW50cyBhcyBhIHBhcmFtZXRlciBuYW1lLCBpdCBpcyByZXNlcnZlZCBieSBKYXZhU2NyaXB0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vlbl9uYW1lc1tTLnRva2VuLnZhbHVlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lX3Rva2VuID0gUy50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVfY3R4ID0gUy5pbnB1dC5jb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBudG9rID0gcGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG50b2sudHlwZSA9PT0gXCJwdW5jXCIgJiYgbnRvay52YWx1ZSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uID0gbWF5YmVfY29uZGl0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5pc190b2tlbihuYW1lX3Rva2VuLCBcIm5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJOYW1lIGV4cGVjdGVkXCIsIG5hbWVfY3R4LnRva2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltID0gbmV3IGFzdC5TeW1ib2xGdW5hcmcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogbmFtZV90b2tlbi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdGFydFwiOiBTLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVuZFwiOiBTLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFubm90YXRpb25cIjogYW5ub3RhdGlvbiA/IG5ldyBhc3QuQW5ub3RhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0YXJ0XCI6IGFubm90YXRpb24uc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogYW5ub3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZW5kXCI6IGFubm90YXRpb24uZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzXyhcIm5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFMuaW5wdXQuY29udGV4dCgpLnRva2xpbmUgIT09IGRlZl9saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIk5hbWUgZXhwZWN0ZWRcIiwgZGVmX2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJOYW1lIGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gUy50b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAo1ZDVj19pbihuYW1lLCB0b2tlbml6ZXIuSlNfS0VZV09SRFMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gXCJfXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bSA9IG5ldyBhc3QuU3ltYm9sRnVuYXJnKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RhcnRcIjogUy50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbmRcIjogUy50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbm5vdGF0aW9uXCI6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9hcmdzW3N5bS5uYW1lXSA9IHN5bS5hbm5vdGF0aW9uID8gc3ltLmFubm90YXRpb24ucmVzb2x2ZVR5cGUoUy5pbl9zY29wZSkgOiBcIj9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFpc18oXCJwdW5jXCIsIFwiKVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc18oXCJvcGVyYXRvclwiLCBcIioqXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IocHJldigpLCBcIioqa3dhcmdzIGluIGZ1bmN0aW9uIGRlZmluaXRpb24gaXMgbm90IGltcGxlbWVudGVkIHlldCwgd29yayBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEua3dhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKHByZXYoKSwgXCJDYW4ndCBkZWZpbmUgbXVsdGlwbGUgKiprd2FyZ3MgaW4gZnVuY3Rpb24gZGVmaW5pdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5rd2FyZ3MgPSBnZXRfYXJnKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzXyhcIm9wZXJhdG9yXCIsIFwiKlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5zdGFyYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihwcmV2KCksIFwiQ2FuJ3QgZGVmaW5lIG11bHRpcGxlICphcmdzIGluIGZ1bmN0aW9uIGRlZmluaXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhLmt3YXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihwcmV2KCksIFwiQ2FuJ3QgZGVmaW5lICphcmdzIGFmdGVyICoqa3dhcmdzIGluIGZ1bmN0aW9uIGRlZmluaXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuc3RhcmFyZ3MgPSBnZXRfYXJnKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhLnN0YXJhcmdzIHx8IGEua3dhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKHByZXYoKSwgXCJDYW4ndCBkZWZpbmUgYSBmb3JtYWwgcGFyYW1ldGVyIGFmdGVyICphcmdzIG9yICoqa3dhcmdzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goZ2V0X2FyZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfKFwib3BlcmF0b3JcIiwgXCI9XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhLmt3YXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IocHJldigpLCBcIkNhbid0IGRlZmluZSBhbiBvcHRpb25hbCBmb3JtYWwgcGFyYW1ldGVyIGFmdGVyICoqa3dhcmdzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHByZXYoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0c1t2YWxdID0gZXhwcmVzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuaGFzX2RlZmF1bHRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5oYXNfZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKHByZXYoKSwgXCJDYW4ndCBkZWZpbmUgcmVxdWlyZWQgZm9ybWFsIHBhcmFtZXRlcnMgYWZ0ZXIgb3B0aW9uYWwgZm9ybWFsIHBhcmFtZXRlcnNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfKFwicHVuY1wiLCBcIi0+XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByID0gZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybl9hbm5vdGF0aW9uID0gbmV3IGFzdC5Bbm5vdGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZXhwci5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZXhwci5lbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGEuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfShbXSksXG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yczogUy5pbl9kZWNvcmF0b3IgPyBbXSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjUwLCDVkNWPaWR4NTA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkLCBkZWNvcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjUwID0g1ZDVj19JdGVyYWJsZShTLmRlY29yYXRvcnMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHg1MCA9IDA7INWQ1Y9pZHg1MCA8INWQ1Y9pdHI1MC5sZW5ndGg7INWQ1Y9pZHg1MCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0b3IgPSDVkNWPaXRyNTBb1ZDVj2lkeDUwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucHVzaChuZXcgYXN0LkRlY29yYXRvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZGVjb3JhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgUy5kZWNvcmF0b3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgIH0oKSxcbiAgICAgICAgICAgICAgICByZXR1cm5fYW5ub3RhdGlvbjogcmV0dXJuX2Fubm90YXRpb24sXG4gICAgICAgICAgICAgICAgYm9keTogZnVuY3Rpb24obG9vcCwgbGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhLCB2YXJpYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgUy5pbl9zY29wZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgPyBuYW1lLm5hbWUgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuX2Fubm90YXRpb246IHJldHVybl9hbm5vdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ubG9jYWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBmdW5jdGlvbl9hcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXM6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBTLmluX2RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBTLmluX2xvb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICBTLmxhYmVscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBhID0gYmxvY2tfKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRvciA9IFMuaW5fc2NvcGVbUy5pbl9zY29wZS5sZW5ndGgtMV0uZ2VuZXJhdG9yO1xuICAgICAgICAgICAgICAgICAgICBkb2NzdHJpbmcgPSBTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTFdLmRvY3N0cmluZztcbiAgICAgICAgICAgICAgICAgICAgY2FsbHNTdXBlciA9IFMuaW5fc2NvcGVbUy5pbl9zY29wZS5sZW5ndGgtMV0uY2FsbHNTdXBlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAg1ZDVj19wcmludChTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2NhbHZhcnMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIg1ZDVj2lkeDUxLCDVkNWPaXRyNTEgPSDVkNWPX0l0ZXJhYmxlKE9iamVjdC5rZXlzKFMuaW5fc2NvcGVbUy5pbl9zY29wZS5sZW5ndGgtMV0udmFycykpLCDVkNWPcmVzID0gW10sIHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4NTEgPSAwOyDVkNWPaWR4NTEgPCDVkNWPaXRyNTEubGVuZ3RoOyDVkNWPaWR4NTErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0g1ZDVj2l0cjUxW9WQ1Y9pZHg1MV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEo1ZDVj19pbih2YXJpYWJsZSwgUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0xXS5ub25sb2NhbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgINWQ1Y9yZXMucHVzaChuZXdfc3ltYm9sKGFzdC5TeW1ib2xWYXIsIHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuINWQ1Y9yZXM7XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgIFMuaW5fc2NvcGUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIFMuaW5fbG9vcCA9IGxvb3A7XG4gICAgICAgICAgICAgICAgICAgIFMubGFiZWxzID0gbGFiZWxzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9KFMuaW5fbG9vcCwgUy5sYWJlbHMpLFxuICAgICAgICAgICAgICAgIGRvY3N0cmluZzogZG9jc3RyaW5nLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIGxvY2FsdmFyczogbG9jYWx2YXJzLFxuICAgICAgICAgICAgICAgIGVuZDogcHJldigpLFxuICAgICAgICAgICAgICAgIHN0YXRpYzogaW5fY2xhc3MgJiYgc3RhdGljbWV0aG9kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0xXS5mdW5jdGlvbnNbbmFtZS5uYW1lXSA9IGRlZmluaXRpb24ucmVzb2x2ZVR5cGUoUy5pbl9zY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5fY2xhc3MgJiYgIXN0YXRpY21ldGhvZCkge1xuICAgICAgICAgICAgICAgIGlmIChjdG9yID09PSBhc3QuQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5wYXJlbnQgPSBTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTFdLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5jYWxsc1N1cGVyID0gY2FsbHNTdXBlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uYXJnbmFtZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBjcm9hayhcIkNsYXNzIG1ldGhvZHMgcmVxdWlyZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKHNlbGYpXCIsIHN0YXJ0LmxpbmUsIHN0YXJ0LmNvbCwgc3RhcnQucG9zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN0b3IgPT09IGFzdC5PYmplY3RHZXR0ZXIgJiYgZGVmaW5pdGlvbi5hcmduYW1lcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJDbGFzcyBnZXR0ZXJzIGRvbid0IHRha2UgYW55IGFyZ3VtZW50cyBhc2lkZSBmcm9tIG9uZSByZWZlcmVuY2luZyB0aGUgaW5zdGFuY2UgKHNlbGYpXCIsIHN0YXJ0LmxpbmUsIHN0YXJ0LmNvbCwgc3RhcnQucG9zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN0b3IgPT09IGFzdC5PYmplY3RTZXR0ZXIgJiYgZGVmaW5pdGlvbi5hcmduYW1lcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJDbGFzcyBzZXR0ZXJzIHRha2UgZXhhY3RseSAyIGFyZ3VtZW50cyAoc2VsZiwgdmFsdWUpXCIsIHN0YXJ0LmxpbmUsIHN0YXJ0LmNvbCwgc3RhcnQucG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzX2FjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN0b3IgPT09IGFzdC5PYmplY3RHZXR0ZXIgJiYgZGVmaW5pdGlvbi5hcmduYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJPYmplY3QgZ2V0dGVycyBkb24ndCB0YWtlIGFueSBhcmd1bWVudHNcIiwgc3RhcnQubGluZSwgc3RhcnQuY29sLCBzdGFydC5wb3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3RvciA9PT0gYXN0Lk9iamVjdFNldHRlciAmJiBkZWZpbml0aW9uLmFyZ25hbWVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjcm9hayhcIk9iamVjdCBzZXR0ZXJzIHRha2UgZXhhY3RseSAxIGFyZ3VtZW50XCIsIHN0YXJ0LmxpbmUsIHN0YXJ0LmNvbCwgc3RhcnQucG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhY2Nlc3Nvcl8odHlwZSwgc3RhcnQsIGluX2NsYXNzKSB7XG4gICAgICAgICAgICB2YXIgZnVuYztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImdldFwiKSB7XG4gICAgICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uXyhpbl9jbGFzcywgYXN0Lk9iamVjdEdldHRlcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICAgICAgICBmdW5jID0gZnVuY3Rpb25fKGluX2NsYXNzLCBhc3QuT2JqZWN0U2V0dGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3JvYWsoXCJFeHBlY3Rpbmcgc2V0dGVyL2dldHRlciwgZ290ICdcIiArIHR5cGUgKyBcIicgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBmdW5jLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlmXygpIHtcbiAgICAgICAgICAgIHZhciBjb25kLCBib2R5LCBiZWxzZTtcbiAgICAgICAgICAgIGNvbmQgPSBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICAgICAgYm9keSA9IHN0YXRlbWVudCgpO1xuICAgICAgICAgICAgYmVsc2UgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzXyhcImtleXdvcmRcIiwgXCJlbGlmXCIpIHx8IGlzXyhcImtleXdvcmRcIiwgXCJlbHNlXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzXyhcImtleXdvcmRcIiwgXCJlbHNlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBTLnRva2VuLnZhbHVlID0gXCJpZlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiZWxzZSA9IHN0YXRlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3QuSWYoe1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogY29uZCxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBiZWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNfZG9jc3RyaW5nKHN0bXQpIHtcbiAgICAgICAgICAgIGlmIChzdG10IGluc3RhbmNlb2YgYXN0LkRpcmVjdGl2ZSAmJiAhUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0xXS5kb2NzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb3JtYXRfZG9jc3RyaW5nKHN0cmluZykge1xuICAgICAgICAgICAgdmFyINWQ1Y9pdHI1Miwg1ZDVj2lkeDUyLCDVkNWPaXRyNTMsINWQ1Y9pZHg1MztcbiAgICAgICAgICAgIHZhciBsaW5lcywgaW5kZW50LCBsaW5lLCBwYWQsIHRyaW1tZWQ7XG4gICAgICAgICAgICBsaW5lcyA9IHN0cmluZy5zcGxpdCgvXFxuL2cpO1xuICAgICAgICAgICAgaW5kZW50ID0gMWU2O1xuICAgICAgICAgICAg1ZDVj2l0cjUyID0g1ZDVj19JdGVyYWJsZShsaW5lcy5zbGljZSgxKSk7XG4gICAgICAgICAgICBmb3IgKNWQ1Y9pZHg1MiA9IDA7INWQ1Y9pZHg1MiA8INWQ1Y9pdHI1Mi5sZW5ndGg7INWQ1Y9pZHg1MisrKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9INWQ1Y9pdHI1MlvVkNWPaWR4NTJdO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLnRyaW0oKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkID0gbGluZS5tYXRjaCgvXlxccyovKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gTWF0aC5taW4oaW5kZW50LCBwYWQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmltbWVkID0gWyBsaW5lc1swXS50cmltKCkgXTtcbiAgICAgICAgICAgIGlmIChpbmRlbnQgPCAxZTYpIHtcbiAgICAgICAgICAgICAgICDVkNWPaXRyNTMgPSDVkNWPX0l0ZXJhYmxlKGxpbmVzLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHg1MyA9IDA7INWQ1Y9pZHg1MyA8INWQ1Y9pdHI1My5sZW5ndGg7INWQ1Y9pZHg1MysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSDVkNWPaXRyNTNb1ZDVj2lkeDUzXTtcbiAgICAgICAgICAgICAgICAgICAgdHJpbW1lZC5wdXNoKGxpbmUuc2xpY2UoaW5kZW50KS5yZXBsYWNlKC9cXHMrJC8pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAodHJpbW1lZCAmJiAhdHJpbW1lZFt0cmltbWVkLmxlbmd0aC0xXSkge1xuICAgICAgICAgICAgICAgIHRyaW1tZWQucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAodHJpbW1lZCAmJiAhdHJpbW1lZFswXSkge1xuICAgICAgICAgICAgICAgIHRyaW1tZWQuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmltbWVkLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmxvY2tfKCkge1xuICAgICAgICAgICAgdmFyIGEsIHN0bXQ7XG4gICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgICAgaWYgKCFTLnRva2VuLm5ld2xpbmVfYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFTLnRva2VuLm5ld2xpbmVfYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc18oXCJlb2ZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdG10ID0gc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYS5sZW5ndGggJiYgaXNfZG9jc3RyaW5nKHN0bXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZHJvcERvY3N0cmluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTFdLmRvY3N0cmluZyA9IGZvcm1hdF9kb2NzdHJpbmcoc3RtdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3RtdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlICghaXNfKFwicHVuY1wiLCBcIn1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzXyhcImVvZlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RtdCA9IHN0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWEubGVuZ3RoICYmIGlzX2RvY3N0cmluZyhzdG10KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRyb3BEb2NzdHJpbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0xXS5kb2NzdHJpbmcgPSBmb3JtYXRfZG9jc3RyaW5nKHN0bXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0bXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN3aXRjaF9ib2R5XygpIHtcbiAgICAgICAgICAgIHZhciBhLCBjdXIsIGJyYW5jaDtcbiAgICAgICAgICAgIGV4cGVjdChcIntcIik7XG4gICAgICAgICAgICBhID0gW107XG4gICAgICAgICAgICBjdXIgPSBudWxsO1xuICAgICAgICAgICAgYnJhbmNoID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICghaXNfKFwicHVuY1wiLCBcIn1cIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNfKFwiZW9mXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzXyhcImtleXdvcmRcIiwgXCJjYXNlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChicmFuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyYW5jaC5lbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyID0gW107XG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaCA9IG5ldyBhc3QuQ2FzZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBTLnRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbih0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGN1clxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGJyYW5jaCk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChcIjpcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc18oXCJrZXl3b3JkXCIsIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhbmNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmFuY2guZW5kID0gcHJldigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmFuY2ggPSBuZXcgYXN0LkRlZmF1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gUy50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogY3VyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goYnJhbmNoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1ci5wdXNoKHN0YXRlbWVudCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnJhbmNoKSB7XG4gICAgICAgICAgICAgICAgYnJhbmNoLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyeV8oKSB7XG4gICAgICAgICAgICB2YXIgYm9keSwgYmNhdGNoLCBiZmluYWxseSwgc3RhcnQsIGV4Y2VwdGlvbnMsIG5hbWU7XG4gICAgICAgICAgICBib2R5ID0gYmxvY2tfKCk7XG4gICAgICAgICAgICBiY2F0Y2ggPSBbXTtcbiAgICAgICAgICAgIGJmaW5hbGx5ID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChpc18oXCJrZXl3b3JkXCIsIFwiZXhjZXB0XCIpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBleGNlcHRpb25zID0gW107XG4gICAgICAgICAgICAgICAgaWYgKCFpc18oXCJwdW5jXCIsIFwiOlwiKSAmJiAhaXNfKFwia2V5d29yZFwiLCBcImFzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbnMucHVzaChhc19zeW1ib2woYXN0LlN5bWJvbFZhcikpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaXNfKFwicHVuY1wiLCBcIixcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbnMucHVzaChhc19zeW1ib2woYXN0LlN5bWJvbFZhcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc18oXCJrZXl3b3JkXCIsIFwiYXNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gYXNfc3ltYm9sKGFzdC5TeW1ib2xDYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJjYXRjaC5wdXNoKG5ldyBhc3QuRXhjZXB0KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBhcmduYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGV4Y2VwdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGJsb2NrXygpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc18oXCJrZXl3b3JkXCIsIFwiZmluYWxseVwiKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgYmZpbmFsbHkgPSBuZXcgYXN0LkZpbmFsbHkoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGJsb2NrXygpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFiY2F0Y2gubGVuZ3RoICYmICFiZmluYWxseSkge1xuICAgICAgICAgICAgICAgIGNyb2FrKFwiTWlzc2luZyBleGNlcHQvZmluYWxseSBibG9ja3NcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdC5Ucnkoe1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgYmNhdGNoOiBiY2F0Y2gubGVuZ3RoID8gbmV3IGFzdC5DYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGJjYXRjaFxuICAgICAgICAgICAgICAgIH0pIDogbnVsbCxcbiAgICAgICAgICAgICAgICBiZmluYWxseTogYmZpbmFsbHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhcmRlZnMobm9faW4sIHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBhLCBzeW1ib2w7XG4gICAgICAgICAgICBhID0gW107XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBhc3QuVmFyRGVmKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFMudG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGFzX3N5bWJvbCh0eXBlID09PSBcImNvbnN0XCIgPyBhc3QuU3ltYm9sQ29uc3QgOiB0eXBlID09PSBcIm5vbmxvY2FsXCIgPyBhc3QuU3ltYm9sTm9ubG9jYWwgOiBhc3QuU3ltYm9sVmFyKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJub25sb2NhbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIFMuaW5fc2NvcGVbUy5pbl9zY29wZS5sZW5ndGgtMV0ubm9ubG9jYWxbc3ltYm9sLm5hbWUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzXyhcInB1bmNcIiwgXCIsXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBub25sb2NhbF8obm9faW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0LlZhcih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHByZXYoKSxcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uczogdmFyZGVmcyhub19pbiwgXCJub25sb2NhbFwiKSxcbiAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29uc3RfKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3QuQ29uc3Qoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBwcmV2KCksXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbnM6IHZhcmRlZnMoZmFsc2UsIFwiY29uc3RcIiksXG4gICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5ld18oKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQsIG5ld2V4cCwgYXJncztcbiAgICAgICAgICAgIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgICAgIGV4cGVjdF90b2tlbihcIm9wZXJhdG9yXCIsIFwibmV3XCIpO1xuICAgICAgICAgICAgbmV3ZXhwID0gZXhwcl9hdG9tKGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChpc18oXCJwdW5jXCIsIFwiKFwiKSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBhcmdzID0gZXhwcl9saXN0KFwiKVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IGFzdC5OZXcoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBuZXdleHAsXG4gICAgICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgfSksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFzX2F0b21fbm9kZSh0b2tlbikge1xuICAgICAgICAgICAgdmFyIHRvaywgdG1wXywgdG9rZW4sIHJldCwgdG1wX187XG4gICAgICAgICAgICB0b2sgPSB0b2tlbiB8fCBTLnRva2VuO1xuICAgICAgICAgICAgdG1wXyA9IHRvay50eXBlO1xuICAgICAgICAgICAgaWYgKHRtcF8gPT09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvay52YWx1ZSA9PT0gXCJOYU5cIikge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBrd2FyZ3MoYXNfc3ltYm9sKShhc3QuTm90QU51bWJlciwge3Rva2VuOiB0b2t9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRvay52YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBrd2FyZ3MoYXNfc3ltYm9sKShhc3QuVW5kZWZpbmVkLCB7dG9rZW46IHRva30pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGt3YXJncyhhc19zeW1ib2wpKGFzdC5TeW1ib2xSZWYsIHt0b2tlbjogdG9rfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcIm51bVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3IGFzdC5OdW1iZXIoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogdG9rLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHRvayxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRvay52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3IGFzdC5TdHJpbmcoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogdG9rLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHRvayxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRvay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRvay5zdWJ0eXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IFwicmVnZXhwXCIpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBuZXcgYXN0LlJlZ0V4cCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0b2ssXG4gICAgICAgICAgICAgICAgICAgIGVuZDogdG9rLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9rLnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IFwiYXRvbVwiKSB7XG4gICAgICAgICAgICAgICAgdG1wX18gPSB0b2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRtcF9fID09PSBcIkZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gbmV3IGFzdC5Cb29sZWFuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0b2ssXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHRva1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF9fID09PSBcIlRydWVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBuZXcgYXN0LkJvb2xlYW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRvayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB0b2tcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfXyA9PT0gXCJOb25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gbmV3IGFzdC5OdWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0b2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHRva1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0LnJlc29sdmVUeXBlKFMuaW5fc2NvcGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleHByX2F0b20oYWxsb3dfY2FsbHMpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCwgdG1wXywgZXgsIGNscywgZnVuYztcbiAgICAgICAgICAgIGlmIChpc18oXCJvcGVyYXRvclwiLCBcIm5ld1wiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICBpZiAoaXNfKFwicHVuY1wiKSkge1xuICAgICAgICAgICAgICAgIHRtcF8gPSBzdGFydC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG1wXyA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBleCA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGV4LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGV4LmVuZCA9IFMudG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChleCBpbnN0YW5jZW9mIGFzdC5TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4LnBhcmVucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoZXgsIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGFycmF5XygpLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhvYmplY3RfKCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzXyhcImtleXdvcmRcIiwgXCJjbGFzc1wiKSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBjbHMgPSBjbGFzc18oKTtcbiAgICAgICAgICAgICAgICBjbHMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICBjbHMuZW5kID0gcHJldigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGNscywgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzXyhcImtleXdvcmRcIiwgXCJkZWZcIikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uXyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgZnVuYy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIGZ1bmMuZW5kID0gcHJldigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGZ1bmMsIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBVE9NSUNfU1RBUlRfVE9LRU5bUy50b2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGFzX2F0b21fbm9kZSgpLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhwcl9saXN0KGNsb3NpbmcsIGFsbG93X3RyYWlsaW5nX2NvbW1hLCBhbGxvd19lbXB0eSwgZnVuY19jYWxsKSB7XG4gICAgICAgICAgICB2YXIg1ZDVj2l0cjU0LCDVkNWPaWR4NTQsINWQ1Y91cGs0O1xuICAgICAgICAgICAgdmFyIGZpcnN0LCBhLCBzYXdfc3RhcmFyZ3MsIHRtcCwgaSwgYXJnO1xuICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgICAgc2F3X3N0YXJhcmdzID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoIWlzXyhcInB1bmNcIiwgY2xvc2luZykpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2F3X3N0YXJhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKHByZXYoKSwgXCIqYXJncyBtdXN0IGJlIHRoZSBsYXN0IGFyZ3VtZW50IGluIGEgZnVuY3Rpb24gY2FsbFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93X3RyYWlsaW5nX2NvbW1hICYmIGlzXyhcInB1bmNcIiwgY2xvc2luZykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc18oXCJvcGVyYXRvclwiLCBcIipcIikgJiYgZnVuY19jYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhd19zdGFyYXJncyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzXyhcInB1bmNcIiwgXCIsXCIpICYmIGFsbG93X2VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChuZXcgYXN0LkhvbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFMudG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IFMudG9rZW5cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChleHByZXNzaW9uKGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmNfY2FsbCkge1xuICAgICAgICAgICAgICAgIHRtcCA9IFtdO1xuICAgICAgICAgICAgICAgIHRtcC5rd2FyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICDVkNWPaXRyNTQgPSDVkNWPX0l0ZXJhYmxlKGVudW1lcmF0ZShhKSk7XG4gICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4NTQgPSAwOyDVkNWPaWR4NTQgPCDVkNWPaXRyNTQubGVuZ3RoOyDVkNWPaWR4NTQrKykge1xuICAgICAgICAgICAgICAgICAgICDVkNWPdXBrNCA9INWQ1Y9pdHI1NFvVkNWPaWR4NTRdO1xuICAgICAgICAgICAgICAgICAgICBpID0g1ZDVj3VwazRbMF07XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9INWQ1Y91cGs0WzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgYXN0LkFzc2lnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytCQVNFTElCW1wia3dhcmdzXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wLmt3YXJncy5wdXNoKFsgYXJnLmxlZnQsIGFyZy5yaWdodCBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChzYXdfc3RhcmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBhLnN0YXJhcmdzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZ1bmNfY2FsbF9saXN0KCkge1xuICAgICAgICAgICAgdmFyIGEsIGZpcnN0LCBrd2FyZ3MsIGFyZztcbiAgICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGEua3dhcmdzID0gW107XG4gICAgICAgICAgICBhLmt3YXJnX2l0ZW1zID0ga3dhcmdzID0gW107XG4gICAgICAgICAgICBhLnN0YXJhcmdzID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoIWlzXyhcInB1bmNcIiwgXCIpXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzXyhcIm9wZXJhdG9yXCIsIFwiKlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGV4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhcmcuaXNfYXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgYS5zdGFyYXJncyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc18oXCJvcGVyYXRvclwiLCBcIioqXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICsrQkFTRUxJQltcImt3YXJnc1wiXTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBrd2FyZ3MucHVzaChhc19zeW1ib2woYXN0LlN5bWJvbFZhciwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBleHByZXNzaW9uKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIGFzdC5Bc3NpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrQkFTRUxJQltcImt3YXJnc1wiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEua3dhcmdzLnB1c2goWyBhcmcubGVmdCwgYXJnLnJpZ2h0IF0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWFkX2NvbXByZWhlbnNpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgdGVybWluYXRvciwgZm9ybG9vcDtcbiAgICAgICAgICAgIHRlcm1pbmF0b3IgPSBvYmplY3QgaW5zdGFuY2VvZiBhc3QuRGljdENvbXByZWhlbnNpb24gPyBcIn1cIiA6IFwiXVwiO1xuICAgICAgICAgICAgZXhwZWN0X3Rva2VuKFwia2V5d29yZFwiLCBcImZvclwiKTtcbiAgICAgICAgICAgIGZvcmxvb3AgPSBmb3JfKHRydWUpO1xuICAgICAgICAgICAgKytCQVNFTElCW1wiaXRlcmFibGVcIl07XG4gICAgICAgICAgICBvYmplY3QuaW5pdCA9IGZvcmxvb3AuaW5pdDtcbiAgICAgICAgICAgIG9iamVjdC5uYW1lID0gZm9ybG9vcC5uYW1lO1xuICAgICAgICAgICAgb2JqZWN0Lm9iamVjdCA9IGZvcmxvb3Aub2JqZWN0O1xuICAgICAgICAgICAgb2JqZWN0LmNvbmRpdGlvbiA9IGlzXyhcInB1bmNcIiwgdGVybWluYXRvcikgPyBudWxsIDogKGV4cGVjdF90b2tlbihcImtleXdvcmRcIiwgXCJpZlwiKSwgXG4gICAgICAgICAgICBleHByZXNzaW9uKHRydWUpKTtcbiAgICAgICAgICAgIGV4cGVjdCh0ZXJtaW5hdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBhcnJheV8gPSAo1ZDVj18xMTkgPSBmdW5jdGlvbiBhcnJheV8oKSB7XG4gICAgICAgICAgICB2YXIgZXhwciwgcmV0O1xuICAgICAgICAgICAgZXhwZWN0KFwiW1wiKTtcbiAgICAgICAgICAgIGV4cHIgPSBbXTtcbiAgICAgICAgICAgIGlmICghaXNfKFwicHVuY1wiLCBcIl1cIikpIHtcbiAgICAgICAgICAgICAgICBleHByLnB1c2goZXhwcmVzc2lvbihmYWxzZSkpO1xuICAgICAgICAgICAgICAgIGlmIChpc18oXCJrZXl3b3JkXCIsIFwiZm9yXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkX2NvbXByZWhlbnNpb24obmV3IGFzdC5MaXN0Q29tcHJlaGVuc2lvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQ6IGV4cHJbMF1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfKFwib3BlcmF0b3JcIiwgXCJ0aWxcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgKytCQVNFTElCW1wicmFuZ2VcIl07XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwci5wdXNoKGV4cHJlc3Npb24oZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gbmV3IGFzdC5SYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogUy50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHJbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCJ0aWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBleHByWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChcIl1cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc18oXCJvcGVyYXRvclwiLCBcInRvXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICsrQkFTRUxJQltcInJhbmdlXCJdO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV4cHIucHVzaChleHByZXNzaW9uKGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IG5ldyBhc3QuUmFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFMudG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBleHByWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwidG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBleHByWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChcIl1cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNfKFwicHVuY1wiLCBcIl1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdC5BcnJheSh7XG4gICAgICAgICAgICAgICAgZWxlbWVudHM6IGV4cHIuY29uY2F0KGV4cHJfbGlzdChcIl1cIiwgIW9wdGlvbnMuc3RyaWN0LCB0cnVlKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCDVkNWPXzExOSA9IGVtYmVkX3Rva2VucyjVkNWPXzExOSksINWQ1Y9fMTE5KTtcbiAgICAgICAgXG4gICAgICAgIHZhciBvYmplY3RfID0gKNWQ1Y9fMTIwID0gZnVuY3Rpb24gb2JqZWN0XygpIHtcbiAgICAgICAgICAgIHZhciBtYXliZV9kaWN0X2NvbXByZWhlbnNpb24sIGZpcnN0LCBhLCBzdGFydCwgdHlwZSwgY29tcHV0ZWQsIHNhd19zdGFyYXJncywga2V5LCBuYW1lLCBjdHgsIG9yaWcsIGtleV87XG4gICAgICAgICAgICBtYXliZV9kaWN0X2NvbXByZWhlbnNpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGV4cGVjdChcIntcIik7XG4gICAgICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICBhID0gW107XG4gICAgICAgICAgICB3aGlsZSAoIWlzXyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCIsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0ICYmIGlzXyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICAgICAgdHlwZSA9IHN0YXJ0LnR5cGU7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzYXdfc3RhcmFyZ3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNfKFwib3BlcmF0b3JcIiwgXCIqXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhd19zdGFyYXJncyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5lczYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiU3ByZWFkIG9wZXJhdG9yIGluIG9iamVjdCBsaXRlcmFscyBpcyBvbmx5IGFsbG93ZWQgaW4gRVM2IG1vZGVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG1heWJlX3VuYXJ5KHRydWUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpcnN0ICYmIHBlZWsoKS52YWx1ZSAhPT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVfZGljdF9jb21wcmVoZW5zaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gZXhwcmVzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IFMuaW5wdXQuY29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBvcmlnID0gY3R4LmV4cGVjdF9vYmplY3RfbGl0ZXJhbF9rZXk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5leHBlY3Rfb2JqZWN0X2xpdGVyYWxfa2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzXyhcInB1bmNcIiwgXCIoXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZXM2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJDb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gRVM2IG1vZGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZXhwcmVzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5XyA9IGFzX3Byb3BlcnR5X25hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBrZXlfLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleV8udHlwZSA9PT0gXCJudW1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG5ldyBhc3QuTnVtYmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Xy50eXBlID09PSBcIm5hbWVcIiB8fCBrZXlfLnR5cGUgPT09IFwia2V5d29yZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKNWQ1Y9faW4obmFtZSwgWyBcIlRydWVcIiwgXCJGYWxzZVwiIF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG5ldyBhc3QuQm9vbGVhbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG5ldyBhc3QuSWRlbnRpZmllcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbmV3IGFzdC5TdHJpbmcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5leHBlY3Rfb2JqZWN0X2xpdGVyYWxfa2V5ID0gb3JpZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwibmFtZVwiICYmICFpc18oXCJwdW5jXCIsIFwiOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGFjY2Vzc29yXyhuYW1lLCBzdGFydCwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2F3X3N0YXJhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChuZXcgYXN0Lk9iamVjdEtleVZhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBleHByZXNzaW9uKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEubGVuZ3RoID09PSAxICYmIGlzXyhcImtleXdvcmRcIiwgXCJmb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkX2NvbXByZWhlbnNpb24obmV3IGFzdC5EaWN0Q29tcHJlaGVuc2lvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50OiBtYXliZV9kaWN0X2NvbXByZWhlbnNpb24gPyBrZXkgOiBhc19hdG9tX25vZGUoYVswXS5zdGFydCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVfc3RhdGVtZW50OiBhWzBdLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0Lk9iamVjdExpdGVyYWwoe1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCDVkNWPXzEyMCA9IGVtYmVkX3Rva2VucyjVkNWPXzEyMCksINWQ1Y9fMTIwKTtcbiAgICAgICAgZnVuY3Rpb24gYXNfcHJvcGVydHlfbmFtZSgpIHtcbiAgICAgICAgICAgIHZhciB0bXAsIHRtcF87XG4gICAgICAgICAgICB0bXAgPSBTLnRva2VuO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgdG1wXyA9IHRtcC50eXBlO1xuICAgICAgICAgICAgaWYgKHRtcF8gPT09IFwibnVtXCIgfHwgdG1wXyA9PT0gXCJzdHJpbmdcIiB8fCB0bXBfID09PSBcIm5hbWVcIiB8fCB0bXBfID09PSBcIm9wZXJhdG9yXCIgfHwgdG1wXyA9PT0gXCJrZXl3b3JkXCIgfHwgdG1wXyA9PT0gXCJhdG9tXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXNfbmFtZSgpIHtcbiAgICAgICAgICAgIHZhciB0bXAsIHRtcF87XG4gICAgICAgICAgICB0bXAgPSBTLnRva2VuO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgdG1wXyA9IHRtcC50eXBlO1xuICAgICAgICAgICAgaWYgKHRtcF8gPT09IFwibmFtZVwiIHx8IHRtcF8gPT09IFwib3BlcmF0b3JcIiB8fCB0bXBfID09PSBcImtleXdvcmRcIiB8fCB0bXBfID09PSBcImF0b21cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXAudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhc19zeW1ib2wodHlwZSwgbm9lcnJvciwgdG9rZW4pIHtcbiAgICAgICAgICAgIHZhciB0b2tlbl8sIG5hbWUsIHN5bTtcbiAgICAgICAgICAgIHRva2VuXyA9IHRva2VuIHx8IFMudG9rZW47XG4gICAgICAgICAgICBpZiAoIXRva2VuaXplci5pc190b2tlbih0b2tlbl8sIFwibmFtZVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghbm9lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjcm9hayhcIk5hbWUgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZSA9IHRva2VuXy52YWx1ZTtcbiAgICAgICAgICAgIGlmICjVkNWPX2luKG5hbWUsIHRva2VuaXplci5KU19LRVlXT1JEUykpIHtcbiAgICAgICAgICAgICAgICB0b2tlbl8udmFsdWUgKz0gXCJfXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzeW0gPSBuZXcgKG5hbWUgPT09IFwidGhpc1wiID8gYXN0LlRoaXMgOiB0eXBlKSh7XG4gICAgICAgICAgICAgICAgbmFtZTogU3RyaW5nKHRva2VuXy52YWx1ZSksXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRva2VuXyxcbiAgICAgICAgICAgICAgICBlbmQ6IHRva2VuX1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN5bTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBuZXdfc3ltYm9sKHR5cGUsIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzeW07XG4gICAgICAgICAgICBzeW0gPSBuZXcgKG5hbWUgPT09IFwidGhpc1wiID8gYXN0LlRoaXMgOiB0eXBlKSh7XG4gICAgICAgICAgICAgICAgbmFtZTogU3RyaW5nKG5hbWUpLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgICAgIGVuZDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3ltO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzX3N0YXRpY19tZXRob2QoY2xzLCBtZXRob2QpIHtcbiAgICAgICAgICAgIGlmICjVkNWPX2luKG1ldGhvZCwgQ09NTU9OX1NUQVRJQykgfHwgY2xzLnN0YXRpYyAmJiDVkNWPX2luKG1ldGhvZCwgY2xzLnN0YXRpYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hcmtfbG9jYWxfYXNzaWdubWVudChlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvbXB1dGVkVHlwZSwgbmFtZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkVHlwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogdmFsdWUucmVzb2x2ZVR5cGUoUy5pbl9zY29wZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkVHlwZSA9IFwiP1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZSA9IHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiID8gZWxlbWVudCA6IGVsZW1lbnQubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKNWQ1Y9faW4obmFtZSwgUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0xXS52YXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTFdLnZhcnNbbmFtZV0ucHVzaChjb21wdXRlZFR5cGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFMuaW5fc2NvcGVbUy5pbl9zY29wZS5sZW5ndGgtMV0udmFyc1tuYW1lXSA9IFsgY29tcHV0ZWRUeXBlIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN1YnNjcmlwdHMoZXhwciwgYWxsb3dfY2FsbHMpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCwgc2xpY2VfYm91bmRzLCBpc19zbGljZSwgaSwgc3RyXywgcmV0LCBjbGFzc05hbWUsIGZ1bmNuYW1lLCB0bXBfLCBhcmdzO1xuICAgICAgICAgICAgc3RhcnQgPSBleHByLnN0YXJ0O1xuICAgICAgICAgICAgaWYgKGlzXyhcInB1bmNcIiwgXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBhc3QuRG90KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogYXNfbmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgIH0pLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNfKFwicHVuY1wiLCBcIltcIikgJiYgIVMudG9rZW4ubmV3bGluZV9iZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgc2xpY2VfYm91bmRzID0gW107XG4gICAgICAgICAgICAgICAgaXNfc2xpY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNfKFwicHVuY1wiLCBcIjpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xpY2VfYm91bmRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2xpY2VfYm91bmRzLnB1c2goZXhwcmVzc2lvbihmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfKFwicHVuY1wiLCBcIjpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNfc2xpY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc18oXCJwdW5jXCIsIFwiOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2VfYm91bmRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzXyhcInB1bmNcIiwgXCJdXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbGljZV9ib3VuZHMucHVzaChleHByZXNzaW9uKGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzXyhcInB1bmNcIiwgXCI6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICsrQkFTRUxJQltcImVzbGljZVwiXTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfKFwicHVuY1wiLCBcIl1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlX2JvdW5kcy5wdXNoKGV4cHJlc3Npb24oZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoXCJdXCIpO1xuICAgICAgICAgICAgICAgIGlmIChpc19zbGljZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfKFwib3BlcmF0b3JcIikgJiYgUy50b2tlbi52YWx1ZSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBhc3QuU2xpY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBzbGljZV9ib3VuZHNbMF0gfHwgbmV3IGFzdC5OdW1iZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5Mjogc2xpY2VfYm91bmRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnQ6IGV4cHJlc3Npb24odHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xpY2VfYm91bmRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2VfYm91bmRzLnVuc2hpZnQoc2xpY2VfYm91bmRzLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2xpY2VfYm91bmRzW3NsaWNlX2JvdW5kcy5sZW5ndGgtMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZV9ib3VuZHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzbGljZV9ib3VuZHNbc2xpY2VfYm91bmRzLmxlbmd0aC0xXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZV9ib3VuZHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghc2xpY2VfYm91bmRzW3NsaWNlX2JvdW5kcy5sZW5ndGgtMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZV9ib3VuZHNbc2xpY2VfYm91bmRzLmxlbmd0aC0yXSA9IG5ldyBhc3QuVW5kZWZpbmVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhuZXcgYXN0LkNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBuZXcgYXN0LlN5bWJvbFJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiZXNsaWNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbIGV4cHIgXS5jb25jYXQoc2xpY2VfYm91bmRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlX2JvdW5kcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIg1ZDVj2lkeDU1LCDVkNWPaXRyNTUgPSDVkNWPX0l0ZXJhYmxlKHNsaWNlX2JvdW5kcyksINWQ1Y9yZXMgPSBbXSwgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHg1NSA9IDA7INWQ1Y9pZHg1NSA8INWQ1Y9pdHI1NS5sZW5ndGg7INWQ1Y9pZHg1NSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSDVkNWPaXRyNTVb1ZDVj2lkeDU1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg1ZDVj3Jlcy5wdXNoKGkgPT09IG51bGwgPyBuZXcgYXN0Lk51bWJlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6IGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4g1ZDVj3JlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhuZXcgYXN0LkNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBuZXcgYXN0LkRvdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IFwic2xpY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBzbGljZV9ib3VuZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhuZXcgYXN0LlN1Yih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHNsaWNlX2JvdW5kc1swXSB8fCBuZXcgYXN0Lk51bWJlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgfSksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsb3dfY2FsbHMgJiYgaXNfKFwicHVuY1wiLCBcIihcIikgJiYgIVMudG9rZW4ubmV3bGluZV9iZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBhc3QuU3ltYm9sUmVmICYmIGV4cHIubmFtZSA9PT0gXCJKU1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cl8gPSBleHByZXNzaW9uKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoc3RyXyBpbnN0YW5jZW9mIGFzdC5TdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihwcmV2KCksIFwiQ29tcGlsZS10aW1lIGZ1bmN0aW9uIEpTKCkgY2FuJ3QgZXZhbHVhdGUgdmFyaWFibGVzIG9yIGV4cHJlc3Npb25zXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IG5ldyBhc3QuVmVyYmF0aW0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cl8udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMocmV0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFleHByLnBhcmVucyAmJiBnZXRfY2xhc3NfaW5fc2NvcGUoZXhwcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKNWQ1Y9faW4oZXhwci5uYW1lLCBTVERMSUIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK0JBU0VMSUJbZXhwci5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvRXJyb3IkLy50ZXN0KGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK0JBU0VMSUJbXCJleHRlbmRzXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBhc3QuTmV3KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBmdW5jX2NhbGxfbGlzdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgfSksIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgYXN0LkRvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0X2NsYXNzX2luX3Njb3BlKGV4cHIuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY25hbWUgPSBleHByO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmNuYW1lLnByb3BlcnR5ID09PSBcIl9faW5pdF9fXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jbmFtZS5wcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFMuaW5fc2NvcGVbUy5pbl9zY29wZS5sZW5ndGgtMV0uY2FsbHNTdXBlciA9IFMuaW5fc2NvcGUubGVuZ3RoID4gMSAmJiBTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTJdLnR5cGUgPT09IFwiY2xhc3NcIiAmJiBleHByLmV4cHJlc3Npb24ubmFtZSA9PT0gUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0yXS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVDYWxsQXJncyhzdWJzY3JpcHRzKG5ldyBhc3QuQ2xhc3NDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGV4cHIuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmNuYW1lLnByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyOiBTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTFdLmNhbGxzU3VwZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljOiBpc19zdGF0aWNfbWV0aG9kKGNsYXNzTmFtZSwgZnVuY25hbWUucHJvcGVydHkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGZ1bmNfY2FsbF9saXN0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIGFzdC5TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcF8gPSBleHByLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAo1ZDVj19pbih0bXBfLCBTVERMSUIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytCQVNFTElCW3RtcF9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcImlzaW5zdGFuY2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBmdW5jX2NhbGxfbGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIidpc2luc3RhbmNlJyB0YWtlcyBleGFjdGx5IDIgYXJndW1lbnRzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzdC5CaW5hcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcImluc3RhbmNlb2ZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGFyZ3NbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IFwic3VwZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFMuaW5fc2NvcGVbUy5pbl9zY29wZS5sZW5ndGgtMV0uY2FsbHNTdXBlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKNWQ1Y9faW4odG1wXywgdG9rZW5pemVyLkpTX0tFWVdPUkRTKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIubmFtZSArPSBcIl9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVDYWxsQXJncyhzdWJzY3JpcHRzKG5ldyBhc3QuQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogZnVuY19jYWxsX2xpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgIH0pLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24ga2VlcERlY29yYXRvck9ySW1wb3J0KGV4cHIsIGltcCkge1xuICAgICAgICAgICAgaW1wID0gaW1wID09PSB2b2lkIDAgPyBmYWxzZSA6IGltcDtcbiAgICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgICAgaWYgKGltcCkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5kcm9wSW1wb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZHJvcERlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0cmluZ2lmeU5hbWUoZXhwcikge1xuICAgICAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgYXN0LkRvdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5TmFtZShleHByLmV4cHJlc3Npb24pICsgXCIuXCIgKyBleHByLnByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwci5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGV4cHI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBhc3QuU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGV4cHIubmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIGFzdC5Eb3QpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gc3RyaW5naWZ5TmFtZShleHByKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIGFzdC5DYWxsKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHN0cmluZ2lmeU5hbWUoZXhwci5leHByZXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3JvYWsoXCJVbnN1cHBvcnRlZCBkZWNvcmF0b3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEo1ZDVj19pbihuYW1lLCBvcHRpb25zLmRyb3BJbXBvcnRzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAhKNWQ1Y9faW4obmFtZSwgb3B0aW9ucy5kcm9wRGVjb3JhdG9ycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1heWJlX3VuYXJ5KGFsbG93X2NhbGxzKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQsIGV4cHIsIGV4LCB2YWw7XG4gICAgICAgICAgICBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICBpZiAoaXNfKFwib3BlcmF0b3JcIiwgXCJAXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFMuaW5fZGVjb3JhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiTmVzdGVkIGRlY29yYXRvcnMgYXJlIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgUy5pbl9kZWNvcmF0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICAgICAgICAgIFMuaW5fZGVjb3JhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGtlZXBEZWNvcmF0b3JPckltcG9ydChleHByKSkge1xuICAgICAgICAgICAgICAgICAgICBTLmRlY29yYXRvcnMucHVzaChleHByKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3QuRW1wdHlTdGF0ZW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICBzdHlwZTogXCJAXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcmV2KCksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNfKFwib3BlcmF0b3JcIikgJiYgVU5BUllfUFJFRklYKHN0YXJ0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBleCA9IG1ha2VfdW5hcnkoYXN0LlVuYXJ5UHJlZml4LCBzdGFydC52YWx1ZSwgbWF5YmVfdW5hcnkoYWxsb3dfY2FsbHMpKTtcbiAgICAgICAgICAgICAgICBleC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIGV4LmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWwgPSBleHByX2F0b20oYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgd2hpbGUgKGlzXyhcIm9wZXJhdG9yXCIpICYmIHRva2VuaXplci5VTkFSWV9QT1NURklYKFMudG9rZW4udmFsdWUpICYmICFTLnRva2VuLm5ld2xpbmVfYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gbWFrZV91bmFyeShhc3QuVW5hcnlQb3N0Zml4LCBTLnRva2VuLnZhbHVlLCB2YWwpO1xuICAgICAgICAgICAgICAgIHZhbC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhbC5lbmQgPSBTLnRva2VuO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZV91bmFyeShjdG9yLCBvcCwgZXhwcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlVW5hcnkobmV3IGN0b3Ioe1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVCaW5hcnkoYXN0RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGxlZnQsIHJpZ2h0LCBvcDtcbiAgICAgICAgICAgIGxlZnQgPSBhc3RFbGVtZW50LmxlZnQucmVzb2x2ZVR5cGUoUy5pbl9zY29wZSk7XG4gICAgICAgICAgICByaWdodCA9IGFzdEVsZW1lbnQucmlnaHQucmVzb2x2ZVR5cGUoUy5pbl9zY29wZSk7XG4gICAgICAgICAgICBvcCA9IGFzdEVsZW1lbnQub3BlcmF0b3I7XG4gICAgICAgICAgICBpZiAoISjVkNWPX2luKG9wLCBbIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIFwiPT1cIiwgXCIhPVwiLCBcIj09PVwiLCBcIiE9PVwiLCBcInx8XCIsIFwiJiZcIiwgXCI9XCIgXSkpICYmICghKNWQ1Y9faW4obGVmdCwgWyBcIk51bWJlclwiLCBcIlN0cmluZ1wiLCBcIkJvb2xlYW5cIiwgXCI/XCIgXSkpIHx8ICEo1ZDVj19pbihyaWdodCwgWyBcIk51bWJlclwiLCBcIlN0cmluZ1wiLCBcIkJvb2xlYW5cIiwgXCI/XCIgXSkpIHx8IGxlZnQgPT09IFwiU3RyaW5nXCIgJiYgISjVkNWPX2luKG9wLCBbIFwiK1wiLCBcIis9XCIgXSkpIHx8IHJpZ2h0ID09PSBcIlN0cmluZ1wiICYmICEo1ZDVj19pbihvcCwgWyBcIitcIiwgXCIrPVwiIF0pKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFswXSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBcIkFycmF5XCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdFswXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBcIk9iamVjdFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRbMF0gPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IFwiQXJyYXlcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyaWdodFswXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gXCJPYmplY3RcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBjcm9hayhcImNhbm5vdCBwZXJmb3JtIGJpbmFyeSAnXCIgKyBvcCArIFwiJyBvcGVyYXRpb24gb24gaW5jb21wYXRiaWxlIGVsZW1lbnRzIG9mIHR5cGUgXCIgKyBsZWZ0ICsgXCIgYW5kIFwiICsgcmlnaHQgKyBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhc3RFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlVW5hcnkoYXN0RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQsIG9wO1xuICAgICAgICAgICAgZWxlbWVudCA9IGFzdEVsZW1lbnQuZXhwcmVzc2lvbi5yZXNvbHZlVHlwZShTLmluX3Njb3BlKTtcbiAgICAgICAgICAgIG9wID0gYXN0RWxlbWVudC5vcGVyYXRvcjtcbiAgICAgICAgICAgIGlmICghKNWQ1Y9faW4oZWxlbWVudCwgWyBcIk51bWJlclwiLCBcIj9cIiBdKSkgJiYg1ZDVj19pbihvcCwgWyBcIitcIiwgXCItXCIgXSkgfHwgISjVkNWPX2luKGVsZW1lbnRbMF0sIFsgXCJbXCIsIFwie1wiLCBcIj9cIiBdKSkgJiYgb3AgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRbMF0gPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBcIkFycmF5XCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50WzBdID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gXCJPYmplY3RcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JvYWsoXCJjYW5ub3QgcGVyZm9ybSB1bmFyeSAnXCIgKyBvcCArIFwiJyBvcGVyYXRpb24gb24gaW5jb21wYXRiaWxlIGVsZW1lbnQgb2YgdHlwZSBcIiArIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzdEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVDYWxsQXJncyhhc3RFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIg1ZDVj2l0cjU2LCDVkNWPaWR4NTYsINWQ1Y9pdHI1Nywg1ZDVj2lkeDU3LCDVkNWPaXRyNTgsINWQ1Y9pZHg1OCwg1ZDVj2l0cjU5LCDVkNWPaWR4NTksINWQ1Y91cGs1O1xuICAgICAgICAgICAgdmFyIG5hbWUsIGZvdW5kLCBzY29wZSwgZnVuYywgc2lnbmF0dXJlLCB2YXJpYWJsZSwgYXJncywgaSwgYXJnLCBleHBlY3RlZCwgYWN0dWFsO1xuICAgICAgICAgICAgaWYgKGFzdEVsZW1lbnQuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIGFzdC5TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gYXN0RWxlbWVudC5leHByZXNzaW9uLm5hbWU7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICDVkNWPaXRyNTYgPSDVkNWPX0l0ZXJhYmxlKHJldmVyc2VkKFMuaW5fc2NvcGUpKTtcbiAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHg1NiA9IDA7INWQ1Y9pZHg1NiA8INWQ1Y9pdHI1Ni5sZW5ndGg7INWQ1Y9pZHg1NisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlID0g1ZDVj2l0cjU2W9WQ1Y9pZHg1Nl07XG4gICAgICAgICAgICAgICAgICAgINWQ1Y9pdHI1NyA9INWQ1Y9fSXRlcmFibGUoc2NvcGUuZnVuY3Rpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4NTcgPSAwOyDVkNWPaWR4NTcgPCDVkNWPaXRyNTcubGVuZ3RoOyDVkNWPaWR4NTcrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYyA9INWQ1Y9pdHI1N1vVkNWPaWR4NTddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmMgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBzY29wZS5mdW5jdGlvbnNbZnVuY107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgINWQ1Y9pdHI1OCA9INWQ1Y9fSXRlcmFibGUoc2NvcGUudmFycyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDU4ID0gMDsg1ZDVj2lkeDU4IDwg1ZDVj2l0cjU4Lmxlbmd0aDsg1ZDVj2lkeDU4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0g1ZDVj2l0cjU4W9WQ1Y9pZHg1OF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBzY29wZS52YXJzW2Z1bmNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaWduYXR1cmUgJiYgc2lnbmF0dXJlLnNsaWNlKDAsIDkpID09PSBcIkZ1bmN0aW9uKFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSAvXFwoKC4qKVxcKS8uZXhlYyhzaWduYXR1cmUpWzFdLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmICFhcmdzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBhc3RFbGVtZW50LmFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIkZ1bmN0aW9uICdcIiArIG5hbWUgKyBcIicgdGFrZXMgXCIgKyBhcmdzLmxlbmd0aCArIFwiIGFyZ3VtZW50cywgeWV0IHlvdXIgY2FsbCBjb250YWlucyBcIiArIGFzdEVsZW1lbnQuYXJncy5sZW5ndGggKyBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICDVkNWPaXRyNTkgPSDVkNWPX0l0ZXJhYmxlKGVudW1lcmF0ZShhc3RFbGVtZW50LmFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4NTkgPSAwOyDVkNWPaWR4NTkgPCDVkNWPaXRyNTkubGVuZ3RoOyDVkNWPaWR4NTkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAg1ZDVj3VwazUgPSDVkNWPaXRyNTlb1ZDVj2lkeDU5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSDVkNWPdXBrNVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9INWQ1Y91cGs1WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBhcmdzW2ldLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbCA9IGFyZy5yZXNvbHZlVHlwZShTLmluX3Njb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZCAhPT0gXCI/XCIgJiYgISjVkNWPX2luKGFjdHVhbCwgWyBleHBlY3RlZCwgXCI/XCIgXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJGdW5jdGlvbiAnXCIgKyBuYW1lICsgXCInIGV4cGVjdHMgYXJndW1lbnQgXCIgKyBpICsgXCIgdHlwZSBvZiBcIiArIGV4cGVjdGVkICsgXCIsIGJ1dCB5b3UncmUgcGFzc2luZyBcIiArIGFjdHVhbCArIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzdEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhwcl9vcChsZWZ0LCBtaW5fcHJlYywgbm9faW4pIHtcbiAgICAgICAgICAgIHZhciBvcCwgbm90X2luLCBwcmVjLCByaWdodCwgcmV0O1xuICAgICAgICAgICAgb3AgPSBpc18oXCJvcGVyYXRvclwiKSA/IFMudG9rZW4udmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgbm90X2luID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAob3AgPT09IFwiIVwiICYmIHBlZWsoKS50eXBlID09PSBcIm9wZXJhdG9yXCIgJiYgcGVlaygpLnZhbHVlID09PSBcImluXCIpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgb3AgPSBcImluXCI7XG4gICAgICAgICAgICAgICAgbm90X2luID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcCA9PT0gXCJpblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vX2luKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK0JBU0VMSUJbb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWMgPSBvcCAhPT0gbnVsbCA/IHRva2VuaXplci5QUkVDRURFTkNFW29wXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAocHJlYyAhPT0gbnVsbCAmJiBwcmVjID4gbWluX3ByZWMpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBleHByX29wKG1heWJlX3VuYXJ5KHRydWUpLCBwcmVjLCBub19pbik7XG4gICAgICAgICAgICAgICAgaWYgKNWQ1Y9faW4ob3AsIFsgXCI9PVwiLCBcIiE9XCIgXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKytCQVNFTElCW1wiZXFcIl07XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IG5ldyBhc3QuRGVlcEVxdWFsaXR5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBsZWZ0LnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcmlnaHQuZW5kXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IG5ldyBhc3QuQmluYXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBsZWZ0LnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcmlnaHQuZW5kXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUJpbmFyeShyZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm90X2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IG5ldyBhc3QuVW5hcnlQcmVmaXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGxlZnQuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiByZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHJpZ2h0LmVuZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJfb3AocmV0LCBtaW5fcHJlYywgbm9faW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhwcl9vcHMobm9faW4pIHtcbiAgICAgICAgICAgIHJldHVybiBleHByX29wKG1heWJlX3VuYXJ5KHRydWUpLCAwLCBub19pbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVfY29uZGl0aW9uYWwobm9faW4pIHtcbiAgICAgICAgICAgIHZhciBzdGFydCwgZXhwciwgeWVzO1xuICAgICAgICAgICAgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgZXhwciA9IGV4cHJfb3BzKG5vX2luKTtcbiAgICAgICAgICAgIGlmIChpc18oXCJvcGVyYXRvclwiLCBcIj9cIikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgeWVzID0gZXhwcmVzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzdC5Db25kaXRpb25hbCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uOiBleHByLFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW50OiB5ZXMsXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBleHByZXNzaW9uKGZhbHNlLCBub19pbiksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcGVlaygpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Fzc2lnbmFibGUoZXhwcikge1xuICAgICAgICAgICAgdmFyINWQ1Y9pdHI2MCwg1ZDVj2lkeDYwO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIGFzdC5TeW1ib2xSZWYgfHwgZXhwciBpbnN0YW5jZW9mIGFzdC5Qcm9wQWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIGFzdC5BcnJheSkge1xuICAgICAgICAgICAgICAgINWQ1Y9pdHI2MCA9INWQ1Y9fSXRlcmFibGUoZXhwci5lbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4NjAgPSAwOyDVkNWPaWR4NjAgPCDVkNWPaXRyNjAubGVuZ3RoOyDVkNWPaWR4NjArKykge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0g1ZDVj2l0cjYwW9WQ1Y9pZHg2MF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBc3NpZ25hYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIGFzdC5TZXEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBc3NpZ25hYmxlKGV4cHIuY2FyKSAmJiBpc0Fzc2lnbmFibGUoZXhwci5jZHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXliZV9hc3NpZ24obm9faW4pIHtcbiAgICAgICAgICAgIHZhciBzdGFydCwgbGVmdCwgdmFsLCByaWdodDtcbiAgICAgICAgICAgIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgICAgIGxlZnQgPSBtYXliZV9jb25kaXRpb25hbChub19pbik7XG4gICAgICAgICAgICB2YWwgPSBTLnRva2VuLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzXyhcIm9wZXJhdG9yXCIpICYmIEFTU0lHTk1FTlQodmFsKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Fzc2lnbmFibGUobGVmdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBhc3QuU3ltYm9sUmVmICYmIHZhbCAhPT0gXCI9XCIgJiYgISjVkNWPX2luKGxlZnQubmFtZSwgUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0xXS52YXJzKSkgJiYgKCFTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTFdLmFyZ3MgfHwgISjVkNWPX2luKGxlZnQubmFtZSwgUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0xXS5hcmdzKSkpICYmICEo1ZDVj19pbihsZWZ0Lm5hbWUsIFMuaW5fc2NvcGVbUy5pbl9zY29wZS5sZW5ndGgtMV0ubm9ubG9jYWwpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJBdHRlbXB0aW5nIHRvIGluY3JlbWVudC9tb2RpZnkgdW5pbml0aWFsaXplZCB2YXJpYWJsZSAnXCIgKyBsZWZ0Lm5hbWUgKyBcIicsIHRoaXMgY2FuIGFsc28gb2NjdXIgaWYgeW91J3JlIHRyeWluZyB0byBzaGFkb3cgd2l0aG91dCBpbml0aWFsaXppbmcgdGhlIHZhcmlhYmxlIGluIGxvY2FsIHNjb3BlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWF5YmVfYXNzaWduKG5vX2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFTLmluX3NlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya19sb2NhbF9hc3NpZ25tZW50KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVCaW5hcnkobmV3IGFzdC5Bc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNyb2FrKFwiSW52YWxpZCBhc3NpZ25tZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhwcmVzc2lvbihjb21tYXMsIG5vX2luKSB7XG4gICAgICAgICAgICB2YXIg1ZDVj2l0cjYxLCDVkNWPaWR4NjEsINWQ1Y91cGs2LCDVkNWPaXRyNjIsINWQ1Y9pZHg2Miwg1ZDVj3Vwazc7XG4gICAgICAgICAgICB2YXIgc3RhcnQsIGV4cHIsIGxlZnQsIGxlZnRBc3QsIHJpZ2h0LCBpbmRleCwgZWxlbWVudCwgc2VxO1xuICAgICAgICAgICAgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgZXhwciA9IG1heWJlX2Fzc2lnbihub19pbik7XG4gICAgICAgICAgICBpZiAoY29tbWFzKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IFsgZXhwciBdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpc18oXCJwdW5jXCIsIFwiLFwiKSAmJiAhcGVlaygpLm5ld2xpbmVfYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIFMuaW5fc2VxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIGFzdC5Bc3NpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRbbGVmdC5sZW5ndGgtMV0gPSBsZWZ0W2xlZnQubGVuZ3RoLTFdLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFswXSBpbnN0YW5jZW9mIGFzdC5TZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFzdCA9IHNlcV90b19hcnJheShsZWZ0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXN0ID0gbGVmdFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBc3QgPSBuZXcgYXN0LkFycmF5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gc2VxX3RvX2FycmF5KG5ldyBhc3QuU2VxKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXI6IGV4cHIucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2RyOiBleHByZXNzaW9uKHRydWUsIG5vX2luKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjYxID0g1ZDVj19JdGVyYWJsZShlbnVtZXJhdGUobGVmdEFzdC5lbGVtZW50cykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4NjEgPSAwOyDVkNWPaWR4NjEgPCDVkNWPaXRyNjEubGVuZ3RoOyDVkNWPaWR4NjErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgINWQ1Y91cGs2ID0g1ZDVj2l0cjYxW9WQ1Y9pZHg2MV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSDVkNWPdXBrNlswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0g1ZDVj3VwazZbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya19sb2NhbF9hc3NpZ25tZW50KGVsZW1lbnQsIHJpZ2h0LmVsZW1lbnRzW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzdC5Bc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0QXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBleHByLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHBlZWsoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhwciA9IG1heWJlX2Fzc2lnbihub19pbik7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQucHVzaChleHByKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUy5pbl9zZXEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIGFzdC5Bc3NpZ24gJiYgZXhwci5sZWZ0IGluc3RhbmNlb2YgYXN0LlNlcSkge1xuICAgICAgICAgICAgICAgICAgICBleHByLmxlZnQgPSBzZXFfdG9fYXJyYXkoZXhwci5sZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQubGVuZ3RoID4gMSAmJiBsZWZ0W2xlZnQubGVuZ3RoLTFdIGluc3RhbmNlb2YgYXN0LkFzc2lnbikge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0W2xlZnQubGVuZ3RoLTFdID0gbGVmdFtsZWZ0Lmxlbmd0aC0xXS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICDVkNWPaXRyNjIgPSDVkNWPX0l0ZXJhYmxlKGVudW1lcmF0ZShsZWZ0KSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDYyID0gMDsg1ZDVj2lkeDYyIDwg1ZDVj2l0cjYyLmxlbmd0aDsg1ZDVj2lkeDYyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgINWQ1Y91cGs3ID0g1ZDVj2l0cjYyW9WQ1Y9pZHg2Ml07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9INWQ1Y91cGs3WzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9INWQ1Y91cGs3WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya19sb2NhbF9hc3NpZ25tZW50KGVsZW1lbnQsIGV4cHIucmlnaHQgaW5zdGFuY2VvZiBhc3QuQXJyYXkgPyBleHByLnJpZ2h0LmVsZW1lbnRzW2luZGV4XSA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXN0LkFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBuZXcgYXN0LkFycmF5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogbGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogZXhwci5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBleHByLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwZWVrKClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlcSA9IGZ1bmN0aW9uIGJ1aWxkX3NlcShhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciDVkNWPaXRyNjMsINWQ1Y9pZHg2Mywg1ZDVj3Vwazg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdCwgaW5kZXgsIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gYS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBhc3QuQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QubGVmdCBpbnN0YW5jZW9mIGFzdC5BcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgINWQ1Y9pdHI2MyA9INWQ1Y9fSXRlcmFibGUoZW51bWVyYXRlKGZpcnN0LmxlZnQuZWxlbWVudHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHg2MyA9IDA7INWQ1Y9pZHg2MyA8INWQ1Y9pdHI2My5sZW5ndGg7INWQ1Y9pZHg2MysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgINWQ1Y91cGs4ID0g1ZDVj2l0cjYzW9WQ1Y9pZHg2M107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0g1ZDVj3VwazhbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSDVkNWPdXBrOFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya19sb2NhbF9hc3NpZ25tZW50KGVsZW1lbnQsIGZpcnN0LnJpZ2h0IGluc3RhbmNlb2YgYXN0LkFycmF5ID8gZmlyc3QucmlnaHQuZWxlbWVudHNbaW5kZXhdIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzdC5TZXEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyOiBmaXJzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNkcjogYnVpbGRfc2VxKGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwZWVrKClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfShsZWZ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5fbG9vcChjb250KSB7XG4gICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgKytTLmluX2xvb3A7XG4gICAgICAgICAgICByZXQgPSBjb250KCk7XG4gICAgICAgICAgICAtLVMuaW5fbG9vcDtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyINWQ1Y9pdHI2NCwg1ZDVj2lkeDY0O1xuICAgICAgICAgICAgdmFyIHN0YXJ0LCBib2R5LCBkb2NzdHJpbmcsIGZpcnN0X3Rva2VuLCBlbGVtZW50LCBzaGViYW5nLCBlbmQsIHRvcGxldmVsLCBhc3NpZ25tZW50cywgY2FsbGFibGVzLCBpdGVtO1xuICAgICAgICAgICAgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgYm9keSA9IFtdO1xuICAgICAgICAgICAgZG9jc3RyaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGZpcnN0X3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICghaXNfKFwiZW9mXCIpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHN0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdF90b2tlbiAmJiBlbGVtZW50IGluc3RhbmNlb2YgYXN0LkRpcmVjdGl2ZSAmJiBlbGVtZW50LnZhbHVlLmluZGV4T2YoXCIjIVwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaGViYW5nID0gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFib2R5Lmxlbmd0aCAmJiBpc19kb2NzdHJpbmcoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRyb3BEb2NzdHJpbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NzdHJpbmcgPSBmb3JtYXRfZG9jc3RyaW5nKGVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaXJzdF90b2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kID0gcHJldigpO1xuICAgICAgICAgICAgdG9wbGV2ZWwgPSBvcHRpb25zLnRvcGxldmVsO1xuICAgICAgICAgICAgaWYgKHRvcGxldmVsKSB7XG4gICAgICAgICAgICAgICAgdG9wbGV2ZWwuYm9keSA9IHRvcGxldmVsLmJvZHkuY29uY2F0KGJvZHkpO1xuICAgICAgICAgICAgICAgIHRvcGxldmVsLmVuZCA9IGVuZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9wbGV2ZWwgPSBuZXcgYXN0LlRvcExldmVsKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNoZWJhbmc6IHNoZWJhbmcsXG4gICAgICAgICAgICAgICAgICAgIGRvY3N0cmluZzogZG9jc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdW5pcShlbGVtZW50LCBpbmRleCwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyci5sYXN0SW5kZXhPZihlbGVtZW50KSA9PT0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3BsZXZlbC5ub25sb2NhbHZhcnMgPSBPYmplY3Qua2V5cyhTLmluX3Njb3BlW1MuaW5fc2NvcGUubGVuZ3RoLTFdLm5vbmxvY2FsKTtcbiAgICAgICAgICAgIGFzc2lnbm1lbnRzID0gT2JqZWN0LmtleXMoUy5pbl9zY29wZVtTLmluX3Njb3BlLmxlbmd0aC0xXS52YXJzKTtcbiAgICAgICAgICAgIGNhbGxhYmxlcyA9IHNjYW5fZm9yX3RvcF9sZXZlbF9jYWxsYWJsZXModG9wbGV2ZWwuYm9keSkuZmlsdGVyKHVuaXEpO1xuICAgICAgICAgICAgdG9wbGV2ZWwubG9jYWx2YXJzID0gW107XG4gICAgICAgICAgICDVkNWPaXRyNjQgPSDVkNWPX0l0ZXJhYmxlKGFzc2lnbm1lbnRzKTtcbiAgICAgICAgICAgIGZvciAo1ZDVj2lkeDY0ID0gMDsg1ZDVj2lkeDY0IDwg1ZDVj2l0cjY0Lmxlbmd0aDsg1ZDVj2lkeDY0KyspIHtcbiAgICAgICAgICAgICAgICBpdGVtID0g1ZDVj2l0cjY0W9WQ1Y9pZHg2NF07XG4gICAgICAgICAgICAgICAgaWYgKCEo1ZDVj19pbihpdGVtLCB0b3BsZXZlbC5ub25sb2NhbHZhcnMpKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BsZXZlbC5sb2NhbHZhcnMucHVzaChuZXdfc3ltYm9sKGFzdC5TeW1ib2xWYXIsIGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3BsZXZlbC5leHBvcnRzID0gdG9wbGV2ZWwubG9jYWx2YXJzLmNvbmNhdChjYWxsYWJsZXMpLmZpbHRlcih1bmlxKTtcbiAgICAgICAgICAgIHRvcGxldmVsLnN1Ym1vZHVsZXMgPSBbXTtcbiAgICAgICAgICAgIHRvcGxldmVsLmNsYXNzZXMgPSBDTEFTU19NQVA7XG4gICAgICAgICAgICB0b3BsZXZlbC5pbXBvcnRfb3JkZXIgPSBPYmplY3Qua2V5cyhJTVBPUlRFRCkubGVuZ3RoO1xuICAgICAgICAgICAgdG9wbGV2ZWwubW9kdWxlX2lkID0gbW9kdWxlX2lkO1xuICAgICAgICAgICAgSU1QT1JURURbbW9kdWxlX2lkXSA9IHRvcGxldmVsO1xuICAgICAgICAgICAgdG9wbGV2ZWwuaW1wb3J0cyA9IElNUE9SVEVEO1xuICAgICAgICAgICAgdG9wbGV2ZWwuYmFzZWxpYiA9IEJBU0VMSUI7XG4gICAgICAgICAgICBJTVBPUlRJTkdbbW9kdWxlX2lkXSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRvcGxldmVsO1xuICAgICAgICB9KCk7XG4gICAgfVxuICAgINWQ1Y9fbW9kdWxlc1tcInBhcnNlclwiXVtcIk5BVElWRV9DTEFTU0VTXCJdID0gTkFUSVZFX0NMQVNTRVM7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJwYXJzZXJcIl1bXCJDT01NT05fU1RBVElDXCJdID0gQ09NTU9OX1NUQVRJQztcblxuICAgINWQ1Y9fbW9kdWxlc1tcInBhcnNlclwiXVtcIkNMQVNTX01BUFwiXSA9IENMQVNTX01BUDtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInBhcnNlclwiXVtcImtleVwiXSA9IGtleTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInBhcnNlclwiXVtcIkJBU0VMSUJcIl0gPSBCQVNFTElCO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wicGFyc2VyXCJdW1wiU1RETElCXCJdID0gU1RETElCO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wicGFyc2VyXCJdW1wiVU5BUllfUFJFRklYXCJdID0gVU5BUllfUFJFRklYO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wicGFyc2VyXCJdW1wiQVNTSUdOTUVOVFwiXSA9IEFTU0lHTk1FTlQ7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJwYXJzZXJcIl1bXCJTVEFURU1FTlRTX1dJVEhfTEFCRUxTXCJdID0gU1RBVEVNRU5UU19XSVRIX0xBQkVMUztcblxuICAgINWQ1Y9fbW9kdWxlc1tcInBhcnNlclwiXVtcIkFUT01JQ19TVEFSVF9UT0tFTlwiXSA9IEFUT01JQ19TVEFSVF9UT0tFTjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInBhcnNlclwiXVtcImFycmF5X3RvX2hhc2hcIl0gPSBhcnJheV90b19oYXNoO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wicGFyc2VyXCJdW1wiaGFzX3NpbXBsZV9kZWNvcmF0b3JcIl0gPSBoYXNfc2ltcGxlX2RlY29yYXRvcjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInBhcnNlclwiXVtcInBhcnNlXCJdID0gcGFyc2U7XG59KSgpO1xuXG4oZnVuY3Rpb24oKXtcbiAgICB2YXIgX19uYW1lX18gPSBcIl9iYXNlbGliXCI7XG4gICAgdmFyIEJBU0VMSUI7XG4gICAgQkFTRUxJQiA9ICdcIlwiXCJcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuXFxuICBBIFJhcHlkU2NyaXB0IHRvIEphdmFTY3JpcHQgY29tcGlsZXIuXFxuICBodHRwczovL2dpdGh1Yi5jb20vYXRzZXBrb3YvUmFweWRTY3JpcHRcXG5cXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogQWxleGFuZGVyIFRzZXBrb3ZcXG4gICAgICAgICAgICAgICAgICAgICAgICAgPGF0c2Vwa292QHB5amVvbi5jb20+XFxuICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly93d3cucHlqZW9uLmNvbVxcblxcbiAgRGlzdHJpYnV0ZWQgdW5kZXIgQlNEIGxpY2Vuc2U6XFxuICAgIENvcHlyaWdodCAyMDEzIChjKSBBbGV4YW5kZXIgVHNlcGtvdiA8YXRzZXBrb3ZAcHlqZW9uLmNvbT5cXG5cXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcblwiXCJcIlxcblxcblxcbiMgZm9yIGNvbnZlbmllbmNlIHdlXFwnbGwgdXNlIGEgY29udmVudGlvbiBoZXJlIHRoYXQgd2lsbCB3b3JrIGFzIGZvbGxvd3M6XFxuI1xcbiMgICBpZiBmdW5jdGlvbiBpcyBuYW1lZCwgYXNzdW1lIHdlXFwnbGwgYmUgb3V0cHV0dGluZyB0aGUgZnVuY3Rpb24gaXRzZWxmXFxuIyAgIGlmIHRoZSBnaXZlbiBiYXNlbGliIGNodW5rIGlzIHRyaWdnZXJlZFxcbiNcXG4jICAgaWYgZnVuY3Rpb24gaXMgdW5uYW1lZCwgYXNzdW1lIHRoZSBmdW5jdGlvbiBpcyBhIGNvbnRhaW5lciBmb3IgdGhlIGxvZ2ljXFxuIyAgIHRvIGJlIG91dHB1dC4gV2VcXCdyZSBiYXNpY2FsbHkgaWdub3JpbmcgdGhlIHdyYXBwZXIgYW5kIGR1bXBpbmcgd2hhdFxcJ3MgaW5zaWRlXFxuXFxue1xcblwiYWJzXCI6IGRlZiBhYnMobik6XFxuICAgIHJldHVybiBNYXRoLmFicyhuKVxcbixcXG5cImFsbFwiOiBkZWYgYWxsKGEpOlxcbiAgICBmb3IgZSBpbiBhOlxcbiAgICAgICAgaWYgbm90IGU6IHJldHVybiBGYWxzZVxcbiAgICByZXR1cm4gVHJ1ZVxcbixcXG5cImFueVwiOiBkZWYgYW55KGEpOlxcbiAgICBmb3IgZSBpbiBhOlxcbiAgICAgICAgaWYgZTogcmV0dXJuIFRydWVcXG4gICAgcmV0dXJuIEZhbHNlXFxuLFxcblwiYmluXCI6IGRlZiBiaW4oYSk6IHJldHVybiBcXCcwYlxcJyArIChhID4+PiAwKS50b1N0cmluZygyKVxcbixcXG5cImJpbmRcIjogZGVmINWQ1Y9fYmluZChmbiwgdGhpc0FyZyk6XFxuICAgIGlmIGZuLm9yaWc6IGZuID0gZm4ub3JpZ1xcbiAgICBpZiB0aGlzQXJnIGlzIEZhbHNlOiByZXR1cm4gZm5cXG4gICAgcmV0ID0gZGVmKCk6XFxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKVxcbiAgICByZXQub3JpZyA9IGZuXFxuICAgIHJldHVybiByZXRcXG4sXFxuXCJyZWJpbmRfYWxsXCI6IGRlZiDVkNWPX3JlYmluZEFsbCh0aGlzQXJnLCByZWJpbmQpOlxcbiAgICBpZiByZWJpbmQgaXMgdW5kZWZpbmVkOiByZWJpbmQgPSBUcnVlXFxuICAgIGZvciBKUyhcXCd2YXIgcCBpbiB0aGlzQXJnXFwnKTpcXG4gICAgICAgIGlmIHRoaXNBcmdbcF0gYW5kIHRoaXNBcmdbcF0ub3JpZzpcXG4gICAgICAgICAgICBpZiByZWJpbmQ6IHRoaXNBcmdbcF0gPSBiaW5kKHRoaXNBcmdbcF0sIHRoaXNBcmcpXFxuICAgICAgICAgICAgZWxzZTogdGhpc0FyZ1twXSA9IHRoaXNBcmdbcF0ub3JpZ1xcbixcXG5cImNtcFwiOiBkZWYgY21wKGEsIGIpOiByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDBcXG4sXFxuXCJjaHJcIjogZGVmKCk6IGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGVcXG4sXFxuXCJkaXJcIjogZGVmIGRpcihpdGVtKTpcXG4gICAgIyBUT0RPOiB0aGlzIGlzblxcJ3QgcmVhbGx5IHJlcHJlc2VudGF0aXZlIG9mIHJlYWwgUHl0aG9uXFwncyBkaXIoKSwgbm9yIGlzIGl0XFxuICAgICMgYW4gaW50dWl0aXZlIHJlcGxhY2VtZW50IGZvciBcImZvciAuLi4gaW5cIiBsb29wLCBuZWVkIHRvIHVwZGF0ZSB0aGlzIGxvZ2ljXFxuICAgICMgYW5kIGludHJvZHVjZSBhIGRpZmZlcmVudCB3YXkgb2YgYWNoaWV2aW5nIFwiZm9yIC4uLiBpblwiXFxuICAgIGFyciA9IFtdXFxuICAgIGZvciBKUyhcXCd2YXIgaSBpbiBpdGVtXFwnKTogYXJyLnB1c2goaSlcXG4gICAgcmV0dXJuIGFyclxcbixcXG5cImVudW1lcmF0ZVwiOiBkZWYgZW51bWVyYXRlKGl0ZW0pOlxcbiAgICBhcnIgPSBbXVxcbiAgICBpdGVyID0g1ZDVj19JdGVyYWJsZShpdGVtKVxcbiAgICBmb3IgaSBpbiByYW5nZShpdGVyLmxlbmd0aCk6XFxuICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBbaSwgaXRlbVtpXV1cXG4gICAgcmV0dXJuIGFyclxcbixcXG5cImVzbGljZVwiOiBkZWYg1ZDVj19lc2xpY2UoYXJyLCBzdGVwLCBzdGFydCwgZW5kKTpcXG4gICAgYXJyID0gYXJyWzpdXFxuICAgIGlmIEpTKFxcJ3R5cGVvZiBhcnJcXCcpIGlzIFxcJ3N0cmluZ1xcJyBvciBpc2luc3RhbmNlKGFyciwgU3RyaW5nKTpcXG4gICAgICAgIGlzU3RyaW5nID0gVHJ1ZVxcbiAgICAgICAgYXJyID0gYXJyLnNwbGl0KFxcJ1xcJylcXG5cXG4gICAgaWYgc3RlcCA8IDA6XFxuICAgICAgICBzdGVwID0gLXN0ZXBcXG4gICAgICAgIGFyci5yZXZlcnNlKClcXG4gICAgICAgIGlmIEpTKFxcJ3R5cGVvZiBzdGFydFxcJykgaXMgbm90IFwidW5kZWZpbmVkXCI6IHN0YXJ0ID0gYXJyLmxlbmd0aCAtIHN0YXJ0IC0gMVxcbiAgICAgICAgaWYgSlMoXFwndHlwZW9mIGVuZFxcJykgaXMgbm90IFwidW5kZWZpbmVkXCI6IGVuZCA9IGFyci5sZW5ndGggLSBlbmQgLSAxXFxuICAgIGlmIEpTKFxcJ3R5cGVvZiBzdGFydFxcJykgaXMgXCJ1bmRlZmluZWRcIjogc3RhcnQgPSAwXFxuICAgIGlmIEpTKFxcJ3R5cGVvZiBlbmRcXCcpIGlzIFwidW5kZWZpbmVkXCI6IGVuZCA9IGFyci5sZW5ndGhcXG5cXG4gICAgYXJyID0gYXJyLnNsaWNlKHN0YXJ0LCBlbmQpLmZpbHRlcihkZWYoZSwgaSk6IHJldHVybiBpICUgc3RlcCBpcyAwOylcXG4gICAgcmV0dXJuIGlzU3RyaW5nID8gYXJyLmpvaW4oXFwnXFwnKSA6IGFyclxcbixcXG5cImV4dGVuZHNcIjogZGVmINWQ1Y9fZXh0ZW5kcyhjaGlsZCwgcGFyZW50KTpcXG4gICAgY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKVxcbiAgICBjaGlsZC5wcm90b3R5cGUuX19iYXNlX18gPSBwYXJlbnQgICAgICMgc2luY2Ugd2UgZG9uXFwndCBzdXBwb3J0IG11bHRpcGxlIGluaGVyaXRhbmNlLCBfX2Jhc2VfXyBzZWVtZWQgbW9yZSBhcHByb3ByaWF0ZSB0aGFuIF9fYmFzZXNfXyBhcnJheSBvZiAxXFxuICAgIGNoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNoaWxkXFxuLFxcblwiZmlsdGVyXCI6IGRlZiBmaWx0ZXIob3BlciwgYXJyKTpcXG4gICAgcmV0dXJuIGFyci5maWx0ZXIob3BlcilcXG4sXFxuXCJoZXhcIjogZGVmIGhleChhKTogcmV0dXJuIFxcJzB4XFwnICsgKGEgPj4+IDApLnRvU3RyaW5nKDE2KVxcbixcXG5cImluXCI6IGRlZiDVkNWPX2luKHZhbCwgYXJyKTpcXG4gICAgaWYgSlMoXFwndHlwZW9mIGFyci5pbmRleE9mXFwnKSBpcyBcXCdmdW5jdGlvblxcJzogcmV0dXJuIGFyci5pbmRleE9mKHZhbCkgaXMgbm90IC0xXFxuICAgIHJldHVybiBhcnIuaGFzT3duUHJvcGVydHkodmFsKVxcbixcXG5cIml0ZXJhYmxlXCI6IGRlZiDVkNWPX0l0ZXJhYmxlKGl0ZXJhYmxlKTpcXG4gICAgIyBjYW5cXCd0IHVzZSBTeW1ib2wuaXRlcmF0b3IgeWV0IHNpbmNlIGl0XFwncyBub3Qgc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMgdW50aWwgRVM2IChpLmUuIG1vYmlsZSBicm93c2VycyBkb25cXCd0IGhhdmUgaXQpXFxuICAgIGlmIGl0ZXJhYmxlLmNvbnN0cnVjdG9yIGlzIFtdLmNvbnN0cnVjdG9yXFxuICAgIG9yIGl0ZXJhYmxlLmNvbnN0cnVjdG9yIGlzIFxcJ1xcJy5jb25zdHJ1Y3RvclxcbiAgICBvciAodG1wID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaXRlcmFibGUpKS5sZW5ndGg6XFxuICAgICAgICByZXR1cm4gdG1wIG9yIGl0ZXJhYmxlXFxuICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVyYWJsZSkgICAgIyBzbyB3ZSBjYW4gdXNlIFxcJ2ZvciAuLi4gaW5cXCcgc3ludGF4IHdpdGggaGFzaGVzXFxuLFxcblwibGVuXCI6IGRlZiBsZW4ob2JqKTpcXG4gICAgIyBjYW5cXCd0IHVzZSBTeW1ib2wuaXRlcmF0b3IgeWV0IHNpbmNlIGl0XFwncyBub3Qgc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMgdW50aWwgRVM2IChpLmUuIG1vYmlsZSBicm93c2VycyBkb25cXCd0IGhhdmUgaXQpXFxuICAgIGlmIG9iai5jb25zdHJ1Y3RvciBpcyBbXS5jb25zdHJ1Y3RvclxcbiAgICBvciBvYmouY29uc3RydWN0b3IgaXMgXFwnXFwnLmNvbnN0cnVjdG9yXFxuICAgIG9yICh0bXAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopKS5sZW5ndGg6XFxuICAgICAgICByZXR1cm4gKHRtcCBvciBvYmopLmxlbmd0aFxcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGhcXG4sXFxuXCJtYXBcIjogZGVmIG1hcChvcGVyLCBhcnIpOlxcbiAgICByZXR1cm4gYXJyLm1hcChvcGVyKVxcbixcXG5cIm1heFwiOiBkZWYgbWF4KGEpOlxcbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgQXJyYXkuaXNBcnJheShhKSA/IGEgOiBhcmd1bWVudHMpXFxuLFxcblwibWluXCI6IGRlZiBtaW4oYSk6XFxuICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShudWxsLCBBcnJheS5pc0FycmF5KGEpID8gYSA6IGFyZ3VtZW50cylcXG4sXFxuXCJtZXJnZVwiOiBkZWYg1ZDVj19tZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3ZlcndyaXRlKTpcXG4gICAgZm9yIEpTKFxcJ3ZhciBpIGluIHNvdXJjZVxcJyk6XFxuICAgICAgICAjIGluc3RhbmNlIHZhcmlhYmxlc1xcbiAgICAgICAgaWYgc291cmNlLmhhc093blByb3BlcnR5KGkpIGFuZCAob3ZlcndyaXRlIG9yIEpTKFxcJ3R5cGVvZiB0YXJnZXRbaV1cXCcpIGlzIFxcJ3VuZGVmaW5lZFxcJyk6IHRhcmdldFtpXSA9IHNvdXJjZVtpXVxcbiAgICBmb3IgcHJvcCBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UucHJvdG90eXBlKTpcXG4gICAgICAgICMgbWV0aG9kc1xcbiAgICAgICAgaWYgb3ZlcndyaXRlIG9yIEpTKFxcJ3R5cGVvZiB0YXJnZXQucHJvdG90eXBlW3Byb3BdXFwnKSBpcyBcXCd1bmRlZmluZWRcXCc6IHRhcmdldC5wcm90b3R5cGVbcHJvcF0gPSBzb3VyY2UucHJvdG90eXBlW3Byb3BdXFxuLFxcblwibWl4aW5cIjogZGVmINWQ1Y9fbWl4aW4oKmNsYXNzZXMpOlxcbiAgICByZXR1cm4gZGVmKGJhc2VDbGFzcyk6XFxuICAgICAgICBmb3IgY2xzIGluIGNsYXNzZXM6XFxuICAgICAgICAgICAgZm9yIGtleSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjbHMucHJvdG90eXBlKTpcXG4gICAgICAgICAgICAgICAgaWYga2V5IG5vdCBpbiBiYXNlQ2xhc3MucHJvdG90eXBlOlxcbiAgICAgICAgICAgICAgICAgICAgYmFzZUNsYXNzLnByb3RvdHlwZVtrZXldID0gY2xzLnByb3RvdHlwZVtrZXldXFxuICAgICAgICByZXR1cm4gYmFzZUNsYXNzXFxuXFxuLFxcblwicHJpbnRcIjogZGVmINWQ1Y9fcHJpbnQoKTpcXG4gICAgaWYgSlMoXFwndHlwZW9mIGNvbnNvbGVcXCcpIGlzIFxcJ29iamVjdFxcJzogY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxcbixcXG5cInJhbmdlXCI6IGRlZiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCk6XFxuICAgIGlmIGFyZ3VtZW50cy5sZW5ndGggPD0gMTpcXG4gICAgICAgIHN0b3AgPSBzdGFydCBvciAwXFxuICAgICAgICBzdGFydCA9IDBcXG4gICAgc3RlcCA9IGFyZ3VtZW50c1syXSBvciAxXFxuXFxuICAgIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKVxcbiAgICBpZHggPSAwXFxuICAgIHJhbmdlID0gQXJyYXkobGVuZ3RoKVxcblxcbiAgICB3aGlsZSBpZHggPCBsZW5ndGg6XFxuICAgICAgICByYW5nZVtKUyhcXCdpZHgrK1xcJyldID0gc3RhcnRcXG4gICAgICAgIHN0YXJ0ICs9IHN0ZXBcXG4gICAgcmV0dXJuIHJhbmdlXFxuLFxcblwicmVkdWNlXCI6IGRlZiByZWR1Y2UoZiwgYSk6IHJldHVybiBBcnJheS5yZWR1Y2UoYSwgZilcXG4sXFxuXCJyZXZlcnNlZFwiOiBkZWYgcmV2ZXJzZWQoYXJyKTpcXG4gICAgdG1wID0gYXJyWzpdXFxuICAgIHJldHVybiB0bXAucmV2ZXJzZSgpXFxuLFxcblwic29ydGVkXCI6IGRlZiBzb3J0ZWQoYXJyKTpcXG4gICAgdG1wID0gYXJyWzpdXFxuICAgIHJldHVybiB0bXAuc29ydCgpXFxuLFxcblwic3VtXCI6IGRlZiBzdW0oYXJyLCBzdGFydD0wKTpcXG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoXFxuICAgICAgICBkZWYocHJldiwgY3VyKTogcmV0dXJuIHByZXYrY3VyXFxuICAgICAgICAsXFxuICAgICAgICBzdGFydFxcbiAgICApXFxuLFxcblwidHlwZVwiOiBkZWYg1ZDVj190eXBlKG9iaik6XFxuICAgIHJldHVybiBvYmogYW5kIG9iai5jb25zdHJ1Y3RvciBhbmQgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPyBvYmouY29uc3RydWN0b3IubmFtZSA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopLnNsaWNlKDgsIC0xKVxcbixcXG5cInppcFwiOiBkZWYgemlwKGEsIGIpOlxcbiAgICByZXR1cm4gW1thW2ldLCBiW2ldXSBmb3IgaSBpbiByYW5nZShNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpKV1cXG4sXFxuXCJnZXRhdHRyXCI6IGRlZiBnZXRhdHRyKG9iaiwgbmFtZSk6XFxuICAgIHJldHVybiBvYmpbbmFtZV1cXG4sXFxuXCJzZXRhdHRyXCI6IGRlZiBzZXRhdHRyKG9iaiwgbmFtZSwgdmFsdWUpOlxcbiAgICBvYmpbbmFtZV0gPSB2YWx1ZVxcbixcXG5cImhhc2F0dHJcIjogZGVmIGhhc2F0dHIob2JqLCBuYW1lKTpcXG4gICAgcmV0dXJuIEpTKFxcJ25hbWUgaW4gb2JqXFwnKVxcbixcXG5cImVxXCI6IGRlZiDVkNWPX2VxKGEsIGIpOlxcbiAgICBcIlwiXCJcXG4gICAgRXF1YWxpdHkgY29tcGFyaXNvbiB0aGF0IHdvcmtzIHdpdGggYWxsIGRhdGEgdHlwZXMsIHJldHVybnMgdHJ1ZSBpZiBzdHJ1Y3R1cmUgYW5kXFxuICAgIGNvbnRlbnRzIG9mIGZpcnN0IG9iamVjdCBlcXVhbCB0byB0aG9zZSBvZiBzZWNvbmQgb2JqZWN0XFxuXFxuICAgIEFyZ3VtZW50czpcXG4gICAgICAgIGE6IGZpcnN0IG9iamVjdFxcbiAgICAgICAgYjogc2Vjb25kIG9iamVjdFxcbiAgICBcIlwiXCJcXG4gICAgaWYgYSBpcyBiOlxcbiAgICAgICAgIyBzaW1wbGUgb2JqZWN0XFxuICAgICAgICByZXR1cm4gVHJ1ZVxcblxcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSBhbmQgQXJyYXkuaXNBcnJheShiKSkgb3IgKGlzaW5zdGFuY2UoYSwgT2JqZWN0KSBhbmQgaXNpbnN0YW5jZShiLCBPYmplY3QpKTpcXG4gICAgICAgICMgaWYgbGVuZ3RoIG90IHR5cGUgZG9lc25cXCd0IG1hdGNoLCB0aGV5IGNhblxcJ3QgYmUgZXF1YWxcXG4gICAgICAgIGlmIGEuY29uc3RydWN0b3IgaXMgbm90IGIuY29uc3RydWN0b3Igb3IgYS5sZW5ndGggaXMgbm90IGIubGVuZ3RoOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcblxcbiAgICAgICAgaWYgQXJyYXkuaXNBcnJheShhKTpcXG4gICAgICAgICAgICAjIGFycmF5c1xcbiAgICAgICAgICAgIGZvciBpIGluIHJhbmdlKGEubGVuZ3RoKTpcXG4gICAgICAgICAgICAgICAgaWYgbm90INWQ1Y9fZXEoYVtpXSwgYltpXSk6XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsc2VcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgIyBoYXNoZXNcXG4gICAgICAgICAgICAjIGNvbXBhcmUgaW5kaXZpZHVhbCBwcm9wZXJ0aWVzIChvcmRlciBkb2VzblxcJ3QgbWF0dGVyIGlmIGl0XFwncyBhIGhhc2gpXFxuICAgICAgICAgICAgaWYgT2JqZWN0LmtleXMoYSkubGVuZ3RoIGlzIG5vdCBPYmplY3Qua2V5cyhiKS5sZW5ndGg6IHJldHVybiBGYWxzZVxcbiAgICAgICAgICAgIGZvciBpIGluIGE6XFxuICAgICAgICAgICAgICAgICMgcmVjdXJzaXZlbHkgdGVzdCBlcXVhbGl0eSBvZiBvYmplY3QgY2hpbGRyZW5cXG4gICAgICAgICAgICAgICAgaWYgbm90INWQ1Y9fZXEoYVtpXSwgYltpXSk6XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsc2VcXG4gICAgICAgIHJldHVybiBUcnVlXFxuICAgIHJldHVybiBGYWxzZVxcbixcXG5cImt3YXJnc1wiOiBkZWYoKTpcXG4gICAgIyBXQVJOSU5HOiB3aGVuIHVzaW5nIHRoaXMgZnVuY3Rpb24gZGVjb3JhdG9yLCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byB1c2Ugb2JmdXNjYXRvcnMgdGhhdCByZW5hbWUgbG9jYWwgdmFyaWFibGVzXFxuICAgIGRlZiBrd2FyZ3MoZik6XFxuICAgICAgICBhcmdOYW1lcyA9IGYudG9TdHJpbmcoKS5tYXRjaCgvXFxcXCgoW15cXFxcKV0rKS8pWzFdXFxuICAgICAgICBpZiBub3Qga3dhcmdzLm1lbW9bYXJnTmFtZXNdOlxcbiAgICAgICAgICAgIGt3YXJncy5tZW1vW2FyZ05hbWVzXSA9IGFyZ05hbWVzID8gYXJnTmFtZXMuc3BsaXQoXFwnLFxcJykubWFwKGRlZihzKTogcmV0dXJuIHMudHJpbSgpOykgOiBbXVxcbiAgICAgICAgYXJnTmFtZXMgPSBrd2FyZ3MubWVtb1thcmdOYW1lc11cXG4gICAgICAgIHJldHVybiBkZWYoKTpcXG4gICAgICAgICAgICBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXFxuICAgICAgICAgICAgaWYgYXJncy5sZW5ndGg6XFxuICAgICAgICAgICAgICAgIGt3ID0gYXJnc1stMV1cXG4gICAgICAgICAgICAgICAgaWYgSlMoXFwndHlwZW9mIGt3XFwnKSBpcyBcXCdvYmplY3RcXCc6XFxuICAgICAgICAgICAgICAgICAgICBmb3IgaSBpbiByYW5nZShhcmdOYW1lcy5sZW5ndGgpOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGFyZ05hbWVzW2ldIGluIGt3OlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0ga3dbYXJnTmFtZXNbaV1dXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goa3cpXFxuXFxuICAgICAgICAgICAgIyBUaGlzIGxvZ2ljIGlzIHZlcnkgZnJhZ2lsZSBhbmQgdmVyeSBzdWJ0bGUsIGl0IG5lZWRzIHRvIHdvcmsgYm90aCBpbiBFUzYgYW5kIEVTNSwgZG9uXFwndCB0cnkgdG8gb3B0aW1pemUgdGhlXFxuICAgICAgICAgICAgIyBhcHBseSBhd2F5IGludG8gKmFyZ3MgYmVjYXVzZSBoYXZpbmcgaXQgaW4gdGhpcyBmb3JtYXQgZW5zdXJlcyBjb3JyZWN0IFxcJ3RoaXNcXCcgY29udGV4dCwgb3RoZXJ3aXNlIHRoZSBmdW5jdGlvblxcbiAgICAgICAgICAgICMgZW5kcyB1cCB1bmJvdW5kLiBTaW1pbGFybHksIHRoZSBmYWxsdGhyb3VnaCB0byBleGNlcHQgaGFuZGxlcyBjbGFzcyBjcmVhdGlvbiBpbiBFUzYuXFxuICAgICAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmdzKVxcbiAgICAgICAgICAgIGV4Y2VwdCBhcyBlOlxcbiAgICAgICAgICAgICAgICBpZiAvQ2xhc3MgY29uc3RydWN0b3IgXFxcXHcrIGNhbm5vdCBiZSBpbnZva2VkIHdpdGhvdXQgXFwnbmV3XFwnLy50ZXN0KGUpOlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBmKCphcmdzKVxcbiAgICAgICAgICAgICAgICByYWlzZVxcbiAgICBrd2FyZ3MubWVtbyA9IHt9XFxuLFxcblxcbiMgRXJyb3JzXFxuIyB0ZW1wb3JhcmlseSBpbXBsZW1lbnRlZCB2aWEgYSB3cmFwcGVyIHBhdHRlcm4gc2luY2UgdGhlcmUgaXMgbm8gbWVjaGFuaXNtIGZvciBhc3NpZ25pbmdcXG4jIGNsYXNzZXMgdG8gZGljdGlvbmFyeSBrZXlzIHlldFxcblwiQXNzZXJ0aW9uRXJyb3JcIjogZGVmKCk6XFxuICAgIGNsYXNzIEFzc2VydGlvbkVycm9yKEVycm9yKTpcXG4gICAgICAgIGRlZiBfX2luaXRfXyhzZWxmLCBtZXNzYWdlKTpcXG4gICAgICAgICAgICBzZWxmLm5hbWUgPSBcIkFzc2VydGlvbkVycm9yXCJcXG4gICAgICAgICAgICBzZWxmLm1lc3NhZ2UgPSBtZXNzYWdlXFxuLFxcblwiSW5kZXhFcnJvclwiOiBkZWYoKTpcXG4gICAgY2xhc3MgSW5kZXhFcnJvcihFcnJvcik6XFxuICAgICAgICBkZWYgX19pbml0X18oc2VsZiwgbWVzc2FnZSk6XFxuICAgICAgICAgICAgc2VsZi5uYW1lID0gXCJJbmRleEVycm9yXCJcXG4gICAgICAgICAgICBzZWxmLm1lc3NhZ2UgPSBtZXNzYWdlXFxuLFxcblwiS2V5RXJyb3JcIjogZGVmKCk6XFxuICAgIGNsYXNzIEtleUVycm9yKEVycm9yKTpcXG4gICAgICAgIGRlZiBfX2luaXRfXyhzZWxmLCBtZXNzYWdlKTpcXG4gICAgICAgICAgICBzZWxmLm5hbWUgPSBcIktleUVycm9yXCJcXG4gICAgICAgICAgICBzZWxmLm1lc3NhZ2UgPSBtZXNzYWdlXFxuLFxcblwiVHlwZUVycm9yXCI6IGRlZigpOlxcbiAgICBjbGFzcyBUeXBlRXJyb3IoRXJyb3IpOlxcbiAgICAgICAgZGVmIF9faW5pdF9fKHNlbGYsIG1lc3NhZ2UpOlxcbiAgICAgICAgICAgIHNlbGYubmFtZSA9IFwiVHlwZUVycm9yXCJcXG4gICAgICAgICAgICBzZWxmLm1lc3NhZ2UgPSBtZXNzYWdlXFxuLFxcblwiVmFsdWVFcnJvclwiOiBkZWYoKTpcXG4gICAgY2xhc3MgVmFsdWVFcnJvcihFcnJvcik6XFxuICAgICAgICBkZWYgX19pbml0X18oc2VsZiwgbWVzc2FnZSk6XFxuICAgICAgICAgICAgc2VsZi5uYW1lID0gXCJWYWx1ZUVycm9yXCJcXG4gICAgICAgICAgICBzZWxmLm1lc3NhZ2UgPSBtZXNzYWdlXFxuLFxcbn1cXG4nO1xuICAgINWQ1Y9fbW9kdWxlc1tcIl9iYXNlbGliXCJdW1wiQkFTRUxJQlwiXSA9IEJBU0VMSUI7XG59KSgpO1xuXG4oZnVuY3Rpb24oKXtcbiAgICB2YXIgX19uYW1lX18gPSBcIm91dHB1dFwiO1xuICAgIHZhciBtYWtlUHJlZGljYXRlID0g1ZDVj19tb2R1bGVzW1widXRpbHNcIl0ubWFrZVByZWRpY2F0ZTtcbiAgICB2YXIgbm9vcCA9INWQ1Y9fbW9kdWxlc1tcInV0aWxzXCJdLm5vb3A7XG4gICAgdmFyIGRlZmF1bHRzID0g1ZDVj19tb2R1bGVzW1widXRpbHNcIl0uZGVmYXVsdHM7XG4gICAgdmFyIHJlcGVhdF9zdHJpbmcgPSDVkNWPX21vZHVsZXNbXCJ1dGlsc1wiXS5yZXBlYXRfc3RyaW5nO1xuICAgIHZhciBSQVBZRF9QUkVGSVggPSDVkNWPX21vZHVsZXNbXCJ1dGlsc1wiXS5SQVBZRF9QUkVGSVg7XG4gICAgXG4gICAgdmFyIGlzX2lkZW50aWZpZXJfY2hhciA9INWQ1Y9fbW9kdWxlc1tcInRva2VuaXplclwiXS5pc19pZGVudGlmaWVyX2NoYXI7XG4gICAgdmFyIFBSRUNFREVOQ0UgPSDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl0uUFJFQ0VERU5DRTtcbiAgICBcbiAgICB2YXIgYXN0ID0g1ZDVj19tb2R1bGVzW1wiYXN0XCJdO1xuICAgIFxuICAgIHZhciBfYmFzZWxpYiA9INWQ1Y9fbW9kdWxlc1tcIl9iYXNlbGliXCJdO1xuICAgIFxuICAgIHZhciBwYXJzZXIgPSDVkNWPX21vZHVsZXNbXCJwYXJzZXJcIl07XG4gICAgXG4gICAgZnVuY3Rpb24gU3RyZWFtKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMsIGluZGVudGF0aW9uLCBjdXJyZW50X2NvbCwgY3VycmVudF9saW5lLCBjdXJyZW50X3BvcywgQlVGRkVSUywgSU1QT1JURUQsIG1pZ2h0X25lZWRfc3BhY2UsIG1pZ2h0X25lZWRfc2VtaWNvbG9uLCBsYXN0LCByZXF1aXJlU2VtaWNvbG9uQ2hhcnMsIHNwYWNlLCBpbmRlbnQsIHdpdGhfaW5kZW50LCBuZXdsaW5lLCBzZW1pY29sb24sIGFkZF9tYXBwaW5nLCB0bXBJbmRleCwgc3RhY2ssIGJhc2VsaWJDYWNoZTtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGluZGVudF9zdGFydDogMCxcbiAgICAgICAgICAgIGluZGVudF9sZXZlbDogNCxcbiAgICAgICAgICAgIHF1b3RlX2tleXM6IGZhbHNlLFxuICAgICAgICAgICAgc3BhY2VfY29sb246IHRydWUsXG4gICAgICAgICAgICBhc2NpaV9vbmx5OiBmYWxzZSxcbiAgICAgICAgICAgIGlubGluZV9zY3JpcHQ6IGZhbHNlLFxuICAgICAgICAgICAgd2lkdGg6IDgwLFxuICAgICAgICAgICAgbWF4X2xpbmVfbGVuOiAzMmUzLFxuICAgICAgICAgICAgZXM2OiBmYWxzZSxcbiAgICAgICAgICAgIGJlYXV0aWZ5OiBmYWxzZSxcbiAgICAgICAgICAgIHNvdXJjZV9tYXA6IG51bGwsXG4gICAgICAgICAgICBicmFja2V0aXplOiBmYWxzZSxcbiAgICAgICAgICAgIHNlbWljb2xvbnM6IHRydWUsXG4gICAgICAgICAgICBjb21tZW50czogZmFsc2UsXG4gICAgICAgICAgICBwcmVzZXJ2ZV9saW5lOiBmYWxzZSxcbiAgICAgICAgICAgIG9taXRfYmFzZWxpYjogZmFsc2UsXG4gICAgICAgICAgICBiYXNlbGliOiBudWxsLFxuICAgICAgICAgICAgcHJpdmF0ZV9zY29wZTogdHJ1ZSxcbiAgICAgICAgICAgIGF1dG9fYmluZDogZmFsc2UsXG4gICAgICAgICAgICB3cml0ZV9uYW1lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpbmRlbnRhdGlvbiA9IDA7XG4gICAgICAgIGN1cnJlbnRfY29sID0gMDtcbiAgICAgICAgY3VycmVudF9saW5lID0gMTtcbiAgICAgICAgY3VycmVudF9wb3MgPSAwO1xuICAgICAgICBCVUZGRVJTID0gWyB7XG4gICAgICAgICAgICB2YXJzOiBbXSxcbiAgICAgICAgICAgIG91dHB1dDogXCJcIixcbiAgICAgICAgICAgIGJhc2VsaWI6IHt9XG4gICAgICAgIH0gXTtcbiAgICAgICAgSU1QT1JURUQgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gdG9fYXNjaWkoc3RyXywgaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIHN0cl8ucmVwbGFjZSgvW1xcdTAwODAtXFx1ZmZmZl0vZywgZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICBjb2RlID0gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUubGVuZ3RoIDw9IDIgJiYgIWlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvZGUubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IFwiMFwiICsgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFxceFwiICsgY29kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29kZS5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gXCIwXCIgKyBjb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1XCIgKyBjb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2Vfc3RyaW5nKHN0cl8sIHF1b3Rlcykge1xuICAgICAgICAgICAgdmFyIGRxLCBzcSwgc3RyXztcbiAgICAgICAgICAgIGRxID0gMDtcbiAgICAgICAgICAgIHNxID0gMDtcbiAgICAgICAgICAgIHN0cl8gPSBzdHJfLnJlcGxhY2UoL1tcXFxcXFxiXFxmXFxuXFxyXFx0XFx4MjJcXHgyN1xcdTIwMjhcXHUyMDI5XFwwXS9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcF87XG4gICAgICAgICAgICAgICAgdG1wXyA9IHM7XG4gICAgICAgICAgICAgICAgaWYgKHRtcF8gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFxcXFxcXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcIlxcYlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFxiXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcIlxcZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFxmXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFxuXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcIlxcdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx0XCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcIlxcclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFxyXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBfID09PSBcIlxcdTIwMjhcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjhcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICArK2RxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1wiJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICsrc3E7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIidcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IFwiXFwwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXDBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFzY2lpX29ubHkpIHtcbiAgICAgICAgICAgICAgICBzdHJfID0gdG9fYXNjaWkoc3RyXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVvdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRxID4gc3EpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJ1wiICsgc3RyXy5yZXBsYWNlKC9cXHgyNy9nLCBcIlxcXFwnXCIpICsgXCInXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcIicgKyBzdHJfLnJlcGxhY2UoL1xceDIyL2csICdcXFxcXCInKSArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlbmNvZGVfc3RyaW5nKHN0cl8sIHF1b3Rlcykge1xuICAgICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICAgIHJldCA9IG1ha2Vfc3RyaW5nKHN0cl8sIHF1b3Rlcyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbmxpbmVfc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gcmV0LnJlcGxhY2UoLzxcXHgyZnNjcmlwdChbPlxcL1xcdFxcblxcZlxcciBdKS9naSwgXCI8XFxcXC9zY3JpcHQkMVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZV9uYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFzY2lpX29ubHkpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gdG9fYXNjaWkobmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlX2luZGVudChiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwZWF0X3N0cmluZyhcIiBcIiwgb3B0aW9ucy5pbmRlbnRfc3RhcnQgKyBpbmRlbnRhdGlvbiAtIGJhY2sgKiBvcHRpb25zLmluZGVudF9sZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgbWlnaHRfbmVlZF9zcGFjZSA9IGZhbHNlO1xuICAgICAgICBtaWdodF9uZWVkX3NlbWljb2xvbiA9IGZhbHNlO1xuICAgICAgICBsYXN0ID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gbGFzdF9jaGFyKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3QuY2hhckF0KGxhc3QubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVfbmV3bGluZSgpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1heF9saW5lX2xlbiAmJiBjdXJyZW50X2NvbCA+IG9wdGlvbnMubWF4X2xpbmVfbGVuKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfKFwiXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVpcmVTZW1pY29sb25DaGFycyA9IG1ha2VQcmVkaWNhdGUoXCIoIFsgKyAqIC8gLSAsIC5cIik7XG4gICAgICAgIGZ1bmN0aW9uIHByaW50XyhzdHJfKSB7XG4gICAgICAgICAgICB2YXIgc3RyXywgY2gsIHRhcmdldF9saW5lLCBwcmV2LCBhLCBuO1xuICAgICAgICAgICAgc3RyXyA9IFN0cmluZyhzdHJfKTtcbiAgICAgICAgICAgIGNoID0gc3RyXy5jaGFyQXQoMCk7XG4gICAgICAgICAgICBpZiAobWlnaHRfbmVlZF9zZW1pY29sb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoKCFjaCB8fCAhKNWQ1Y9faW4oY2gsIFwiO31cIikpKSAmJiAhL1s7XSQvLnRlc3QobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2VtaWNvbG9ucyB8fCByZXF1aXJlU2VtaWNvbG9uQ2hhcnMoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBCVUZGRVJTW0JVRkZFUlMubGVuZ3RoLTFdLm91dHB1dCArPSBcIjtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrY3VycmVudF9jb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2N1cnJlbnRfcG9zO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQlVGRkVSU1tCVUZGRVJTLmxlbmd0aC0xXS5vdXRwdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrY3VycmVudF9wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2N1cnJlbnRfbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfY29sID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuYmVhdXRpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZ2h0X25lZWRfc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtaWdodF9uZWVkX3NlbWljb2xvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG1heWJlX25ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5iZWF1dGlmeSAmJiBvcHRpb25zLnByZXNlcnZlX2xpbmUgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRfbGluZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRfbGluZSA8IHRhcmdldF9saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIEJVRkZFUlNbQlVGRkVSUy5sZW5ndGgtMV0ub3V0cHV0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgICsrY3VycmVudF9wb3M7XG4gICAgICAgICAgICAgICAgICAgICsrY3VycmVudF9saW5lO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X2NvbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1pZ2h0X25lZWRfc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWlnaHRfbmVlZF9zcGFjZSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBsYXN0X2NoYXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNfaWRlbnRpZmllcl9jaGFyKHByZXYpICYmIChpc19pZGVudGlmaWVyX2NoYXIoY2gpIHx8IGNoID09PSBcIlxcXFxcIikgfHwgL15bXFwrXFwtXFwvXSQvLnRlc3QoY2gpICYmIGNoID09PSBwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgIEJVRkZFUlNbQlVGRkVSUy5sZW5ndGgtMV0ub3V0cHV0ICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICArK2N1cnJlbnRfY29sO1xuICAgICAgICAgICAgICAgICAgICArK2N1cnJlbnRfcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtaWdodF9uZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID0gc3RyXy5zcGxpdCgvXFxyP1xcbi8pO1xuICAgICAgICAgICAgbiA9IGEubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGN1cnJlbnRfbGluZSArPSBuO1xuICAgICAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50X2NvbCArPSBhW25dLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudF9jb2wgPSBhW25dLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRfcG9zICs9IHN0cl8ubGVuZ3RoO1xuICAgICAgICAgICAgbGFzdCA9IHN0cl87XG4gICAgICAgICAgICBCVUZGRVJTW0JVRkZFUlMubGVuZ3RoLTFdLm91dHB1dCArPSBzdHJfO1xuICAgICAgICB9XG4gICAgICAgIHNwYWNlID0gb3B0aW9ucy5iZWF1dGlmeSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcHJpbnRfKFwiIFwiKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbWlnaHRfbmVlZF9zcGFjZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGluZGVudCA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbihoYWxmKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5iZWF1dGlmeSkge1xuICAgICAgICAgICAgICAgIHByaW50XyhtYWtlX2luZGVudChoYWxmID8gLjUgOiAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiBub29wO1xuICAgICAgICB3aXRoX2luZGVudCA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbihjb2wsIGNvbnQpIHtcbiAgICAgICAgICAgIHZhciBjb2wsIHNhdmVfaW5kZW50YXRpb24sIHJldDtcbiAgICAgICAgICAgIGlmIChjb2wgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb2wgPSBuZXh0X2luZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2F2ZV9pbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gPSBjb2w7XG4gICAgICAgICAgICByZXQgPSBjb250KCk7XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiA9IHNhdmVfaW5kZW50YXRpb247XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9IDogZnVuY3Rpb24oY29sLCBjb250KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udCgpO1xuICAgICAgICB9O1xuICAgICAgICBuZXdsaW5lID0gb3B0aW9ucy5iZWF1dGlmeSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcHJpbnRfKFwiXFxuXCIpO1xuICAgICAgICB9IDogbm9vcDtcbiAgICAgICAgc2VtaWNvbG9uID0gb3B0aW9ucy5iZWF1dGlmeSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcHJpbnRfKFwiO1wiKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbWlnaHRfbmVlZF9zZW1pY29sb24gPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBmb3JjZV9zZW1pY29sb24oKSB7XG4gICAgICAgICAgICBtaWdodF9uZWVkX3NlbWljb2xvbiA9IGZhbHNlO1xuICAgICAgICAgICAgcHJpbnRfKFwiO1wiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBuZXh0X2luZGVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRlbnRhdGlvbiArIG9wdGlvbnMuaW5kZW50X2xldmVsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNwYWNlZCgpIHtcbiAgICAgICAgICAgIHZhciDVkNWPaXRyNjUsINWQ1Y9pZHg2NSwg1ZDVj3Vwazk7XG4gICAgICAgICAgICB2YXIgaSwgeDtcbiAgICAgICAgICAgINWQ1Y9pdHI2NSA9INWQ1Y9fSXRlcmFibGUoZW51bWVyYXRlKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgZm9yICjVkNWPaWR4NjUgPSAwOyDVkNWPaWR4NjUgPCDVkNWPaXRyNjUubGVuZ3RoOyDVkNWPaWR4NjUrKykge1xuICAgICAgICAgICAgICAgINWQ1Y91cGs5ID0g1ZDVj2l0cjY1W9WQ1Y9pZHg2NV07XG4gICAgICAgICAgICAgICAgaSA9INWQ1Y91cGs5WzBdO1xuICAgICAgICAgICAgICAgIHggPSDVkNWPdXBrOVsxXTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHgucHJpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgeC5wcmludCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmludF8oeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZFByb3BlcnR5KHByb3AsIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoXCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChvYmopO1xuICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludF9zdHJpbmcocHJvcCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiKVwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkUHJvcGVydGllcyhzdWJhdHRyLCBwcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KG9iaik7XG4gICAgICAgICAgICAgICAgaWYgKHN1YmF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiLlwiICsgc3ViYXR0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbihrZXksIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY29sb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciDVkNWPaXRyNjYsINWQ1Y9pZHg2NjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICDVkNWPaXRyNjYgPSDVkNWPX0l0ZXJhYmxlKFsgXCJlbnVtZXJhYmxlXCIsIFwid3JpdGFibGVcIiBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKNWQ1Y9pZHg2NiA9IDA7INWQ1Y9pZHg2NiA8INWQ1Y9pdHI2Ni5sZW5ndGg7INWQ1Y9pZHg2NisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSDVkNWPaXRyNjZb1ZDVj2lkeDY2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoYXR0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW2tleV0ob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIpXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlbmRfc3RhdGVtZW50KCkge1xuICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd2l0aF9ibG9jayhjb250KSB7XG4gICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgcmV0ID0gbnVsbDtcbiAgICAgICAgICAgIHByaW50XyhcIntcIik7XG4gICAgICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgICAgICB3aXRoX2luZGVudChuZXh0X2luZGVudCgpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBjb250KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluZGVudCgpO1xuICAgICAgICAgICAgcHJpbnRfKFwifVwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd2l0aF9wYXJlbnMoY29udCkge1xuICAgICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICAgIHByaW50XyhcIihcIik7XG4gICAgICAgICAgICByZXQgPSBjb250KCk7XG4gICAgICAgICAgICBwcmludF8oXCIpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3aXRoX3NxdWFyZShjb250KSB7XG4gICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgcHJpbnRfKFwiW1wiKTtcbiAgICAgICAgICAgIHJldCA9IGNvbnQoKTtcbiAgICAgICAgICAgIHByaW50XyhcIl1cIik7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbW1hKCkge1xuICAgICAgICAgICAgcHJpbnRfKFwiLFwiKTtcbiAgICAgICAgICAgIHNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29sb24oKSB7XG4gICAgICAgICAgICBwcmludF8oXCI6XCIpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3BhY2VfY29sb24pIHtcbiAgICAgICAgICAgICAgICBzcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZF9tYXBwaW5nID0gb3B0aW9ucy5zb3VyY2VfbWFwID8gZnVuY3Rpb24odG9rZW4sIG5hbWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc291cmNlX21hcC5hZGQodG9rZW4uZmlsZSB8fCBcIj9cIiwgY3VycmVudF9saW5lLCBjdXJyZW50X2NvbCwgdG9rZW4ubGluZSwgdG9rZW4uY29sLCAhbmFtZSAmJiB0b2tlbi50eXBlID09PSBcIm5hbWVcIiA/IHRva2VuLnZhbHVlIDogbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAo1ZDVj19FeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXggPSDVkNWPX0V4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICBhc3QuTm9kZS53YXJuKFwiQ291bGRuJ3QgZmlndXJlIG91dCBtYXBwaW5nIGZvciB7ZmlsZX06e2xpbmV9LHtjb2x9IOKGkiB7Y2xpbmV9LHtjY29sfSBbe25hbWV9XVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IHRva2VuLmZpbGUsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IHRva2VuLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDogdG9rZW4uY29sLFxuICAgICAgICAgICAgICAgICAgICBjbGluZTogY3VycmVudF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBjY29sOiBjdXJyZW50X2NvbCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSB8fCBcIlwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiBub29wO1xuICAgICAgICBmdW5jdGlvbiBnZXRfKCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCwgb3V0O1xuICAgICAgICAgICAgaWYgKEJVRkZFUlMubGVuID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWV0aGluZyB3ZW50IHdyb25nLCBvdXRwdXQgZ2VuZXJhdG9yIGRpZG4ndCBleGl0IGFsbCBvZiBpdHMgc2NvcGVzIHByb3Blcmx5LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoQlVGRkVSU1swXS52YXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIEJVRkZFUlMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgIHZhcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IFwiXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbmRMb2NhbEJ1ZmZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ID0gQlVGRkVSU1swXS5vdXRwdXQ7XG4gICAgICAgICAgICBCVUZGRVJTWzBdLm91dHB1dCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wcml2YXRlX3Njb3BlKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJmdW5jdGlvbigpXCIpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludCgnXCJ1c2Ugc3RyaWN0XCInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5lbmRfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQob3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiKCk7XCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEJVRkZFUlNbQlVGRkVSUy5sZW5ndGgtMV0ub3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFzc2lnbl92YXIobmFtZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfKG5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lLnByaW50KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3BhY2UoKTtcbiAgICAgICAgICAgIHByaW50XyhcIj1cIik7XG4gICAgICAgICAgICBzcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRtcEluZGV4ID0ge1xuICAgICAgICAgICAgXCJpdHJcIjogMCxcbiAgICAgICAgICAgIFwiaWR4XCI6IDAsXG4gICAgICAgICAgICBcInVwa1wiOiAwLFxuICAgICAgICAgICAgXCJfXCI6IDBcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gbmV3VGVtcChzdWJ0eXBlLCBidWZmZXIpIHtcbiAgICAgICAgICAgIHN1YnR5cGUgPSBzdWJ0eXBlID09PSB2b2lkIDAgPyBcIl9cIiA6IHN1YnR5cGU7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIgPT09IHZvaWQgMCA/IHRydWUgOiBidWZmZXI7XG4gICAgICAgICAgICB2YXIgdG1wO1xuICAgICAgICAgICAgKyt0bXBJbmRleFtzdWJ0eXBlXTtcbiAgICAgICAgICAgIHRtcCA9IFJBUFlEX1BSRUZJWCArIHN1YnR5cGUgKyB0bXBJbmRleFtzdWJ0eXBlXTtcbiAgICAgICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBCVUZGRVJTW0JVRkZFUlMubGVuZ3RoLTFdLnZhcnMucHVzaCh0bXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcmV2VGVtcChzdWJ0eXBlKSB7XG4gICAgICAgICAgICBzdWJ0eXBlID0gc3VidHlwZSA9PT0gdm9pZCAwID8gXCJfXCIgOiBzdWJ0eXBlO1xuICAgICAgICAgICAgcmV0dXJuIFJBUFlEX1BSRUZJWCArIHN1YnR5cGUgKyB0bXBJbmRleFtzdWJ0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFydExvY2FsQnVmZmVyKCkge1xuICAgICAgICAgICAgQlVGRkVSUy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YXJzOiBbXSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVuZExvY2FsQnVmZmVyKGJhc2VsaWIpIHtcbiAgICAgICAgICAgIGJhc2VsaWIgPSBiYXNlbGliID09PSB2b2lkIDAgPyBmYWxzZSA6IGJhc2VsaWI7XG4gICAgICAgICAgICB2YXIgbG9jYWxCdWZmZXI7XG4gICAgICAgICAgICBsb2NhbEJ1ZmZlciA9IEJVRkZFUlMucG9wKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxCdWZmZXIudmFycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBwcmludF8oXCJ2YXIgXCIpO1xuICAgICAgICAgICAgICAgIGxvY2FsQnVmZmVyLnZhcnMuZm9yRWFjaChmdW5jdGlvbihsb2NhbCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmludF8obG9jYWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcmNlX3NlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIG5ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiYXNlbGliKSB7XG4gICAgICAgICAgICAgICAgQlVGRkVSU1tCVUZGRVJTLmxlbmd0aC0xXS5vdXRwdXQgPSBsb2NhbEJ1ZmZlci5vdXRwdXQgKyBCVUZGRVJTW0JVRkZFUlMubGVuZ3RoLTFdLm91dHB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQlVGRkVSU1tCVUZGRVJTLmxlbmd0aC0xXS5vdXRwdXQgKz0gbG9jYWxCdWZmZXIub3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrID0gW107XG4gICAgICAgIGJhc2VsaWJDYWNoZSA9IHt9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0OiBnZXRfLFxuICAgICAgICAgICAgdG9TdHJpbmc6IGdldF8sXG4gICAgICAgICAgICBpbmRlbnQ6IGluZGVudCxcbiAgICAgICAgICAgIGluZGVudGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZW50YXRpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VycmVudF93aWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRfY29sIC0gaW5kZW50YXRpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvdWxkX2JyZWFrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy53aWR0aCAmJiB0aGlzLmN1cnJlbnRfd2lkdGgoKSA+PSBvcHRpb25zLndpZHRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5ld2xpbmU6IG5ld2xpbmUsXG4gICAgICAgICAgICBwcmludDogcHJpbnRfLFxuICAgICAgICAgICAgc3BhY2U6IHNwYWNlLFxuICAgICAgICAgICAgY29tbWE6IGNvbW1hLFxuICAgICAgICAgICAgY29sb246IGNvbG9uLFxuICAgICAgICAgICAgbGFzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VtaWNvbG9uOiBzZW1pY29sb24sXG4gICAgICAgICAgICBmb3JjZV9zZW1pY29sb246IGZvcmNlX3NlbWljb2xvbixcbiAgICAgICAgICAgIHRvX2FzY2lpOiB0b19hc2NpaSxcbiAgICAgICAgICAgIHByaW50X25hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcmludF8obWFrZV9uYW1lKG5hbWUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmludF9zdHJpbmc6IGZ1bmN0aW9uKHN0cl8sIHF1b3Rlcykge1xuICAgICAgICAgICAgICAgIHF1b3RlcyA9IHF1b3RlcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IHF1b3RlcztcbiAgICAgICAgICAgICAgICBwcmludF8oZW5jb2RlX3N0cmluZyhzdHJfLCBxdW90ZXMpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0X2luZGVudDogbmV4dF9pbmRlbnQsXG4gICAgICAgICAgICB3aXRoX2luZGVudDogd2l0aF9pbmRlbnQsXG4gICAgICAgICAgICB3aXRoX2Jsb2NrOiB3aXRoX2Jsb2NrLFxuICAgICAgICAgICAgd2l0aF9wYXJlbnM6IHdpdGhfcGFyZW5zLFxuICAgICAgICAgICAgc3BhY2VkOiBzcGFjZWQsXG4gICAgICAgICAgICBlbmRfc3RhdGVtZW50OiBlbmRfc3RhdGVtZW50LFxuICAgICAgICAgICAgYWRkUHJvcGVydHk6IGFkZFByb3BlcnR5LFxuICAgICAgICAgICAgc3RhcnRMb2NhbEJ1ZmZlcjogc3RhcnRMb2NhbEJ1ZmZlcixcbiAgICAgICAgICAgIGVuZExvY2FsQnVmZmVyOiBlbmRMb2NhbEJ1ZmZlcixcbiAgICAgICAgICAgIGFkZFByb3BlcnRpZXM6IGFkZFByb3BlcnRpZXMsXG4gICAgICAgICAgICB3aXRoX3NxdWFyZTogd2l0aF9zcXVhcmUsXG4gICAgICAgICAgICBhZGRfbWFwcGluZzogYWRkX21hcHBpbmcsXG4gICAgICAgICAgICBhc3NpZ246IGFzc2lnbl92YXIsXG4gICAgICAgICAgICBwcmludF9iYXNlbGliOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjY3LCDVkNWPaWR4Njc7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2VsaWJBc3QsIGhhc2gsIGRhdGEsIGl0ZW0sIGtleV8sIHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5vbWl0X2Jhc2VsaWIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhiYXNlbGliQ2FjaGUpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWxpYkFzdCA9IHBhcnNlci5wYXJzZShfYmFzZWxpYi5CQVNFTElCLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGZpbGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcERvY3N0cmluZ3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IFwiX2Jhc2VsaWIucHlqXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCA9IGJhc2VsaWJBc3QuYm9keVtiYXNlbGliQXN0LmJvZHkubGVuZ3RoLTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGhhc2guYm9keS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAg1ZDVj2l0cjY3ID0g1ZDVj19JdGVyYWJsZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDY3ID0gMDsg1ZDVj2lkeDY3IDwg1ZDVj2l0cjY3Lmxlbmd0aDsg1ZDVj2lkeDY3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0g1ZDVj2l0cjY3W9WQ1Y9pZHg2N107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5XyA9IGl0ZW0ua2V5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRlbS52YWx1ZS5uYW1lID8gWyBpdGVtLnZhbHVlIF0gOiBpdGVtLnZhbHVlLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWxpYkNhY2hlW2tleV9dID0gc3BsYXRCYXNlbGliKGtleV8sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiYXNlbGliQ2FjaGVba2V5XS5wcmludCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1wb3J0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUlNUE9SVEVELmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgSU1QT1JURURba2V5XSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc19tYWluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQlVGRkVSUy5sZW5ndGggPT09IDEgJiYgQlVGRkVSU1tCVUZGRVJTLmxlbmd0aC0xXS5vdXRwdXQubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbjogZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnNbb3B0XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudF9saW5lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRfY29sO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRfcG9zO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHB1c2hfbm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9wX25vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5ld1RlbXA6IG5ld1RlbXAsXG4gICAgICAgICAgICBwcmV2VGVtcDogcHJldlRlbXAsXG4gICAgICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMiAtIChuIHx8IDApXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgU1BFQ0lBTF9NRVRIT0RTLCBCQVNFTElCLCBDUkVBVElPTjtcbiAgICAgICAgU1BFQ0lBTF9NRVRIT0RTID0ge1xuICAgICAgICAgICAgXCJiaW5kXCI6IFwi1ZDVj19iaW5kXCIsXG4gICAgICAgICAgICBcInJlYmluZF9hbGxcIjogXCLVkNWPX3JlYmluZEFsbFwiLFxuICAgICAgICAgICAgXCJib29sXCI6IFwiISFcIixcbiAgICAgICAgICAgIFwiZmxvYXRcIjogXCJwYXJzZUZsb2F0XCIsXG4gICAgICAgICAgICBcImludFwiOiBcInBhcnNlSW50XCIsXG4gICAgICAgICAgICBcIm1peGluXCI6IFwi1ZDVj19taXhpblwiLFxuICAgICAgICAgICAgXCJtZXJnZVwiOiBcItWQ1Y9fbWVyZ2VcIixcbiAgICAgICAgICAgIFwicHJpbnRcIjogXCLVkNWPX3ByaW50XCIsXG4gICAgICAgICAgICBcImVzbGljZVwiOiBcItWQ1Y9fZXNsaWNlXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCLVkNWPX3R5cGVcIlxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiB1bmlmeShvdXRwdXQsIGFzc2lnbikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICB2YXIgYXJncztcbiAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgIT09IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihiYXNlRm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IG91dHB1dC5uZXdUZW1wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXNzaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFzc2lnbihhc3NpZ24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciDVkNWPaXRyNjgsINWQ1Y9pZHg2ODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24odG1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlRm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICDVkNWPaXRyNjggPSDVkNWPX0l0ZXJhYmxlKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDY4ID0gMDsg1ZDVj2lkeDY4IDwg1ZDVj2l0cjY4Lmxlbmd0aDsg1ZDVj2lkeDY4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0g1ZDVj2l0cjY4W9WQ1Y9pZHg2OF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKNWQ1Y9faW4oYXJnLCBbIG51bGwsIHZvaWQgMCBdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy5jYWxsKG91dHB1dCwgdG1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludCh0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXNzaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VGbigpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gREVGUFJJTlQobm9kZXR5cGUsIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgbm9kZXR5cGUucHJvdG90eXBlLl9jb2RlZ2VuID0gZ2VuZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGFzdC5Ob2RlLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uKHN0cmVhbSwgZm9yY2VfcGFyZW5zKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiwgZ2VuZXJhdG9yO1xuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBnZW5lcmF0b3IgPSBzZWxmLl9jb2RlZ2VuO1xuICAgICAgICAgICAgc3RyZWFtLnB1c2hfbm9kZShzZWxmKTtcbiAgICAgICAgICAgIGlmIChmb3JjZV9wYXJlbnMgfHwgc2VsZi5uZWVkc19wYXJlbnMoc3RyZWFtKSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRfY29tbWVudHMoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRfc291cmNlX21hcChzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3Ioc2VsZiwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hZGRfY29tbWVudHMoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFkZF9zb3VyY2VfbWFwKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yKHNlbGYsIHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0ucG9wX25vZGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYXN0Lk5vZGUucHJvdG90eXBlLnByaW50X3RvX3N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgcyA9IFN0cmVhbShvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMucHJpbnQocyk7XG4gICAgICAgICAgICByZXR1cm4gcy5nZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYXN0Lk5vZGUucHJvdG90eXBlLmFkZF9jb21tZW50cyA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgICAgdmFyINWQ1Y9pdHI2OSwg1ZDVj2lkeDY5O1xuICAgICAgICAgICAgdmFyIGMsIHNlbGYsIHN0YXJ0LCBjb21tZW50cztcbiAgICAgICAgICAgIGMgPSBvdXRwdXQub3B0aW9uKFwiY29tbWVudHNcIik7XG4gICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzZWxmLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCAmJiAhc3RhcnQuX2NvbW1lbnRzX2R1bXBlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydC5fY29tbWVudHNfZHVtcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBzdGFydC5jb21tZW50c19iZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmIGluc3RhbmNlb2YgYXN0LkV4aXQgJiYgc2VsZi52YWx1ZSAmJiBzZWxmLnZhbHVlLnN0YXJ0LmNvbW1lbnRzX2JlZm9yZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IChjb21tZW50cyB8fCBbXSkuY29uY2F0KHNlbGYudmFsdWUuc3RhcnQuY29tbWVudHNfYmVmb3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudmFsdWUuc3RhcnQuY29tbWVudHNfYmVmb3JlID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGMudGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5maWx0ZXIoZnVuY3Rpb24oY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLnRlc3QoY29tbWVudC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmZpbHRlcihmdW5jdGlvbihjb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMoc2VsZiwgY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICDVkNWPaXRyNjkgPSDVkNWPX0l0ZXJhYmxlKGNvbW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4NjkgPSAwOyDVkNWPaWR4NjkgPCDVkNWPaXRyNjkubGVuZ3RoOyDVkNWPaWR4NjkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9INWQ1Y9pdHI2OVvVkNWPaWR4NjldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMudHlwZSA9PT0gXCJjb21tZW50OmxpbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi8vXCIgKyBjLnZhbHVlICsgXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjLnR5cGUgPT09IFwiY29tbWVudDptdWx0aWxpbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi8qXCIgKyBjLnZhbHVlICsgXCIqL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQubmV3bGluZV9iZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBQQVJFTlMobm9kZXR5cGUsIGZ1bmMpIHtcbiAgICAgICAgICAgIG5vZGV0eXBlLnByb3RvdHlwZS5uZWVkc19wYXJlbnMgPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIFBBUkVOUyhhc3QuTm9kZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBQQVJFTlMoYXN0LkZ1bmN0aW9uLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdF9pbl9zdGF0ZW1lbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFBBUkVOUyhhc3QuT2JqZWN0TGl0ZXJhbCwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3RfaW5fc3RhdGVtZW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBQQVJFTlMoYXN0LlVuYXJ5LCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiBwIGluc3RhbmNlb2YgYXN0LlByb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzO1xuICAgICAgICB9KTtcbiAgICAgICAgUEFSRU5TKGFzdC5TZXEsIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHAgaW5zdGFuY2VvZiBhc3QuVW5hcnkgfHwgcCBpbnN0YW5jZW9mIGFzdC5WYXJEZWYgfHwgcCBpbnN0YW5jZW9mIGFzdC5Eb3QgfHwgcCBpbnN0YW5jZW9mIGFzdC5PYmplY3RQcm9wZXJ0eSB8fCBwIGluc3RhbmNlb2YgYXN0LkNvbmRpdGlvbmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgUEFSRU5TKGFzdC5SYW5nZSwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBQQVJFTlMoYXN0LkJpbmFyeSwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgICAgICB2YXIgcCwgcG8sIHBwLCBzbywgc3A7XG4gICAgICAgICAgICBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBhc3QuQmFzZUNhbGwgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIGFzdC5VbmFyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBhc3QuUHJvcEFjY2VzcyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgYXN0LkJpbmFyeSkge1xuICAgICAgICAgICAgICAgIHBvID0gcC5vcGVyYXRvcjtcbiAgICAgICAgICAgICAgICBwcCA9IFBSRUNFREVOQ0VbcG9dO1xuICAgICAgICAgICAgICAgIHNvID0gdGhpcy5vcGVyYXRvcjtcbiAgICAgICAgICAgICAgICBzcCA9IFBSRUNFREVOQ0Vbc29dO1xuICAgICAgICAgICAgICAgIGlmIChwcCA+IHNwIHx8IHBwID09PSBzcCAmJiB0aGlzID09PSBwLnJpZ2h0ICYmICEoc28gPT09IHBvICYmIChzbyA9PT0gXCIqXCIgfHwgc28gPT09IFwiJiZcIiB8fCBzbyA9PT0gXCJ8fFwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgUEFSRU5TKGFzdC5Qcm9wQWNjZXNzLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgYXN0Lk5ldyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhbGsobmV3IGFzdC5UcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgYXN0LkJhc2VDYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKNWQ1Y9fRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleCA9INWQ1Y9fRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXggIT09IHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFBBUkVOUyhhc3QuQmFzZUNhbGwsIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHAgaW5zdGFuY2VvZiBhc3QuTmV3ICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcztcbiAgICAgICAgfSk7XG4gICAgICAgIFBBUkVOUyhhc3QuTmV3LCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgICAgIGlmIChub19jb25zdHJ1Y3Rvcl9wYXJlbnModGhpcywgb3V0cHV0KSAmJiAocCBpbnN0YW5jZW9mIGFzdC5Qcm9wQWNjZXNzIHx8IHAgaW5zdGFuY2VvZiBhc3QuQmFzZUNhbGwgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgUEFSRU5TKGFzdC5OdW1iZXIsIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VmFsdWUoKSA8IDAgJiYgcCBpbnN0YW5jZW9mIGFzdC5Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgUEFSRU5TKGFzdC5Ob3RBTnVtYmVyLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgYXN0LlByb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBhc3NpZ25fYW5kX2NvbmRpdGlvbmFsX3BhcmVuX3J1bGVzKG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBhc3QuVW5hcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgYXN0LkJpbmFyeSAmJiAhKHAgaW5zdGFuY2VvZiBhc3QuQXNzaWduKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBhc3QuQmFzZUNhbGwgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIGFzdC5Db25kaXRpb25hbCAmJiBwLmNvbmRpdGlvbiA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBhc3QuUHJvcEFjY2VzcyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQQVJFTlMoYXN0LkFzc2lnbiwgYXNzaWduX2FuZF9jb25kaXRpb25hbF9wYXJlbl9ydWxlcyk7XG4gICAgICAgIFBBUkVOUyhhc3QuQ29uZGl0aW9uYWwsIGFzc2lnbl9hbmRfY29uZGl0aW9uYWxfcGFyZW5fcnVsZXMpO1xuICAgICAgICBERUZQUklOVChhc3QuRGlyZWN0aXZlLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludF9zdHJpbmcoc2VsZi52YWx1ZSk7XG4gICAgICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuRGVidWdnZXIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiZGVidWdnZXJcIik7XG4gICAgICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBkaXNwbGF5X2JvZHkoYm9keSwgaXNfdG9wbGV2ZWwsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIGxhc3Q7XG4gICAgICAgICAgICBsYXN0ID0gYm9keS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0bXQsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShzdG10IGluc3RhbmNlb2YgYXN0LkVtcHR5U3RhdGVtZW50KSAmJiAhKHN0bXQgaW5zdGFuY2VvZiBhc3QuRGVmaW5pdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RtdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShpID09PSBsYXN0ICYmIGlzX3RvcGxldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJpbmRfbWV0aG9kcyhtZXRob2RzLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICBmb3IgKGFyZyBpbiBtZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcInRoaXMuXCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24oYXJnKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCLVkNWPX2JpbmRcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ0aGlzLlwiICsgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcInRoaXNcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmVuZF9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cml0ZV9pbXBvcnRzKG1vZHVsZV8sIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyINWQ1Y9pdHI3MCwg1ZDVj2lkeDcwLCDVkNWPaXRyNzEsINWQ1Y9pZHg3MSwg1ZDVj2l0cjcyLCDVkNWPaWR4NzIsINWQ1Y9pdHI3Mywg1ZDVj2lkeDczLCDVkNWPaXRyNzQsINWQ1Y9pZHg3NDtcbiAgICAgICAgICAgIHZhciBpbXBvcnRzLCBpbXBvcnRfaWQsIG5vbmxvY2FsdmFycywgbW9kdWxlXywgbmFtZTtcbiAgICAgICAgICAgIGltcG9ydHMgPSBbXTtcbiAgICAgICAgICAgINWQ1Y9pdHI3MCA9INWQ1Y9fSXRlcmFibGUoT2JqZWN0LmtleXMobW9kdWxlXy5pbXBvcnRzKSk7XG4gICAgICAgICAgICBmb3IgKNWQ1Y9pZHg3MCA9IDA7INWQ1Y9pZHg3MCA8INWQ1Y9pdHI3MC5sZW5ndGg7INWQ1Y9pZHg3MCsrKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0X2lkID0g1ZDVj2l0cjcwW9WQ1Y9pZHg3MF07XG4gICAgICAgICAgICAgICAgaW1wb3J0cy5wdXNoKG1vZHVsZV8uaW1wb3J0c1tpbXBvcnRfaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltcG9ydHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgdmFyINWQ1Y91cGsxMDtcbiAgICAgICAgICAgICAgICB2YXIgYSwgYjtcbiAgICAgICAgICAgICAgICDVkNWPdXBrMTAgPSBbIGEuaW1wb3J0X29yZGVyLCBiLmltcG9ydF9vcmRlciBdO1xuICAgICAgICAgICAgICAgIGEgPSDVkNWPdXBrMTBbMF07XG4gICAgICAgICAgICAgICAgYiA9INWQ1Y91cGsxMFsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbXBvcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlZChcInZhciDVkNWPX21vZHVsZXNcIiwgXCI9XCIsIFwie307XCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub25sb2NhbHZhcnMgPSB7fTtcbiAgICAgICAgICAgINWQ1Y9pdHI3MSA9INWQ1Y9fSXRlcmFibGUoaW1wb3J0cyk7XG4gICAgICAgICAgICBmb3IgKNWQ1Y9pZHg3MSA9IDA7INWQ1Y9pZHg3MSA8INWQ1Y9pdHI3MS5sZW5ndGg7INWQ1Y9pZHg3MSsrKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlXyA9INWQ1Y9pdHI3MVvVkNWPaWR4NzFdO1xuICAgICAgICAgICAgICAgINWQ1Y9pdHI3MiA9INWQ1Y9fSXRlcmFibGUobW9kdWxlXy5ub25sb2NhbHZhcnMpO1xuICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDcyID0gMDsg1ZDVj2lkeDcyIDwg1ZDVj2l0cjcyLmxlbmd0aDsg1ZDVj2lkeDcyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9INWQ1Y9pdHI3MlvVkNWPaWR4NzJdO1xuICAgICAgICAgICAgICAgICAgICBub25sb2NhbHZhcnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vbmxvY2FsdmFycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG5vbmxvY2FsdmFycykuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgaWYgKG5vbmxvY2FsdmFycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwidmFyIFwiICsgbm9ubG9jYWx2YXJzKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuZW5kX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAg1ZDVj2l0cjczID0g1ZDVj19JdGVyYWJsZShpbXBvcnRzKTtcbiAgICAgICAgICAgIGZvciAo1ZDVj2lkeDczID0gMDsg1ZDVj2lkeDczIDwg1ZDVj2l0cjczLmxlbmd0aDsg1ZDVj2lkeDczKyspIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVfID0g1ZDVj2l0cjczW9WQ1Y9pZHg3M107XG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZV8ubW9kdWxlX2lkICE9PSBcIl9fbWFpbl9fXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYXNzaWduKCfVkNWPX21vZHVsZXNbXCInICsgbW9kdWxlXy5tb2R1bGVfaWQgKyAnXCJdJyk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcInt9XCIpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuZW5kX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgINWQ1Y9pdHI3NCA9INWQ1Y9fSXRlcmFibGUoaW1wb3J0cyk7XG4gICAgICAgICAgICBmb3IgKNWQ1Y9pZHg3NCA9IDA7INWQ1Y9pZHg3NCA8INWQ1Y9pdHI3NC5sZW5ndGg7INWQ1Y9pZHg3NCsrKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlXyA9INWQ1Y9pdHI3NFvVkNWPaWR4NzRdO1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGVfLm1vZHVsZV9pZCAhPT0gXCJfX21haW5fX1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50X21vZHVsZShtb2R1bGVfLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cml0ZV9tYWluX25hbWUob3V0cHV0KSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcIndyaXRlX25hbWVcIikpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VkKFwidmFyIF9fbmFtZV9fXCIsIFwiPVwiLCAnXCJfX21haW5fX1wiJyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmVuZF9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkaXNwbGF5X2NvbXBsZXhfYm9keShub2RlLCBpc190b3BsZXZlbCwgb3V0cHV0KSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0LCBuZWVkc1N1cGVyLCBkZWxheVNlbGZBc3NpZ25tZW50LCBhcmc7XG4gICAgICAgICAgICBvdXRwdXQuc3RhcnRMb2NhbEJ1ZmZlcigpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIG5lZWRzU3VwZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlbGF5U2VsZkFzc2lnbm1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwiZXM2XCIpICYmIG5vZGUgaW5zdGFuY2VvZiBhc3QuQ29uc3RydWN0b3IgJiYgbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jYWxsc1N1cGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5U2VsZkFzc2lnbm1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRzU3VwZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgYXN0Lk1ldGhvZCAmJiAhbm9kZS5zdGF0aWMgJiYgIWRlbGF5U2VsZkFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobmVlZHNTdXBlcikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcInN1cGVyKClcIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5lbmRfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VkKFwidmFyXCIsIG5vZGUuYXJnbmFtZXNbMF0sIFwiPVwiLCBcInRoaXNcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmVuZF9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICArK29mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgYXN0LlNjb3BlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuYXJnbmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuYXJnbmFtZXMuc3RhcmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZWQoXCJ2YXJcIiwgbm9kZS5hcmduYW1lcy5zdGFyYXJncywgXCI9XCIsIFwiW10uc2xpY2UuY2FsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJhcmd1bWVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KG5vZGUuYXJnbmFtZXMubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmVuZF9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW91dHB1dC5vcHRpb24oXCJlczZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYXJnIGluIG5vZGUuYXJnbmFtZXMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlZChhcmcsIFwiPVwiLCBhcmcsIFwiPT09XCIsIFwidm9pZCAwXCIsIFwiP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZV9zdGF0ZW1lbnQobm9kZS5hcmduYW1lcy5kZWZhdWx0c1thcmddLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5lbmRfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJhdXRvX2JpbmRcIikgJiYgbm9kZS5uYW1lICYmIG5vZGUubmFtZS5uYW1lID09PSBcIl9faW5pdF9fXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCLVkNWPX3JlYmluZEFsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwidGhpc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5lbmRfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRfbWV0aG9kcyhub2RlLmJvdW5kLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNsYXJlX3ZhcnMobm9kZS5sb2NhbHZhcnMsIG91dHB1dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBhc3QuRXhjZXB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuYXJnbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcInZhciBcIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24obm9kZS5hcmduYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwi1ZDVj19FeGNlcHRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5lbmRfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGxheV9ib2R5KG5vZGUuYm9keSwgaXNfdG9wbGV2ZWwsIG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQuZW5kTG9jYWxCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWNsYXJlX3ZhcnModmFycywgb3V0cHV0KSB7XG4gICAgICAgICAgICBpZiAodmFycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwidmFyIFwiKTtcbiAgICAgICAgICAgICAgICB2YXJzLmZvckVhY2goZnVuY3Rpb24oYXJnLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmcucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuZW5kX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlY2xhcmVfZXhwb3J0cyhtb2R1bGVfaWQsIGV4cG9ydHMsIHN1Ym1vZHVsZXMsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyINWQ1Y9pdHI3NSwg1ZDVj2lkeDc1LCDVkNWPaXRyNzYsINWQ1Y9pZHg3NjtcbiAgICAgICAgICAgIHZhciBzZWVuLCBzeW1ib2wsIHN1Yl9tb2R1bGVfaWQsIGtleTtcbiAgICAgICAgICAgIHNlZW4gPSB7fTtcbiAgICAgICAgICAgINWQ1Y9pdHI3NSA9INWQ1Y9fSXRlcmFibGUoZXhwb3J0cyk7XG4gICAgICAgICAgICBmb3IgKNWQ1Y9pZHg3NSA9IDA7INWQ1Y9pZHg3NSA8INWQ1Y9pdHI3NS5sZW5ndGg7INWQ1Y9pZHg3NSsrKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0g1ZDVj2l0cjc1W9WQ1Y9pZHg3NV07XG4gICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KCfVkNWPX21vZHVsZXNbXCInICsgbW9kdWxlX2lkICsgJ1wiXVtcIicgKyBzeW1ib2wubmFtZSArICdcIl0gPSAnICsgc3ltYm9sLm5hbWUpO1xuICAgICAgICAgICAgICAgIHNlZW5bc3ltYm9sLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuZW5kX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAg1ZDVj2l0cjc2ID0g1ZDVj19JdGVyYWJsZShzdWJtb2R1bGVzKTtcbiAgICAgICAgICAgIGZvciAo1ZDVj2lkeDc2ID0gMDsg1ZDVj2lkeDc2IDwg1ZDVj2l0cjc2Lmxlbmd0aDsg1ZDVj2lkeDc2KyspIHtcbiAgICAgICAgICAgICAgICBzdWJfbW9kdWxlX2lkID0g1ZDVj2l0cjc2W9WQ1Y9pZHg3Nl07XG4gICAgICAgICAgICAgICAgaWYgKCFzZWVuLmhhc093blByb3BlcnR5KG1vZHVsZV9pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gc3ViX21vZHVsZV9pZC5zcGxpdChcIi5cIilbc3ViX21vZHVsZV9pZC5zcGxpdChcIi5cIikubGVuZ3RoLTFdO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludCgn1ZDVj19tb2R1bGVzW1wiJyArIG1vZHVsZV9pZCArICdcIl1bXCInICsga2V5ICsgJ1wiXSA9ICcpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoJ9WQ1Y9fbW9kdWxlc1tcIicgKyBzdWJfbW9kdWxlX2lkICsgJ1wiXScpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuZW5kX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bnBhY2tfdHVwbGUodHVwbGUsIG91dHB1dCwgaW5fc3RhdGVtZW50KSB7XG4gICAgICAgICAgICB0dXBsZS5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW0sIGkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmFzc2lnbihlbGVtKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQob3V0cHV0LnByZXZUZW1wKFwidXBrXCIpKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9zcXVhcmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWluX3N0YXRlbWVudCB8fCBpIDwgdHVwbGUuZWxlbWVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuZW5kX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhY2hlQnViYmxlKG9wZXJhbmQsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIHRtcDtcbiAgICAgICAgICAgIGlmICghKG9wZXJhbmQgaW5zdGFuY2VvZiBhc3QuU3ltYm9sUmVmIHx8IG9wZXJhbmQgaW5zdGFuY2VvZiBhc3QuU3ltYm9sQ2xhc3NSZWYpKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gb3V0cHV0Lm5ld1RlbXAoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZWQodG1wLCBcIj1cIiwgb3BlcmFuZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQ6IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KHRtcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3BlcmFuZC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQ7XG4gICAgICAgIH1cbiAgICAgICAgYXN0LlN0YXRlbWVudFdpdGhCb2R5LnByb3RvdHlwZS5fZG9fcHJpbnRfYm9keSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgICAgZm9yY2Vfc3RhdGVtZW50KHRoaXMuYm9keSwgb3V0cHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgREVGUFJJTlQoYXN0LlN0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBzZWxmLmJvZHkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEJBU0VMSUIgPSB7fTtcbiAgICAgICAgREVGUFJJTlQoYXN0LlRvcExldmVsLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciBpc19tYWluO1xuICAgICAgICAgICAgaXNfbWFpbiA9IG91dHB1dC5pc19tYWluKCk7XG4gICAgICAgICAgICBCQVNFTElCID0gc2VsZi5iYXNlbGliO1xuICAgICAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJwcml2YXRlX3Njb3BlXCIpICYmIGlzX21haW4pIHtcbiAgICAgICAgICAgICAgICB3cml0ZV9pbXBvcnRzKHNlbGYsIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImZ1bmN0aW9uKClcIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVfbWFpbl9uYW1lKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9jb21wbGV4X2JvZHkoc2VsZiwgdHJ1ZSwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIigpO1wiKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNfbWFpbikge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZV9pbXBvcnRzKHNlbGYsIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlX21haW5fbmFtZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyZV92YXJzKHNlbGYubG9jYWx2YXJzLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwbGF5X2JvZHkoc2VsZi5ib2R5LCB0cnVlLCBvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzX21haW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3RhcnRMb2NhbEJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKEJBU0VMSUIpLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmJhc2VsaWJbYV0gPiAwO1xuICAgICAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludF9iYXNlbGliKGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmVuZExvY2FsQnVmZmVyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gcHJpbnRfbW9kdWxlKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJmdW5jdGlvbigpXCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24oXCJ2YXIgX19uYW1lX19cIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludCgnXCInICsgc2VsZi5tb2R1bGVfaWQgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmVuZF9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyZV92YXJzKHNlbGYubG9jYWx2YXJzLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X2JvZHkoc2VsZi5ib2R5LCB0cnVlLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBkZWNsYXJlX2V4cG9ydHMoc2VsZi5tb2R1bGVfaWQsIHNlbGYuZXhwb3J0cywgc2VsZi5zdWJtb2R1bGVzLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIoKVwiKTtcbiAgICAgICAgICAgIG91dHB1dC5lbmRfc3RhdGVtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgREVGUFJJTlQoYXN0LlNwbGF0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQuaW1wb3J0KHNlbGYubW9kdWxlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheV9ib2R5KHNlbGYuYm9keS5ib2R5LCB0cnVlLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuSW1wb3J0cywgZnVuY3Rpb24oY29udGFpbmVyLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciDVkNWPaXRyNzcsINWQ1Y9pZHg3Nywg1ZDVj2l0cjc4LCDVkNWPaWR4Nzg7XG4gICAgICAgICAgICB2YXIgc2VsZiwgYXJnbmFtZSwgYWxpYXMsIGJvdW5kX25hbWU7XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRfYW5hbWUoYW5hbWUsIGtleSwgZnJvbV9pbXBvcnQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuYXNzaWduKFwidmFyIFwiICsgYW5hbWUpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludCgn1ZDVj19tb2R1bGVzW1wiJyArIGtleSArICdcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbV9pbXBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiLlwiICsgZnJvbV9pbXBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuZW5kX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgINWQ1Y9pdHI3NyA9INWQ1Y9fSXRlcmFibGUoY29udGFpbmVyLmltcG9ydHMpO1xuICAgICAgICAgICAgZm9yICjVkNWPaWR4NzcgPSAwOyDVkNWPaWR4NzcgPCDVkNWPaXRyNzcubGVuZ3RoOyDVkNWPaWR4NzcrKykge1xuICAgICAgICAgICAgICAgIHNlbGYgPSDVkNWPaXRyNzdb1ZDVj2lkeDc3XTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuaW1wb3J0KHNlbGYubW9kdWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmFyZ25hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgINWQ1Y9pdHI3OCA9INWQ1Y9fSXRlcmFibGUoc2VsZi5hcmduYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDc4ID0gMDsg1ZDVj2lkeDc4IDwg1ZDVj2l0cjc4Lmxlbmd0aDsg1ZDVj2lkeDc4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ25hbWUgPSDVkNWPaXRyNzhb1ZDVj2lkeDc4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzID0gYXJnbmFtZS5hbGlhcyA/IGFyZ25hbWUuYWxpYXMubmFtZSA6IGFyZ25hbWUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZF9hbmFtZShhbGlhcywgc2VsZi5rZXksIGFyZ25hbWUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbGlhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkX2FuYW1lKHNlbGYuYWxpYXMubmFtZSwgc2VsZi5rZXksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kX25hbWUgPSBzZWxmLmtleS5zcGxpdChcIi5cIiwgMSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRfYW5hbWUoYm91bmRfbmFtZSwgYm91bmRfbmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgREVGUFJJTlQoYXN0LkxhYmVsZWRTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgc2VsZi5sYWJlbC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgICAgICBzZWxmLmJvZHkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5TaW1wbGVTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgaWYgKCEoc2VsZi5ib2R5IGluc3RhbmNlb2YgYXN0LkVtcHR5U3RhdGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHNlbGYuYm9keS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHByaW50X2JyYWNrZXRlZChub2RlLCBvdXRwdXQsIGNvbXBsZXgpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X2NvbXBsZXhfYm9keShub2RlLCBmYWxzZSwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfYm9keShub2RlLmJvZHksIGZhbHNlLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcInt9XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIERFRlBSSU5UKGFzdC5CbG9ja1N0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBwcmludF9icmFja2V0ZWQoc2VsZiwgb3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5FbXB0eVN0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuRG8sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiZG9cIik7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwid2hpbGVcIik7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbi5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuV2hpbGUsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwid2hpbGVcIik7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbi5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGlzX3NpbXBsZV9mb3JfaW4oc2VsZikge1xuICAgICAgICAgICAgaWYgKHNlbGYub2JqZWN0IGluc3RhbmNlb2YgYXN0LkJhc2VDYWxsICYmIHNlbGYub2JqZWN0LmV4cHJlc3Npb24gaW5zdGFuY2VvZiBhc3QuU3ltYm9sUmVmICYmIHNlbGYub2JqZWN0LmV4cHJlc3Npb24ubmFtZSA9PT0gXCJkaXJcIiAmJiBzZWxmLm9iamVjdC5hcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzX3NpbXBsZV9mb3Ioc2VsZikge1xuICAgICAgICAgICAgaWYgKHNlbGYub2JqZWN0IGluc3RhbmNlb2YgYXN0LkJhc2VDYWxsICYmIHNlbGYub2JqZWN0LmV4cHJlc3Npb24gaW5zdGFuY2VvZiBhc3QuU3ltYm9sUmVmICYmIHNlbGYub2JqZWN0LmV4cHJlc3Npb24ubmFtZSA9PT0gXCJyYW5nZVwiICYmICEoc2VsZi5pbml0IGluc3RhbmNlb2YgYXN0LkFycmF5KSAmJiAoc2VsZi5vYmplY3QuYXJncy5sZW5ndGggPCAzIHx8IHNlbGYub2JqZWN0LmFyZ3Nbc2VsZi5vYmplY3QuYXJncy5sZW5ndGgtMV1bMF0gaW5zdGFuY2VvZiBhc3QuTnVtYmVyIHx8IHNlbGYub2JqZWN0LmFyZ3Nbc2VsZi5vYmplY3QuYXJncy5sZW5ndGgtMV1bMF0gaW5zdGFuY2VvZiBhc3QuVW5hcnkgJiYgc2VsZi5vYmplY3QuYXJnc1tzZWxmLm9iamVjdC5hcmdzLmxlbmd0aC0xXVswXS5vcGVyYXRvciA9PT0gXCItXCIgJiYgc2VsZi5vYmplY3QuYXJnc1tzZWxmLm9iamVjdC5hcmdzLmxlbmd0aC0xXVswXS5leHByZXNzaW9uIGluc3RhbmNlb2YgYXN0Lk51bWJlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBhc3QuRm9ySW4ucHJvdG90eXBlLl9kb19wcmludF9ib2R5ID0gZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgICAgICB2YXIgc2VsZjtcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhdG9yLCBpbmRleCwgdW5wYWNrO1xuICAgICAgICAgICAgICAgIGlmICghKGlzX3NpbXBsZV9mb3Ioc2VsZikgfHwgaXNfc2ltcGxlX2Zvcl9pbihzZWxmKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IG91dHB1dC5wcmV2VGVtcChcIml0clwiKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBvdXRwdXQucHJldlRlbXAoXCJpZHhcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmluaXQgaW5zdGFuY2VvZiBhc3QuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwiZXM2XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfc3F1YXJlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluaXQuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4KSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoaXRlcmF0b3IgKyBcIltcIiArIGluZGV4ICsgXCJdO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnBhY2sgPSBvdXRwdXQubmV3VGVtcChcInVwa1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYXNzaWduKHVucGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KGl0ZXJhdG9yICsgXCJbXCIgKyBpbmRleCArIFwiXTtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnBhY2tfdHVwbGUoc2VsZi5pbml0LCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFzc2lnbihzZWxmLmluaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KGl0ZXJhdG9yICsgXCJbXCIgKyBpbmRleCArIFwiXTtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuYm9keS5ib2R5LmZvckVhY2goZnVuY3Rpb24oc3RtdCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBERUZQUklOVChhc3QuRm9ySW4sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIGluY3JlbWVudCwgYXJncywgdG1wXywgc3RhcnQsIGVuZCwgaXRlcmF0b3I7XG4gICAgICAgICAgICBpZiAoaXNfc2ltcGxlX2ZvcihzZWxmKSkge1xuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgYXJncyA9IHNlbGYub2JqZWN0LmFyZ3M7XG4gICAgICAgICAgICAgICAgdG1wXyA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICh0bXBfID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcF8gPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBhcmdzWzFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wXyA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGFyZ3NbMV07XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IGFyZ3NbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImZvclwiKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24oc2VsZi5pbml0KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQucHJpbnQgPyBzdGFydC5wcmludChvdXRwdXQpIDogb3V0cHV0LnByaW50KHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbml0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnQgaW5zdGFuY2VvZiBhc3QuVW5hcnkgPyBvdXRwdXQucHJpbnQoXCI+XCIpIDogb3V0cHV0LnByaW50KFwiPFwiKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVuZC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmluaXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluY3JlbWVudCAmJiAoIShpbmNyZW1lbnQgaW5zdGFuY2VvZiBhc3QuVW5hcnkpIHx8IGluY3JlbWVudC5leHByZXNzaW9uLnZhbHVlICE9PSBcIjFcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgaW5zdGFuY2VvZiBhc3QuVW5hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCItPVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnQuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIrPVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgaW5zdGFuY2VvZiBhc3QuVW5hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCItLVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiKytcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNfc2ltcGxlX2Zvcl9pbihzZWxmKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImZvclwiKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZWQoc2VsZi5pbml0LCBcImluXCIsIHNlbGYub2JqZWN0LmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IG91dHB1dC5uZXdUZW1wKFwiaXRyXCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24oaXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcItWQ1Y9fSXRlcmFibGVcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9iamVjdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG91dHB1dC5lbmRfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImZvclwiKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBvdXRwdXQubmV3VGVtcChcImlkeFwiKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFzc2lnbihpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIjBcIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZWQoaW5kZXgsIFwiPFwiLCBpdGVyYXRvciArIFwiLmxlbmd0aFwiKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KGluZGV4ICsgXCIrK1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXN0LkZvckpTLnByb3RvdHlwZS5fZG9fcHJpbnRfYm9keSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIHNlbGY7XG4gICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYm9keS5ib2R5LmZvckVhY2goZnVuY3Rpb24oc3RtdCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBERUZQUklOVChhc3QuRm9ySlMsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiZm9yXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuTGlzdENvbXByZWhlbnNpb24sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yLCBpdGVyYXRvciwgaW5kZXgsIHJlc3VsdCwgYWRkX2VudHJ5O1xuICAgICAgICAgICAgY29uc3RydWN0b3IgPSB7XG4gICAgICAgICAgICAgICAgTGlzdENvbXByZWhlbnNpb246IFwiW11cIixcbiAgICAgICAgICAgICAgICBEaWN0Q29tcHJlaGVuc2lvbjogXCJ7fVwiXG4gICAgICAgICAgICB9W9WQ1Y9fdHlwZShzZWxmKV07XG4gICAgICAgICAgICBpdGVyYXRvciA9IG91dHB1dC5uZXdUZW1wKFwiaXRyXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIGluZGV4ID0gb3V0cHV0Lm5ld1RlbXAoXCJpZHhcIiwgZmFsc2UpO1xuICAgICAgICAgICAgcmVzdWx0ID0gUkFQWURfUFJFRklYICsgXCJyZXNcIjtcbiAgICAgICAgICAgIGlmIChzZWxmIGluc3RhbmNlb2YgYXN0LkRpY3RDb21wcmVoZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgYWRkX2VudHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX3NxdWFyZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc3RhdGVtZW50LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYXNzaWduKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnZhbHVlX3N0YXRlbWVudC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuZW5kX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZF9lbnRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChyZXN1bHQgKyBcIi5wdXNoXCIpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YXRlbWVudC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmVuZF9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIigpXCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcInZhciBcIiArIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24oaXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCLVkNWPX0l0ZXJhYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9iamVjdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24ocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaW5pdCBpbnN0YW5jZW9mIGFzdC5BcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbml0LmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluaXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiZm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlZChpbmRleCwgXCI9XCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlZChpbmRleCwgXCI8XCIsIGl0ZXJhdG9yICsgXCIubGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoaW5kZXggKyBcIisrXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaW5pdCBpbnN0YW5jZW9mIGFzdC5BcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwiZXM2XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX3NxdWFyZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5pdC5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4KSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYXNzaWduKG91dHB1dC5uZXdUZW1wKFwidXBrXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KGl0ZXJhdG9yICsgXCJbXCIgKyBpbmRleCArIFwiXTtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW91dHB1dC5vcHRpb24oXCJlczZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5wYWNrX3R1cGxlKHNlbGYuaW5pdCwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24oc2VsZi5pbml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoaXRlcmF0b3IgKyBcIltcIiArIGluZGV4ICsgXCJdO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImlmXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX2VudHJ5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX2VudHJ5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcInJldHVybiBcIiArIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5lbmRfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIigpXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgREVGUFJJTlQoYXN0LldpdGgsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwid2l0aFwiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGRlY29yYXRlKGRlY29yYXRvcnMsIG91dHB1dCwgaW50ZXJuYWxzdWIpIHtcbiAgICAgICAgICAgIHZhciBwb3MsIHdyYXA7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICAgICAgd3JhcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPCBkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0b3JzW3Bvc10uZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICArK3BvcztcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHN1YigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3cmFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVjb3JhdGVkKGRlY29yYXRvcnMsIG91dHB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGJhc2VGbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdGUoZGVjb3JhdG9ycywgb3V0cHV0LCBiYXNlRm4pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGFzdC5MYW1iZGEucHJvdG90eXBlLl9kb19wcmludCA9IGZ1bmN0aW9uKG91dHB1dCwgbm9rZXl3b3JkKSB7XG4gICAgICAgICAgICB2YXIg1ZDVj18xMjE7XG4gICAgICAgICAgICB2YXIgc2VsZiwgbmFtZTtcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZnVuY3Rpb24gYWRkRGVjb3JhdG9ycygpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kZWNvcmF0b3JzICYmIHNlbGYuZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYXNzaWduKG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0ZShzZWxmLmRlY29yYXRvcnMsIG91dHB1dCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGREb2NzdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZG9jc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZFByb3BlcnR5KFwiX19kb2NfX1wiLCBzZWxmLmRvY3N0cmluZykuY2FsbChvdXRwdXQsIG9iaik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc2VsZi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwidmFyIFwiICsgc2VsZi5uYW1lLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBpbnRlcm5hbHN1YiA9ICjVkNWPXzEyMSA9IGZ1bmN0aW9uIGludGVybmFsc3ViKCkge1xuICAgICAgICAgICAgICAgIGlmICghbm9rZXl3b3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5nZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIipcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5uYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcmduYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGFyZywgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZy5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJlczZcIikgJiYgc2VsZi5hcmduYW1lcy5kZWZhdWx0c1thcmcubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXJnbmFtZXMuZGVmYXVsdHNbYXJnLm5hbWVdLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5rd2FyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFyZ25hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwi1ZDVj19rd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgIHByaW50X2JyYWNrZXRlZChzZWxmLCBvdXRwdXQsIHRydWUpO1xuICAgICAgICAgICAgfSwg1ZDVj18xMjEgPSB1bmlmeShvdXRwdXQsIG5hbWUsIGFkZERlY29yYXRvcnMoKSwgYWRkRG9jc3RyaW5nKCkpKNWQ1Y9fMTIxKSwg1ZDVj18xMjEpO1xuICAgICAgICAgICAgaW50ZXJuYWxzdWIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgREVGUFJJTlQoYXN0LkxhbWJkYSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXN0LkNsYXNzLnByb3RvdHlwZS5fZG9fcHJpbnQgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmLCBuYW1lLCBnZW5lcmF0ZUNsYXNzO1xuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VsZi5leHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZERlY29yYXRvcnMoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZGVjb3JhdG9ycyAmJiBzZWxmLmRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciDVkNWPaXRyNzksINWQ1Y9pZHg3OTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQsIHN0bXQsIGZ1bmNOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24ob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRlKHNlbGYuZGVjb3JhdG9ycywgb3V0cHV0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJlczZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICDVkNWPaXRyNzkgPSDVkNWPX0l0ZXJhYmxlKHNlbGYuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4NzkgPSAwOyDVkNWPaWR4NzkgPCDVkNWPaXRyNzkubGVuZ3RoOyDVkNWPaWR4NzkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG10ID0g1ZDVj2l0cjc5W9WQ1Y9pZHg3OV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG10IGluc3RhbmNlb2YgYXN0LkxhbWJkYSAmJiBzdG10LmRlY29yYXRvcnMgJiYgc3RtdC5kZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY05hbWUgPSBvYmogKyBcIi5wcm90b3R5cGUuXCIgKyBzdG10Lm5hbWUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFzc2lnbihmdW5jTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0ZShzdG10LmRlY29yYXRvcnMsIG91dHB1dCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KGZ1bmNOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNlbGYubmFtZSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcInZhciBcIiArIHNlbGYubmFtZS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gb3V0cHV0RXM2KCkge1xuICAgICAgICAgICAgICAgIHZhciDVkNWPXzEyMjtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRDbGFzc1ZhcmlhYmxlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZG9jc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW1wiX19kb2NfX1wiXSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludF9zdHJpbmcoc2VsZi5kb2NzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkuZm9yRWFjaChmdW5jdGlvbihzdG10LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdCBpbnN0YW5jZW9mIGFzdC5TaW1wbGVTdGF0ZW1lbnQgJiYgc3RtdC5ib2R5IGluc3RhbmNlb2YgYXN0LkFzc2lnbiAmJiBzdG10LmJvZHkub3BlcmF0b3IgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc1tzdG10LmJvZHkubGVmdC5uYW1lXSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG10LmJvZHkucmlnaHQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5hZGRQcm9wZXJ0aWVzKFwicHJvdG90eXBlXCIsIHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZ2VuZXJhdGVDbGFzcyA9ICjVkNWPXzEyMiA9IGZ1bmN0aW9uIGdlbmVyYXRlQ2xhc3MoKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImNsYXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJleHRlbmRzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcmVudC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0bXQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdCBpbnN0YW5jZW9mIGFzdC5MYW1iZGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcInN0YXRpY1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG10Lm5hbWUubmFtZSA9PT0gXCJfX2luaXRfX1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG10IGluc3RhbmNlb2YgYXN0Lk9iamVjdEdldHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImdldCBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0bXQgaW5zdGFuY2VvZiBhc3QuT2JqZWN0U2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwic2V0IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0bXQubmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG10LmFyZ25hbWVzLmZvckVhY2goZnVuY3Rpb24oYXJnLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKNWQ1Y9faW4obmFtZSwgc2VsZi5zdGF0aWMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuYXJnbmFtZXMuZGVmYXVsdHNbYXJnLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIj1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0bXQuYXJnbmFtZXMuZGVmYXVsdHNbYXJnLm5hbWVdLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5rd2FyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmduYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcItWQ1Y9fa3dcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRfYnJhY2tldGVkKHN0bXQsIG91dHB1dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sINWQ1Y9fMTIyID0gdW5pZnkob3V0cHV0LCBuYW1lLCBhZGREZWNvcmF0b3JzKCksIGFkZENsYXNzVmFyaWFibGVzKCkpKNWQ1Y9fMTIyKSwg1ZDVj18xMjIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUNsYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gb3V0cHV0RXM1KCkge1xuICAgICAgICAgICAgICAgIHZhciDVkNWPdXBrMTEsINWQ1Y9fMTIzO1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2RzQW5kVmFycywgc3RhdGljbWV0aG9kcztcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWZpbmVfbWV0aG9kKHN0bXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gc3RtdC5uYW1lLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbHN1YigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG10LmFyZ25hbWVzLmZvckVhY2goZnVuY3Rpb24oYXJnLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICjVkNWPX2luKG5hbWUsIHNlbGYuc3RhdGljKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmt3YXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJnbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCLVkNWPX2t3XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRfYnJhY2tldGVkKHN0bXQsIG91dHB1dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5kZWNvcmF0b3JzICYmIHN0bXQuZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0ZShzdG10LmRlY29yYXRvcnMsIG91dHB1dCwgaW50ZXJuYWxzdWIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHN1YigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkSW5oZXJpdGFuY2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCLVkNWPX2V4dGVuZHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRNZXRob2RzKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kc0FuZFZhcnMsIHN0YXRpY01ldGhvZHMsIG1ldGhvZEFuZE91dHB1dCwgbWV0aG9kQW5kVmFyT3V0cHV0LCBzdGF0aWNNZXRob2RPdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHNBbmRWYXJzID0ge307XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY01ldGhvZHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZG9jc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzQW5kVmFyc1tcIl9fZG9jX19cIl0gPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKHNlbGYuZG9jc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5LmZvckVhY2goZnVuY3Rpb24oc3RtdCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQgaW5zdGFuY2VvZiBhc3QuTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY01ldGhvZHNbc3RtdC5uYW1lLm5hbWVdID0gZGVmaW5lX21ldGhvZChzdG10KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzQW5kVmFyc1tzdG10Lm5hbWUubmFtZV0gPSBkZWZpbmVfbWV0aG9kKHN0bXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RtdCBpbnN0YW5jZW9mIGFzdC5TaW1wbGVTdGF0ZW1lbnQgJiYgc3RtdC5ib2R5IGluc3RhbmNlb2YgYXN0LkFzc2lnbiAmJiBzdG10LmJvZHkub3BlcmF0b3IgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kc0FuZFZhcnNbc3RtdC5ib2R5LmxlZnQubmFtZV0gPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RtdC5ib2R5LnJpZ2h0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RtdCBpbnN0YW5jZW9mIGFzdC5DbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOZXN0ZWQgY2xhc3NlcyBhcmVuJ3Qgc3VwcG9ydGVkIHlldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZEFuZE91dHB1dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhtZXRob2RzQW5kVmFycykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RBbmRWYXJPdXRwdXQgPSBvdXRwdXQuYWRkUHJvcGVydGllcyhcInByb3RvdHlwZVwiLCBtZXRob2RzQW5kVmFycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGljTWV0aG9kT3V0cHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YXRpY01ldGhvZHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljTWV0aG9kT3V0cHV0ID0gb3V0cHV0LmFkZFByb3BlcnRpZXMobnVsbCwgc3RhdGljTWV0aG9kcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRob2RBbmRWYXJPdXRwdXQsIHN0YXRpY01ldGhvZE91dHB1dF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgINWQ1Y91cGsxMSA9IGFkZE1ldGhvZHMoKTtcbiAgICAgICAgICAgICAgICBtZXRob2RzQW5kVmFycyA9INWQ1Y91cGsxMVswXTtcbiAgICAgICAgICAgICAgICBzdGF0aWNtZXRob2RzID0g1ZDVj3VwazExWzFdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBnZW5lcmF0ZUNsYXNzID0gKNWQ1Y9fMTIzID0gZnVuY3Rpb24gZ2VuZXJhdGVDbGFzcygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaW5pdCB8fCBzZWxmLnBhcmVudCB8fCBzZWxmLnN0YXRlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5uYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIoKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRfbWV0aG9kcyhzZWxmLmJvdW5kLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmluaXQgfHwgc2VsZi5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbmFtZSA9IHNlbGYuaW5pdCA/IHNlbGYubmFtZSA6IHNlbGYucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ0aGlzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJhcmd1bWVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuZW5kX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiKClcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRfbWV0aG9kcyhzZWxmLmJvdW5kLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCDVkNWPXzEyMyA9IHVuaWZ5KG91dHB1dCwgbmFtZSwgYWRkSW5oZXJpdGFuY2UoKSwgYWRkRGVjb3JhdG9ycygpLCBtZXRob2RzQW5kVmFycywgc3RhdGljbWV0aG9kcyko1ZDVj18xMjMpLCDVkNWPXzEyMyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlQ2xhc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcImVzNlwiKSkge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQ2xhc3MgPSBvdXRwdXRFczYoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVDbGFzcyA9IG91dHB1dEVzNSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuZXJhdGVDbGFzcygpO1xuICAgICAgICB9O1xuICAgICAgICBERUZQUklOVChhc3QuQ2xhc3MsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5TeW1ib2xDbGFzc1JlZiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBzZWxmLmNsYXNzLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIucHJvdG90eXBlLlwiICsgc2VsZi5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFzdC5FeGl0LnByb3RvdHlwZS5fZG9fcHJpbnQgPSBmdW5jdGlvbihvdXRwdXQsIGtpbmQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmO1xuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoa2luZCk7XG4gICAgICAgICAgICBpZiAoc2VsZi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgIHNlbGYudmFsdWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgREVGUFJJTlQoYXN0LlJldHVybiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQsIFwicmV0dXJuXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgREVGUFJJTlQoYXN0LllpZWxkLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJ5aWVsZFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5UaHJvdywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQsIFwidGhyb3dcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBhc3QuTG9vcENvbnRyb2wucHJvdG90eXBlLl9kb19wcmludCA9IGZ1bmN0aW9uKG91dHB1dCwga2luZCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KGtpbmQpO1xuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgICAgIH07XG4gICAgICAgIERFRlBSSU5UKGFzdC5CcmVhaywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQsIFwiYnJlYWtcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuQ29udGludWUsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcImNvbnRpbnVlXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gbWFrZV90aGVuKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcImJyYWNrZXRpemVcIikpIHtcbiAgICAgICAgICAgICAgICBtYWtlX2Jsb2NrKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuYm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQuZm9yY2Vfc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5ID0gc2VsZi5ib2R5O1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYm9keSBpbnN0YW5jZW9mIGFzdC5JZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJvZHkuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VfYmxvY2soc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5LmFsdGVybmF0aXZlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIGFzdC5TdGF0ZW1lbnRXaXRoQm9keSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gYm9keS5ib2R5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcmNlX3N0YXRlbWVudChzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgREVGUFJJTlQoYXN0LklmLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImlmXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIG1ha2VfdGhlbihzZWxmLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImVsc2VcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgZm9yY2Vfc3RhdGVtZW50KHNlbGYuYWx0ZXJuYXRpdmUsIG91dHB1dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5Td2l0Y2gsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwic3dpdGNoXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0bXQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG10LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFzdC5Td2l0Y2hCcmFuY2gucHJvdG90eXBlLl9kb19wcmludF9ib2R5ID0gZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0bXQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBzdG10LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERFRlBSSU5UKGFzdC5EZWZhdWx0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImRlZmF1bHQ6XCIpO1xuICAgICAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgREVGUFJJTlQoYXN0LkNhc2UsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiY2FzZVwiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI6XCIpO1xuICAgICAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgREVGUFJJTlQoYXN0LlRyeSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ0cnlcIik7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHByaW50X2JyYWNrZXRlZChzZWxmLCBvdXRwdXQpO1xuICAgICAgICAgICAgaWYgKHNlbGYuYmNhdGNoKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5iY2F0Y2gucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmJmaW5hbGx5KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5iZmluYWxseS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgREVGUFJJTlQoYXN0LkNhdGNoLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImNhdGNoXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwi1ZDVj19FeGNlcHRpb25cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuYm9keS5sZW5ndGggPiAxIHx8IHNlbGYuYm9keVswXS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub19kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG5vX2RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkuZm9yRWFjaChmdW5jdGlvbihleGNlcHRpb24sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub19kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJlbHNlIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGNlcHRpb24uZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImlmXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uLmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uKGVyciwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ8fFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZWQoXCLVkNWPX0V4Y2VwdGlvblwiLCBcImluc3RhbmNlb2ZcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vX2RlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X2JyYWNrZXRlZChleGNlcHRpb24sIG91dHB1dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub19kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJlbHNlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlZChcInRocm93XCIsIFwi1ZDVj19FeGNlcHRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmVuZF9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByaW50X2JyYWNrZXRlZChzZWxmLmJvZHlbMF0sIG91dHB1dCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuRmluYWxseSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJmaW5hbGx5XCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBwcmludF9icmFja2V0ZWQoc2VsZiwgb3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFzdC5EZWZpbml0aW9ucy5wcm90b3R5cGUuX2RvX3ByaW50ID0gZnVuY3Rpb24ob3V0cHV0LCBraW5kKSB7XG4gICAgICAgICAgICB2YXIgcCwgaW5fZm9yLCBhdm9pZF9zZW1pY29sb247XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoa2luZCk7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihkZWZfLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZl8ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgICAgIGluX2ZvciA9IHAgaW5zdGFuY2VvZiBhc3QuRm9ySW47XG4gICAgICAgICAgICBhdm9pZF9zZW1pY29sb24gPSBpbl9mb3IgJiYgcC5pbml0ID09PSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFhdm9pZF9zZW1pY29sb24pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERFRlBSSU5UKGFzdC5WYXIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcInZhclwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5Db25zdCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQsIFwiY29uc3RcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBwYXJlbnRoZXNpemVfZm9yX25vaW4obm9kZSwgb3V0cHV0LCBub2luKSB7XG4gICAgICAgICAgICBpZiAoIW5vaW4pIHtcbiAgICAgICAgICAgICAgICBub2RlLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUud2FsayhuZXcgYXN0LlRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBhc3QuQmluYXJ5ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiaW5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAo1ZDVj19FeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4ID0g1ZDVj19FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChleCAhPT0gb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlLnByaW50KG91dHB1dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIERFRlBSSU5UKGFzdC5WYXJEZWYsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgc2VsZi5uYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICBpZiAoc2VsZi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24oXCJcIik7XG4gICAgICAgICAgICAgICAgcGFyZW50aGVzaXplX2Zvcl9ub2luKHNlbGYudmFsdWUsIG91dHB1dCwgb3V0cHV0LnBhcmVudCgxKSBpbnN0YW5jZW9mIGFzdC5Gb3JJbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBDUkVBVElPTiA9IFtdO1xuICAgICAgICBERUZQUklOVChhc3QuQmFzZUNhbGwsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIHNlbGZBcmcsIG9iamVjdCwgaGFzX2t3YXJnX2l0ZW1zLCBoYXNfa3dhcmdfZm9ybWFscywgaGFzX2t3YXJncywgb2JqLCBvdXRwdXRfa3dhcmdzO1xuICAgICAgICAgICAgc2VsZkFyZyA9IG51bGw7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsX2Zvcm1hdCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVuYW1lO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmIGluc3RhbmNlb2YgYXN0LkNsYXNzQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xhc3MucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi5cIiArIHNlbGYubWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvdXRwdXQub3B0aW9uKFwiZXM2XCIpICYmIHNlbGYuc3VwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcInN1cGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubWV0aG9kICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIuXCIgKyBzZWxmLm1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmQXJnID0gc2VsZi5hcmdzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsYXNzLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIucHJvdG90eXBlLlwiICsgc2VsZi5tZXRob2QgKyBcIi5jYWxsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuYW1lID0g1ZDVj19pbihzZWxmLmV4cHJlc3Npb24ubmFtZSwgU1BFQ0lBTF9NRVRIT0RTKSA/IFNQRUNJQUxfTUVUSE9EU1tzZWxmLmV4cHJlc3Npb24ubmFtZV0gOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChyZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZiBpbnN0YW5jZW9mIGFzdC5OZXcpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBDUkVBVElPTi5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9fY29uc3RydWN0b3JfcGFyZW5zKHNlbGYsIG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbF9mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc19rd2FyZ19pdGVtcyA9IHNlbGYuYXJncy5rd2FyZ19pdGVtcyAmJiBzZWxmLmFyZ3Mua3dhcmdfaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgaGFzX2t3YXJnX2Zvcm1hbHMgPSBzZWxmLmFyZ3Mua3dhcmdzICYmIHNlbGYuYXJncy5rd2FyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgaGFzX2t3YXJncyA9IGhhc19rd2FyZ19pdGVtcyB8fCBoYXNfa3dhcmdfZm9ybWFscztcbiAgICAgICAgICAgIGlmIChzZWxmLmFyZ3Muc3RhcmFyZ3MgfHwgaGFzX2t3YXJncykge1xuICAgICAgICAgICAgICAgIG9iaiA9IHNlbGYgaW5zdGFuY2VvZiBhc3QuTmV3ID8gb2JqZWN0IDogc2VsZi5leHByZXNzaW9uLmV4cHJlc3Npb24gPyBzZWxmLmV4cHJlc3Npb24uZXhwcmVzc2lvbiA6IG5ldyBhc3QuVGhpcygpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwiZXM2XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNfa3dhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJrd2FyZ3NcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbF9mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbF9mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmIGluc3RhbmNlb2YgYXN0Lk5ldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbF9mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzX2t3YXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImt3YXJnc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIuX19pbml0X19cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi5fX2luaXRfX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNfa3dhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJrd2FyZ3NcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbF9mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbF9mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbF9mb3JtYXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dF9rd2FyZ3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzX2t3YXJnX2l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXJncy5rd2FyZ19pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGt3bmFtZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGt3bmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc19rd2FyZ19mb3JtYWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc19rd2FyZ19mb3JtYWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIntcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXJncy5rd2FyZ3MuZm9yRWFjaChmdW5jdGlvbihwYWlyLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpclswXS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFpclsxXS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwifVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJlczZcIikgJiYgc2VsZi5hcmdzLnN0YXJhcmdzKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFyZ3MuZm9yRWFjaChmdW5jdGlvbihleHByLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5zdGFyYXJncyAmJiBpID09PSBzZWxmLmFyZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuYXJncy5zdGFyYXJncykge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi5hcHBseVwiKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9zcXVhcmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hcmdzLnNsaWNlKDAsIC0xKS5mb3JFYWNoKGZ1bmN0aW9uKGV4cHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hcmdzWzBdLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc19rd2FyZ3MgfHwgc2VsZi5hcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi5jb25jYXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXJnc1tzZWxmLmFyZ3MubGVuZ3RoLTFdLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNfa3dhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRfa3dhcmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNfa3dhcmdzICYmIChzZWxmIGluc3RhbmNlb2YgYXN0Lk5ldyB8fCBzZWxmLmV4cHJlc3Npb24gJiYgc2VsZi5leHByZXNzaW9uLmV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiLmNhbGxcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjgwLCDVkNWPaWR4ODA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICAgICAgICAgIG9iai5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICDVkNWPaXRyODAgPSDVkNWPX0l0ZXJhYmxlKHNlbGYuYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDgwID0gMDsg1ZDVj2lkeDgwIDwg1ZDVj2l0cjgwLmxlbmd0aDsg1ZDVj2lkeDgwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9INWQ1Y9pdHI4MFvVkNWPaWR4ODBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0X2t3YXJncygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXJncy5mb3JFYWNoKGZ1bmN0aW9uKGV4cHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzX2t3YXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF9rd2FyZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJlczZcIikgJiYgc2VsZiBpbnN0YW5jZW9mIGFzdC5DbGFzc0NhbGwgJiYgc2VsZi5zdXBlcikge1xuICAgICAgICAgICAgICAgIG91dHB1dC5lbmRfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZWQoXCJ2YXJcIiwgc2VsZkFyZywgXCI9XCIsIFwidGhpc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5OZXcsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwibmV3XCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBhc3QuQmFzZUNhbGwucHJvdG90eXBlLl9jb2RlZ2VuKHNlbGYsIG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhc3QuU2VxLnByb3RvdHlwZS5fZG9fcHJpbnQgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmLCBwLCBwcmludF9zZXE7XG4gICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgICAgICBwcmludF9zZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhci5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNkcikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5zaG91bGRfYnJlYWsoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNkci5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIGFzdC5CaW5hcnkgfHwgcCBpbnN0YW5jZW9mIGFzdC5SZXR1cm4gfHwgcCBpbnN0YW5jZW9mIGFzdC5BcnJheSB8fCBwIGluc3RhbmNlb2YgYXN0LkJhc2VDYWxsIHx8IHAgaW5zdGFuY2VvZiBhc3QuU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfc3F1YXJlKHByaW50X3NlcSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByaW50X3NlcSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBERUZQUklOVChhc3QuU2VxLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuRG90LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciBleHByO1xuICAgICAgICAgICAgZXhwciA9IHNlbGYuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4cHIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgYXN0Lk51bWJlciAmJiBleHByLmdldFZhbHVlKCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICghL1t4YS1mLl0vaS50ZXN0KG91dHB1dC5sYXN0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiLlwiKTtcbiAgICAgICAgICAgIG91dHB1dC5hZGRfbWFwcGluZyhzZWxmLmVuZCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnRfbmFtZShzZWxmLnByb3BlcnR5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5TdWIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJbXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYucHJvcGVydHkgaW5zdGFuY2VvZiBhc3QuVW5hcnkgJiYgc2VsZi5wcm9wZXJ0eS5vcGVyYXRvciA9PT0gXCItXCIgJiYgc2VsZi5wcm9wZXJ0eS5leHByZXNzaW9uIGluc3RhbmNlb2YgYXN0Lk51bWJlcikge1xuICAgICAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi5sZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnByb3BlcnR5LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJdXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgREVGUFJJTlQoYXN0LlNsaWNlLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIltdLnNwbGljZS5hcHBseVwiKTtcbiAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9zcXVhcmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJvcGVydHkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJvcGVydHkyLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi1cIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJvcGVydHkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIuY29uY2F0XCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hc3NpZ25tZW50LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5VbmFyeVByZWZpeCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICB2YXIgb3A7XG4gICAgICAgICAgICBvcCA9IHNlbGYub3BlcmF0b3I7XG4gICAgICAgICAgICBpZiAob3AgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJlczZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBcIi4uLlwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQob3ApO1xuICAgICAgICAgICAgaWYgKC9eW2Etel0vaS50ZXN0KG9wKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuVW5hcnlQb3N0Zml4LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KHNlbGYub3BlcmF0b3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgREVGUFJJTlQoYXN0LkJpbmFyeSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICB2YXIgY29tcGFyYXRvcnMsIGZ1bmN0aW9uX29wcywgbm9ybWFsaXplLCBvcGVyYXRvciwgbGVmdHZhcjtcbiAgICAgICAgICAgIGNvbXBhcmF0b3JzID0ge1xuICAgICAgICAgICAgICAgIFwiPFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiPlwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiPD1cIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIj49XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCI9PVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiIT1cIjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uX29wcyA9IHtcbiAgICAgICAgICAgICAgICBcImluXCI6IFwi1ZDVj19pblwiLFxuICAgICAgICAgICAgICAgIFwiKipcIjogXCJNYXRoLnBvd1wiLFxuICAgICAgICAgICAgICAgIFwiLy9cIjogXCJNYXRoLmZsb29yXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub3JtYWxpemUgPSBmdW5jdGlvbihvcCkge1xuICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gXCI9PVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIj09PVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AgPT09IFwiIT1cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIhPT1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICjVkNWPX2luKHNlbGYub3BlcmF0b3IsIGZ1bmN0aW9uX29wcykpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoZnVuY3Rpb25fb3BzW3NlbGYub3BlcmF0b3JdKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGVmdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcGVyYXRvciA9PT0gXCIvL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmlnaHQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGFyYXRvcnNbc2VsZi5vcGVyYXRvcl0gJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgYXN0LkJpbmFyeSAmJiBjb21wYXJhdG9yc1tzZWxmLmxlZnQub3BlcmF0b3JdKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBub3JtYWxpemUoc2VsZi5vcGVyYXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubGVmdC5yaWdodCBpbnN0YW5jZW9mIGFzdC5TeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sZWZ0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnR2YXIgPSBzZWxmLmxlZnQucmlnaHQubmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxlZnQubGVmdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KHNlbGYubGVmdC5vcGVyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0dmFyID0gb3V0cHV0Lm5ld1RlbXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24obGVmdHZhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxlZnQucmlnaHQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZWQoXCImJlwiLCBsZWZ0dmFyLCBvcGVyYXRvciwgc2VsZi5yaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZWQoc2VsZi5sZWZ0LCBub3JtYWxpemUoc2VsZi5vcGVyYXRvciksIHNlbGYucmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgREVGUFJJTlQoYXN0LkRlZXBFcXVhbGl0eSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICB2YXIgcHJpbWl0aXZlcztcbiAgICAgICAgICAgIHByaW1pdGl2ZXMgPSBbIFwiQm9vbGVhblwiLCBcIlN0cmluZ1wiLCBcIk51bWJlclwiIF07XG4gICAgICAgICAgICBpZiAo1ZDVj19pbihzZWxmLmxlZnQuY29tcHV0ZWRUeXBlLCBwcmltaXRpdmVzKSB8fCDVkNWPX2luKHNlbGYucmlnaHQuY29tcHV0ZWRUeXBlLCBwcmltaXRpdmVzKSkge1xuICAgICAgICAgICAgICAgIHNlbGYubGVmdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgIHNlbGYub3BlcmF0b3IgPT09IFwiPT1cIiA/IG91dHB1dC5wcmludChcIj09PVwiKSA6IG91dHB1dC5wcmludChcIiE9PVwiKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJpZ2h0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQsIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gY2FjaGVCdWJibGUoc2VsZi5sZWZ0LCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcGVyYXRvciA9PT0gXCI9PVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZWQoXCI9PT1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gY2FjaGVCdWJibGUoc2VsZi5yaWdodCwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlZChcInx8XCIsIFwidHlwZW9mXCIsIGxlZnQsIFwiPT09XCIsICdcIm9iamVjdFwiJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIiYmXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCLVkNWPX2VxXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZWQoXCIhPT1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gY2FjaGVCdWJibGUoc2VsZi5yaWdodCwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiJiZcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VkKFwidHlwZW9mXCIsIGxlZnQsIFwiIT09XCIsICdcIm9iamVjdFwiJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwifHxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiIdWQ1Y9fZXFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5Bc3NpZ24sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmlnaHQgaW5zdGFuY2VvZiBhc3QuTnVtYmVyICYmIHNlbGYucmlnaHQudmFsdWUgPT09IDEgJiYg1ZDVj19pbihzZWxmLm9wZXJhdG9yLCBbIFwiKz1cIiwgXCItPVwiIF0pKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KHNlbGYub3BlcmF0b3IgPT09IFwiKz1cIiA/IFwiKytcIiA6IFwiLS1cIik7XG4gICAgICAgICAgICAgICAgc2VsZi5sZWZ0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wZXJhdG9yID09PSBcIi8vPVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hc3NpZ24oc2VsZi5sZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiTWF0aC5mbG9vclwiKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sZWZ0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmlnaHQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubGVmdCBpbnN0YW5jZW9mIGFzdC5BcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcImVzNlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfc3F1YXJlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubGVmdC5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KG91dHB1dC5uZXdUZW1wKFwidXBrXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGVmdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoc2VsZi5vcGVyYXRvcik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucmlnaHQgaW5zdGFuY2VvZiBhc3QuTmV3KSB7XG4gICAgICAgICAgICAgICAgICAgIENSRUFUSU9OLnB1c2goc2VsZi5sZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5yaWdodC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBhc3QuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvdXRwdXQub3B0aW9uKFwiZXM2XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuZW5kX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5wYWNrX3R1cGxlKHNlbGYubGVmdCwgb3V0cHV0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5Db25kaXRpb25hbCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBzZWxmLmNvbmRpdGlvbi5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI/XCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLmNvbnNlcXVlbnQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgICAgICBzZWxmLmFsdGVybmF0aXZlLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuQXJyYXksIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LndpdGhfc3F1YXJlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheSwgbGVuXztcbiAgICAgICAgICAgICAgICBhcnJheSA9IHNlbGYuZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgbGVuXyA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGVuXyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24oZXhwLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHAucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobGVuXyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuUmFuZ2UsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyINWQ1Y9pdHI4MSwg1ZDVj2lkeDgxO1xuICAgICAgICAgICAgdmFyIGluZGV4ZXMsIGVsZW1lbnQsIHN0YXJ0LCBlbmQsIHN0ZXA7XG4gICAgICAgICAgICBpbmRleGVzID0gW107XG4gICAgICAgICAgICDVkNWPaXRyODEgPSDVkNWPX0l0ZXJhYmxlKFsgc2VsZi5sZWZ0LCBzZWxmLnJpZ2h0IF0pO1xuICAgICAgICAgICAgZm9yICjVkNWPaWR4ODEgPSAwOyDVkNWPaWR4ODEgPCDVkNWPaXRyODEubGVuZ3RoOyDVkNWPaWR4ODErKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSDVkNWPaXRyODFb1ZDVj2lkeDgxXTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIGFzdC5VbmFyeVByZWZpeCAmJiBlbGVtZW50Lm9wZXJhdG9yID09PSBcIi1cIiAmJiBlbGVtZW50LmV4cHJlc3Npb24gaW5zdGFuY2VvZiBhc3QuTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChwYXJzZUZsb2F0KFwiLVwiICsgZWxlbWVudC5leHByZXNzaW9uLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgYXN0Lk51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2gocGFyc2VGbG9hdChlbGVtZW50LnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleGVzWzBdICYmIGluZGV4ZXNbMV0gJiYgTWF0aC5hYnMoaW5kZXhlc1sxXSAtIGluZGV4ZXNbMF0pIDwgNTApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGluZGV4ZXNbMF07XG4gICAgICAgICAgICAgICAgZW5kID0gaW5kZXhlc1sxXTtcbiAgICAgICAgICAgICAgICBzdGVwID0gc3RhcnQgPCBlbmQgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYub3BlcmF0b3IgPT09IFwidG9cIikge1xuICAgICAgICAgICAgICAgICAgICBlbmQgKz0gc3RlcCAvIDFlNjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfc3F1YXJlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIg1ZDVj2l0cjgyLCDVkNWPaWR4ODI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgICDVkNWPaXRyODIgPSDVkNWPX0l0ZXJhYmxlKHJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICjVkNWPaWR4ODIgPSAwOyDVkNWPaWR4ODIgPCDVkNWPaXRyODIubGVuZ3RoOyDVkNWPaWR4ODIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9INWQ1Y9pdHI4MlvVkNWPaWR4ODJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwicmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxlZnQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wZXJhdG9yID09PSBcInRvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZWQoc2VsZi5sZWZ0LCBcIjxcIiwgc2VsZi5yaWdodCwgXCI/XCIsIHNlbGYucmlnaHQsIFwiK1wiLCAxZS02LCBcIjpcIiwgc2VsZi5yaWdodCwgXCItXCIsIDFlLTYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yaWdodC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2VkKHNlbGYubGVmdCwgXCI8XCIsIHNlbGYucmlnaHQsIFwiP1wiLCBcIjFcIiwgXCI6XCIsIFwiLTFcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuT2JqZWN0TGl0ZXJhbCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5PYmplY3RLZXlWYWwsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgaWYgKHNlbGYua2V5IGluc3RhbmNlb2YgYXN0LklkZW50aWZpZXIgfHwgc2VsZi5rZXkgaW5zdGFuY2VvZiBhc3QuU3RyaW5nIHx8IHNlbGYua2V5IGluc3RhbmNlb2YgYXN0Lk51bWJlciB8fCBzZWxmLmtleSBpbnN0YW5jZW9mIGFzdC5Cb29sZWFuKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5rZXkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfc3F1YXJlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmtleS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgICAgICBzZWxmLnZhbHVlLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhc3QuU3ltYm9sLnByb3RvdHlwZS5kZWZpbml0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aGVkZWY7XG4gICAgICAgIH07XG4gICAgICAgIERFRlBSSU5UKGFzdC5TeW1ib2wsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIGRlZl87XG4gICAgICAgICAgICBkZWZfID0gc2VsZi5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnRfbmFtZShkZWZfID8gZGVmXy5tYW5nbGVkX25hbWUgfHwgZGVmXy5uYW1lIDogc2VsZi5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5VbmRlZmluZWQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwidm9pZCAwXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgREVGUFJJTlQoYXN0LkhvbGUsIG5vb3ApO1xuICAgICAgICBERUZQUklOVChhc3QuSW5maW5pdHksIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiMS8wXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgREVGUFJJTlQoYXN0Lk5vdEFOdW1iZXIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiMC8wXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgREVGUFJJTlQoYXN0LlRoaXMsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwidGhpc1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5Db25zdGFudCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoc2VsZi5nZXRWYWx1ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5TdHJpbmcsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgaWYgKNWQ1Y9faW4oc2VsZi5tb2RpZmllciwgXCJmRlwiKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImBcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50X3N0cmluZyhzZWxmLmdldFZhbHVlKCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJgXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKHNlbGYuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuVmVyYmF0aW0sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KHNlbGYuZ2V0VmFsdWUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBERUZQUklOVChhc3QuTnVtYmVyLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChtYWtlX251bShzZWxmLmdldFZhbHVlKCkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIERFRlBSSU5UKGFzdC5SZWdFeHAsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIHN0cl8sIHA7XG4gICAgICAgICAgICBzdHJfID0gc2VsZi5nZXRWYWx1ZSgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcImFzY2lpX29ubHlcIikpIHtcbiAgICAgICAgICAgICAgICBzdHJfID0gb3V0cHV0LnRvX2FzY2lpKHN0cl8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LnByaW50KHN0cl8pO1xuICAgICAgICAgICAgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgYXN0LkJpbmFyeSAmJiAvXmluLy50ZXN0KHAub3BlcmF0b3IpICYmIHAubGVmdCA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBmb3JjZV9zdGF0ZW1lbnQoc3RhdCwgb3V0cHV0KSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcImJyYWNrZXRpemVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXQgfHwgc3RhdCBpbnN0YW5jZW9mIGFzdC5FbXB0eVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBhc3QuQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXQgfHwgc3RhdCBpbnN0YW5jZW9mIGFzdC5FbXB0eVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuZm9yY2Vfc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmaXJzdF9pbl9zdGF0ZW1lbnQob3V0cHV0KSB7XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc2VkLCBpLCBub2RlLCBwcmV2O1xuICAgICAgICAgICAgcHJvY2Vzc2VkID0gb3V0cHV0LnN0YWNrKCk7XG4gICAgICAgICAgICBpID0gcHJvY2Vzc2VkLmxlbmd0aDtcbiAgICAgICAgICAgIG5vZGUgPSBwcm9jZXNzZWRbLS1pXTtcbiAgICAgICAgICAgIHByZXYgPSBwcm9jZXNzZWRbLS1pXTtcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2IGluc3RhbmNlb2YgYXN0LlN0YXRlbWVudCAmJiBwcmV2LmJvZHkgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2IGluc3RhbmNlb2YgYXN0LlNlcSAmJiBwcmV2LmNhciA9PT0gbm9kZSB8fCBwcmV2IGluc3RhbmNlb2YgYXN0LkJhc2VDYWxsICYmIHByZXYuZXhwcmVzc2lvbiA9PT0gbm9kZSB8fCBwcmV2IGluc3RhbmNlb2YgYXN0LkRvdCAmJiBwcmV2LmV4cHJlc3Npb24gPT09IG5vZGUgfHwgcHJldiBpbnN0YW5jZW9mIGFzdC5TdWIgJiYgcHJldi5leHByZXNzaW9uID09PSBub2RlIHx8IHByZXYgaW5zdGFuY2VvZiBhc3QuQ29uZGl0aW9uYWwgJiYgcHJldi5jb25kaXRpb24gPT09IG5vZGUgfHwgcHJldiBpbnN0YW5jZW9mIGFzdC5CaW5hcnkgJiYgcHJldi5sZWZ0ID09PSBub2RlIHx8IHByZXYgaW5zdGFuY2VvZiBhc3QuVW5hcnlQb3N0Zml4ICYmIHByZXYuZXhwcmVzc2lvbiA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gcHJldjtcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IHByb2Nlc3NlZFstLWldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbm9fY29uc3RydWN0b3JfcGFyZW5zKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuYXJncy5sZW5ndGggPT09IDAgJiYgIW91dHB1dC5vcHRpb24oXCJiZWF1dGlmeVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiZXN0X29mKGNob2ljZXMpIHtcbiAgICAgICAgICAgIHZhciBiZXN0LCBsZW5fLCBpO1xuICAgICAgICAgICAgYmVzdCA9IGNob2ljZXNbMF07XG4gICAgICAgICAgICBsZW5fID0gYmVzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgY2hvaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjaG9pY2VzW2ldLmxlbmd0aCA8IGxlbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdCA9IGNob2ljZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGxlbl8gPSBiZXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmVzdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlX251bShudW0pIHtcbiAgICAgICAgICAgIHZhciBzdHJfLCBjaG9pY2VzLCBtYXRjaDtcbiAgICAgICAgICAgIHN0cl8gPSBudW0udG9TdHJpbmcoMTApO1xuICAgICAgICAgICAgY2hvaWNlcyA9IFsgc3RyXy5yZXBsYWNlKC9eMFxcLi8sIFwiLlwiKS5yZXBsYWNlKFwiZStcIiwgXCJlXCIpIF07XG4gICAgICAgICAgICBtYXRjaCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoTWF0aC5mbG9vcihudW0pID09PSBudW0pIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlcy5wdXNoKFwiMHhcIiArIG51bS50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKSwgXCIwXCIgKyBudW0udG9TdHJpbmcoOCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNob2ljZXMucHVzaChcIi0weFwiICsgKC1udW0pLnRvU3RyaW5nKDE2KS50b0xvd2VyQ2FzZSgpLCBcIi0wXCIgKyAoLW51bSkudG9TdHJpbmcoOCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPSAvXiguKj8pKDArKSQvLmV4ZWMobnVtKSkge1xuICAgICAgICAgICAgICAgICAgICBjaG9pY2VzLnB1c2gobWF0Y2hbMV0gKyBcImVcIiArIG1hdGNoWzJdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IC9eMD9cXC4oMCspKC4qKSQvLmV4ZWMobnVtKSkge1xuICAgICAgICAgICAgICAgIGNob2ljZXMucHVzaChtYXRjaFsyXSArIFwiZS1cIiArIChtYXRjaFsxXS5sZW5ndGggKyBtYXRjaFsyXS5sZW5ndGgpLCBzdHJfLnN1YnN0cihzdHJfLmluZGV4T2YoXCIuXCIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmVzdF9vZihjaG9pY2VzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlX2Jsb2NrKHN0bXQsIG91dHB1dCkge1xuICAgICAgICAgICAgaWYgKHN0bXQgaW5zdGFuY2VvZiBhc3QuQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzdG10LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gREVGTUFQKG5vZGV0eXBlLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIG5vZGV0eXBlLnByb3RvdHlwZS5hZGRfc291cmNlX21hcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRvcih0aGlzLCBzdHJlYW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBERUZNQVAoYXN0Lk5vZGUsIG5vb3ApO1xuICAgICAgICBmdW5jdGlvbiBiYXNpY19zb3VyY2VtYXBfZ2VuKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LmFkZF9tYXBwaW5nKHNlbGYuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIERFRk1BUChhc3QuRGlyZWN0aXZlLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICAgICAgREVGTUFQKGFzdC5EZWJ1Z2dlciwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgICAgIERFRk1BUChhc3QuU3ltYm9sLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICAgICAgREVGTUFQKGFzdC5KdW1wLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICAgICAgREVGTUFQKGFzdC5TdGF0ZW1lbnRXaXRoQm9keSwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgICAgIERFRk1BUChhc3QuTGFiZWxlZFN0YXRlbWVudCwgbm9vcCk7XG4gICAgICAgIERFRk1BUChhc3QuTGFtYmRhLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICAgICAgREVGTUFQKGFzdC5Td2l0Y2gsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgICAgICBERUZNQVAoYXN0LlN3aXRjaEJyYW5jaCwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgICAgIERFRk1BUChhc3QuQmxvY2tTdGF0ZW1lbnQsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgICAgICBERUZNQVAoYXN0LlRvcExldmVsLCBub29wKTtcbiAgICAgICAgREVGTUFQKGFzdC5OZXcsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgICAgICBERUZNQVAoYXN0LlRyeSwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgICAgIERFRk1BUChhc3QuQ2F0Y2gsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgICAgICBERUZNQVAoYXN0LkZpbmFsbHksIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgICAgICBERUZNQVAoYXN0LkRlZmluaXRpb25zLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICAgICAgREVGTUFQKGFzdC5Db25zdGFudCwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgICAgIERFRk1BUChhc3QuT2JqZWN0UHJvcGVydHksIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LmFkZF9tYXBwaW5nKHNlbGYuc3RhcnQsIHNlbGYua2V5KTtcbiAgICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICDVkNWPX21vZHVsZXNbXCJvdXRwdXRcIl1bXCJTdHJlYW1cIl0gPSBTdHJlYW07XG59KSgpO1xudmFyIGV4cG9ydHMsIHJhcHlkc2NyaXB0LCBjb21waWxlO1xudmFyIHV0aWxzID0g1ZDVj19tb2R1bGVzW1widXRpbHNcIl07XG5cbnZhciBhc3QgPSDVkNWPX21vZHVsZXNbXCJhc3RcIl07XG5cbnZhciB0b2tlbml6ZXIgPSDVkNWPX21vZHVsZXNbXCJ0b2tlbml6ZXJcIl07XG5cbnZhciBwYXJzZXIgPSDVkNWPX21vZHVsZXNbXCJwYXJzZXJcIl07XG5cbnZhciBvdXRwdXQgPSDVkNWPX21vZHVsZXNbXCJvdXRwdXRcIl07XG5cbmFzdC5Ob2RlLndhcm5fZnVuY3Rpb24gPSBmdW5jdGlvbih0eHQpIHtcbiAgICBjb25zb2xlLmVycm9yKHR4dCk7XG59O1xuZnVuY3Rpb24gc3BsYXRCYXNlbGliKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IGFzdC5TcGxhdCh7XG4gICAgICAgIG1vZHVsZTogbmV3IGFzdC5TeW1ib2xWYXIoe1xuICAgICAgICAgICAgbmFtZToga2V5XG4gICAgICAgIH0pLFxuICAgICAgICBib2R5OiBuZXcgYXN0LlRvcExldmVsKHtcbiAgICAgICAgICAgIHN0YXJ0OiB2YWx1ZVswXS5zdGFydCxcbiAgICAgICAgICAgIGJvZHk6IHZhbHVlLFxuICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgZW5kOiB2YWx1ZVt2YWx1ZS5sZW5ndGgtMV0uZW5kXG4gICAgICAgIH0pXG4gICAgfSk7XG59XG5pZiAoIWV4cG9ydHMpIHtcbiAgICByYXB5ZHNjcmlwdCA9IGV4cG9ydHMgPSB7fTtcbn1cbmV4cG9ydHMucGFyc2VfYmFzZWxpYiA9IGV4cG9ydHMucGFyc2VCYXNlbGliID0gZnVuY3Rpb24oc3JjUGF0aCwgYmVhdXRpZnkpIHtcbiAgICB2YXIg1ZDVj2l0cjgzLCDVkNWPaWR4ODM7XG4gICAgdmFyIGZzLCBiYXNlbGliUGF0aCwgYmFzZWxpYkFzdCwgaGFzaCwgZGF0YSwgYmFzZWxpYkxpc3QsIGl0ZW0sIGtleSwgdmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgICAgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgICAgIGJhc2VsaWJQYXRoID0gcmVxdWlyZShcInBhdGhcIikuam9pbihzcmNQYXRoLCBcImJhc2VsaWIucHlqXCIpO1xuICAgICAgICBiYXNlbGliQXN0ID0gcGFyc2VyLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhiYXNlbGliUGF0aCwgXCJ1dGY4XCIpLCB7XG4gICAgICAgICAgICByZWFkZmlsZTogZnMucmVhZEZpbGVTeW5jLFxuICAgICAgICAgICAgZHJvcERvY3N0cmluZ3M6IHRydWUsXG4gICAgICAgICAgICBmaWxlbmFtZTogXCJiYXNlbGliLnB5alwiXG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKNWQ1Y9fRXhjZXB0aW9uKSB7XG4gICAgICAgIHZhciBlID0g1ZDVj19FeGNlcHRpb247XG4gICAgICAgIGlmIChlLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICAgIHRocm93IFwiRmFpbGVkIHRvIGxvY2FsdGUgYmFzZWxpYiBtb2R1bGUuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyDVkNWPX0V4Y2VwdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNoID0gYmFzZWxpYkFzdC5ib2R5W2Jhc2VsaWJBc3QuYm9keS5sZW5ndGgtMV07XG4gICAgZGF0YSA9IGhhc2guYm9keS5wcm9wZXJ0aWVzO1xuICAgIGJhc2VsaWJMaXN0ID0ge307XG4gICAg1ZDVj2l0cjgzID0g1ZDVj19JdGVyYWJsZShkYXRhKTtcbiAgICBmb3IgKNWQ1Y9pZHg4MyA9IDA7INWQ1Y9pZHg4MyA8INWQ1Y9pdHI4My5sZW5ndGg7INWQ1Y9pZHg4MysrKSB7XG4gICAgICAgIGl0ZW0gPSDVkNWPaXRyODNb1ZDVj2lkeDgzXTtcbiAgICAgICAga2V5ID0gaXRlbS5rZXkudmFsdWU7XG4gICAgICAgIHZhbHVlID0gaXRlbS52YWx1ZS5uYW1lID8gWyBpdGVtLnZhbHVlIF0gOiBpdGVtLnZhbHVlLmJvZHk7XG4gICAgICAgIGJhc2VsaWJMaXN0W2tleV0gPSBzcGxhdEJhc2VsaWIoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlbGliTGlzdDtcbn07XG5leHBvcnRzLmdldF9pbXBvcnRfZGlycyA9IGZ1bmN0aW9uKHBhdGhzX3N0cmluZywgaWdub3JlX2Vudikge1xuICAgIHZhciBwYXRocywgcGF0aDtcbiAgICBwYXRocyA9IFtdO1xuICAgIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbiAgICBmdW5jdGlvbiBtZXJnZShuZXdfcGF0aCkge1xuICAgICAgICBpZiAoISjVkNWPX2luKG5ld19wYXRoLCBwYXRocykpKSB7XG4gICAgICAgICAgICBwYXRocy5wdXNoKG5ld19wYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlnbm9yZV9lbnYgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5SQVBZRFNDUklQVF9QQVRIKSB7XG4gICAgICAgIHByb2Nlc3MuZW52LlJBUFlEU0NSSVBUX1BBVEguc3BsaXQocGF0aC5kZWxpbWl0ZXIpLmZvckVhY2gobWVyZ2UpO1xuICAgIH1cbiAgICBpZiAocGF0aHNfc3RyaW5nKSB7XG4gICAgICAgIHBhdGhzX3N0cmluZy5zcGxpdChwYXRoLmRlbGltaXRlcikuZm9yRWFjaChtZXJnZSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRocztcbn07XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlID0gZnVuY3Rpb24oY29kZSwgb3B0aW9ucykge1xuICAgIHZhciB0b3BsZXZlbCwgc3RyZWFtO1xuICAgIHRvcGxldmVsID0gcGFyc2VyLnBhcnNlKGNvZGUsIHV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgdG9wbGV2ZWw6IHRvcGxldmVsLFxuICAgICAgICBvdXRwdXQ6IHt9XG4gICAgfSkpO1xuICAgIGlmICghb3B0aW9ucy5vbWl0X2Jhc2VsaWIpIHtcbiAgICAgICAgaWYgKCF0b3BsZXZlbC5iYXNlbGliW1wiQXNzZXJ0aW9uRXJyb3JcIl0pIHtcbiAgICAgICAgICAgIC0tdG9wbGV2ZWwuYmFzZWxpYltcImV4dGVuZHNcIl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3BsZXZlbC5iYXNlbGliW1wiSW5kZXhFcnJvclwiXSkge1xuICAgICAgICAgICAgLS10b3BsZXZlbC5iYXNlbGliW1wiZXh0ZW5kc1wiXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcGxldmVsLmJhc2VsaWJbXCJLZXlFcnJvclwiXSkge1xuICAgICAgICAgICAgLS10b3BsZXZlbC5iYXNlbGliW1wiZXh0ZW5kc1wiXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcGxldmVsLmJhc2VsaWJbXCJUeXBlRXJyb3JcIl0pIHtcbiAgICAgICAgICAgIC0tdG9wbGV2ZWwuYmFzZWxpYltcImV4dGVuZHNcIl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3BsZXZlbC5iYXNlbGliW1wiVmFsdWVFcnJvclwiXSkge1xuICAgICAgICAgICAgLS10b3BsZXZlbC5iYXNlbGliW1wiZXh0ZW5kc1wiXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcGxldmVsLmJhc2VsaWJbXCJrd2FyZ3NcIl0pIHtcbiAgICAgICAgICAgIC0tdG9wbGV2ZWwuYmFzZWxpYltcImluXCJdO1xuICAgICAgICAgICAgLS10b3BsZXZlbC5iYXNlbGliW1wiaXRlcmF0b3JcIl07XG4gICAgICAgICAgICAtLXRvcGxldmVsLmJhc2VsaWJbXCJyYW5nZVwiXTtcbiAgICAgICAgICAgIC0tdG9wbGV2ZWwuYmFzZWxpYltcImRpclwiXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcGxldmVsLmJhc2VsaWJbXCJlcVwiXSkge1xuICAgICAgICAgICAgdG9wbGV2ZWwuYmFzZWxpYltcIml0ZXJhdG9yXCJdIC09IDI7XG4gICAgICAgICAgICAtLXRvcGxldmVsLmJhc2VsaWJbXCJyYW5nZVwiXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcGxldmVsLmJhc2VsaWJbXCJtZXJnZVwiXSkge1xuICAgICAgICAgICAgLS10b3BsZXZlbC5iYXNlbGliW1wiaXRlcmF0b3JcIl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3BsZXZlbC5iYXNlbGliW1wibWl4aW5cIl0pIHtcbiAgICAgICAgICAgIC0tdG9wbGV2ZWwuYmFzZWxpYltcImluXCJdO1xuICAgICAgICAgICAgdG9wbGV2ZWwuYmFzZWxpYltcIml0ZXJhdG9yXCJdIC09IDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3BsZXZlbC5iYXNlbGliW1wiZW51bWVyYXRlXCJdKSB7XG4gICAgICAgICAgICAtLXRvcGxldmVsLmJhc2VsaWJbXCJpdGVyYXRvclwiXTtcbiAgICAgICAgICAgIC0tdG9wbGV2ZWwuYmFzZWxpYltcInJhbmdlXCJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdG9wbGV2ZWwuYmFzZWxpYltcImFsbFwiXSkge1xuICAgICAgICAgICAgLS10b3BsZXZlbC5iYXNlbGliW1wiaXRlcmF0b3JcIl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3BsZXZlbC5iYXNlbGliW1wiYW55XCJdKSB7XG4gICAgICAgICAgICAtLXRvcGxldmVsLmJhc2VsaWJbXCJpdGVyYXRvclwiXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcGxldmVsLmJhc2VsaWJbXCJ6aXBcIl0pIHtcbiAgICAgICAgICAgIC0tdG9wbGV2ZWwuYmFzZWxpYltcIml0ZXJhdG9yXCJdO1xuICAgICAgICAgICAgLS10b3BsZXZlbC5iYXNlbGliW1wicmFuZ2VcIl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3BsZXZlbC5iYXNlbGliW1wicmViaW5kX2FsbFwiXSkge1xuICAgICAgICAgICAgLS10b3BsZXZlbC5iYXNlbGliW1wiYmluZFwiXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJlYW0gPSBvdXRwdXQuU3RyZWFtKG9wdGlvbnMpO1xuICAgIHRvcGxldmVsLnByaW50KHN0cmVhbSk7XG4gICAgcmV0dXJuIHN0cmVhbS50b1N0cmluZygpO1xufTtcbmV4cG9ydHMubWluaWZ5ID0gZnVuY3Rpb24oZmlsZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIg1ZDVj2l0cjg0LCDVkNWPaWR4ODQ7XG4gICAgdmFyIG9wdGlvbnMsIGZpbGVzLCBmaWxlLCBjb2RlO1xuICAgIG9wdGlvbnMgPSB1dGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGZyb21TdHJpbmc6IGZhbHNlLFxuICAgICAgICB3YXJuaW5nczogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGZpbGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZpbGVzID0gWyBmaWxlcyBdO1xuICAgIH1cbiAgICDVkNWPaXRyODQgPSDVkNWPX0l0ZXJhYmxlKGZpbGVzKTtcbiAgICBmb3IgKNWQ1Y9pZHg4NCA9IDA7INWQ1Y9pZHg4NCA8INWQ1Y9pdHI4NC5sZW5ndGg7INWQ1Y9pZHg4NCsrKSB7XG4gICAgICAgIGZpbGUgPSDVkNWPaXRyODRb1ZDVj2lkeDg0XTtcbiAgICAgICAgb3B0aW9ucy5maWxlbmFtZSA9IG9wdGlvbnMuZnJvbVN0cmluZyA/IFwiP1wiIDogZmlsZTtcbiAgICAgICAgY29kZSA9IG9wdGlvbnMuZnJvbVN0cmluZyA/IGZpbGUgOiByZXF1aXJlKFwiZnNcIikucmVhZEZpbGVTeW5jKGZpbGUsIFwidXRmOFwiKTtcbiAgICAgICAgcmV0cnVuO1xuICAgICAgICAoe1xuICAgICAgICAgICAgY29kZTogY29tcGlsZShjb2RlLCBvcHRpb25zKVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlci5wYXJzZTtcbmV4cG9ydHMub3V0cHV0ID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gICAgdmFyIHN0cmVhbTtcbiAgICBzdHJlYW0gPSBvdXRwdXQuU3RyZWFtKG9wdGlvbnMpO1xuICAgIGFzdC5wcmludChzdHJlYW0pO1xuICAgIHJldHVybiBzdHJlYW0udG9TdHJpbmcoKTtcbn07XG5leHBvcnRzLnN0cmluZ190ZW1wbGF0ZSA9IHV0aWxzLnN0cmluZ190ZW1wbGF0ZTtcbmV4cG9ydHMuYXN0ID0gYXN0O1xuZXhwb3J0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG5leHBvcnRzLk5BVElWRV9DTEFTU0VTID0gcGFyc2VyLk5BVElWRV9DTEFTU0VTO1xuZXhwb3J0cy5QYXJzZUVycm9yID0gdXRpbHMuUGFyc2VFcnJvcjtcbmV4cG9ydHMuSW1wb3J0RXJyb3IgPSB1dGlscy5JbXBvcnRFcnJvcjtcbmV4cG9ydHMuQUxMX0tFWVdPUkRTID0gdG9rZW5pemVyLkFMTF9LRVlXT1JEUztcbmV4cG9ydHMuSURFTlRJRklFUl9QQVQgPSB0b2tlbml6ZXIuSURFTlRJRklFUl9QQVQ7XG5leHBvcnRzLmNvbG9yZWQgPSB1dGlscy5jb2xvcmVkO3ZhciDVkNWPXzEyNCwg1ZDVj18xMjUsINWQ1Y9fMTI2LCDVkNWPXzEyNywg1ZDVj18xMjg7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsInZhciDVkNWPdXBrNSwg1ZDVj18yLCDVkNWPXzMsINWQ1Y9fNCwg1ZDVj181O1xuZnVuY3Rpb24g1ZDVj19iaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgdmFyIGZuLCByZXQ7XG4gICAgaWYgKGZuLm9yaWcpIHtcbiAgICAgICAgZm4gPSBmbi5vcmlnO1xuICAgIH1cbiAgICBpZiAodGhpc0FyZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgICByZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICByZXQub3JpZyA9IGZuO1xuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiDVkNWPX3JlYmluZEFsbCh0aGlzQXJnLCByZWJpbmQpIHtcbiAgICB2YXIgcmViaW5kO1xuICAgIGlmIChyZWJpbmQgPT09IHZvaWQgMCkge1xuICAgICAgICByZWJpbmQgPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBwIGluIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHRoaXNBcmdbcF0gJiYgdGhpc0FyZ1twXS5vcmlnKSB7XG4gICAgICAgICAgICBpZiAocmViaW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpc0FyZ1twXSA9INWQ1Y9fYmluZCh0aGlzQXJnW3BdLCB0aGlzQXJnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc0FyZ1twXSA9IHRoaXNBcmdbcF0ub3JpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uINWQ1Y9fZXh0ZW5kcyhjaGlsZCwgcGFyZW50KSB7XG4gICAgY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgICBjaGlsZC5wcm90b3R5cGUuX19iYXNlX18gPSBwYXJlbnQ7XG4gICAgY2hpbGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG59XG5mdW5jdGlvbiDVkNWPX0l0ZXJhYmxlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIHRtcDtcbiAgICBpZiAoaXRlcmFibGUuY29uc3RydWN0b3IgPT09IFtdLmNvbnN0cnVjdG9yIHx8IGl0ZXJhYmxlLmNvbnN0cnVjdG9yID09PSBcIlwiLmNvbnN0cnVjdG9yIHx8ICh0bXAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpdGVyYWJsZSkpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdG1wIHx8IGl0ZXJhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaXRlcmFibGUpO1xufVxuZnVuY3Rpb24gbGVuKG9iaikge1xuICAgIHZhciB0bXA7XG4gICAgaWYgKG9iai5jb25zdHJ1Y3RvciA9PT0gW10uY29uc3RydWN0b3IgfHwgb2JqLmNvbnN0cnVjdG9yID09PSBcIlwiLmNvbnN0cnVjdG9yIHx8ICh0bXAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICh0bXAgfHwgb2JqKS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgdmFyIHN0b3AsIHN0YXJ0LCBzdGVwLCBsZW5ndGgsIGlkeCwgcmFuZ2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gYXJndW1lbnRzWzJdIHx8IDE7XG4gICAgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIGlkeCA9IDA7XG4gICAgcmFuZ2UgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB3aGlsZSAoaWR4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJhbmdlW2lkeCsrXSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiDVkNWPX3R5cGUob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPyBvYmouY29uc3RydWN0b3IubmFtZSA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopLnNsaWNlKDgsIC0xKTtcbn1cbmZ1bmN0aW9uINWQ1Y9fZXEoYSwgYikge1xuICAgIHZhciDVkNWPaXRyMTAsINWQ1Y9pZHgxMDtcbiAgICB2YXIgaTtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSB8fCBhIGluc3RhbmNlb2YgT2JqZWN0ICYmIGIgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IgfHwgYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCHVkNWPX2VxKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICDVkNWPaXRyMTAgPSDVkNWPX0l0ZXJhYmxlKGEpO1xuICAgICAgICAgICAgZm9yICjVkNWPaWR4MTAgPSAwOyDVkNWPaWR4MTAgPCDVkNWPaXRyMTAubGVuZ3RoOyDVkNWPaWR4MTArKykge1xuICAgICAgICAgICAgICAgIGkgPSDVkNWPaXRyMTBb1ZDVj2lkeDEwXTtcbiAgICAgICAgICAgICAgICBpZiAoIdWQ1Y9fZXEoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxudmFyIEluZGV4RXJyb3IgPSAo1ZDVj182ID0gZnVuY3Rpb24gSW5kZXhFcnJvcigpIHtcbiAgICBJbmRleEVycm9yLnByb3RvdHlwZS5fX2luaXRfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSwg1ZDVj19leHRlbmRzKNWQ1Y9fNiwgRXJyb3IpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzYucHJvdG90eXBlLCB7XG4gICAgX19pbml0X186IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9faW5pdF9fKG1lc3NhZ2Upe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAg1ZDVj19yZWJpbmRBbGwodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICBzZWxmLm5hbWUgPSBcIkluZGV4RXJyb3JcIjtcbiAgICAgICAgICAgIHNlbGYubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9XG59KSwg1ZDVj182KTtcbnZhciBUeXBlRXJyb3IgPSAo1ZDVj183ID0gZnVuY3Rpb24gVHlwZUVycm9yKCkge1xuICAgIFR5cGVFcnJvci5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzcsIEVycm9yKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj183LnByb3RvdHlwZSwge1xuICAgIF9faW5pdF9fOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfX2luaXRfXyhtZXNzYWdlKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgINWQ1Y9fcmViaW5kQWxsKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgc2VsZi5uYW1lID0gXCJUeXBlRXJyb3JcIjtcbiAgICAgICAgICAgIHNlbGYubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9XG59KSwg1ZDVj183KTtcbnZhciBWYWx1ZUVycm9yID0gKNWQ1Y9fOCA9IGZ1bmN0aW9uIFZhbHVlRXJyb3IoKSB7XG4gICAgVmFsdWVFcnJvci5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0sINWQ1Y9fZXh0ZW5kcyjVkNWPXzgsIEVycm9yKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMo1ZDVj184LnByb3RvdHlwZSwge1xuICAgIF9faW5pdF9fOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfX2luaXRfXyhtZXNzYWdlKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgINWQ1Y9fcmViaW5kQWxsKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgc2VsZi5uYW1lID0gXCJWYWx1ZUVycm9yXCI7XG4gICAgICAgICAgICBzZWxmLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxufSksINWQ1Y9fOCk7XG52YXIg1ZDVj19tb2R1bGVzID0ge307XG7VkNWPX21vZHVsZXNbXCJyYW5kb21cIl0gPSB7fTtcbtWQ1Y9fbW9kdWxlc1tcInN0ZGxpYlwiXSA9IHt9O1xuXG4oZnVuY3Rpb24oKXtcbiAgICB2YXIgX19uYW1lX18gPSBcInJhbmRvbVwiO1xuICAgIHZhciBfJHJhcHlkJF9zZWVkX3N0YXRlLCBfJHJhcHlkJF9nZXRfcmFuZG9tX2J5dGU7XG4gICAgXyRyYXB5ZCRfc2VlZF9zdGF0ZSA9IHtcbiAgICAgICAga2V5OiBbXSxcbiAgICAgICAga2V5X2k6IDAsXG4gICAgICAgIGtleV9qOiAwXG4gICAgfTtcbiAgICBfJHJhcHlkJF9nZXRfcmFuZG9tX2J5dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyINWQ1Y91cGsxO1xuICAgICAgICBfJHJhcHlkJF9zZWVkX3N0YXRlLmtleV9pID0gKF8kcmFweWQkX3NlZWRfc3RhdGUua2V5X2kgKyAxKSAlIDI1NjtcbiAgICAgICAgXyRyYXB5ZCRfc2VlZF9zdGF0ZS5rZXlfaiA9IChfJHJhcHlkJF9zZWVkX3N0YXRlLmtleV9qICsgXyRyYXB5ZCRfc2VlZF9zdGF0ZS5rZXlbXyRyYXB5ZCRfc2VlZF9zdGF0ZS5rZXlfaV0pICUgMjU2O1xuICAgICAgICDVkNWPdXBrMSA9IFsgXyRyYXB5ZCRfc2VlZF9zdGF0ZS5rZXlbXyRyYXB5ZCRfc2VlZF9zdGF0ZS5rZXlfal0sIF8kcmFweWQkX3NlZWRfc3RhdGUua2V5W18kcmFweWQkX3NlZWRfc3RhdGUua2V5X2ldIF07XG4gICAgICAgIF8kcmFweWQkX3NlZWRfc3RhdGUua2V5W18kcmFweWQkX3NlZWRfc3RhdGUua2V5X2ldID0g1ZDVj3VwazFbMF07XG4gICAgICAgIF8kcmFweWQkX3NlZWRfc3RhdGUua2V5W18kcmFweWQkX3NlZWRfc3RhdGUua2V5X2pdID0g1ZDVj3VwazFbMV07XG4gICAgICAgIHJldHVybiBfJHJhcHlkJF9zZWVkX3N0YXRlLmtleVsoXyRyYXB5ZCRfc2VlZF9zdGF0ZS5rZXlbXyRyYXB5ZCRfc2VlZF9zdGF0ZS5rZXlfaV0gKyBfJHJhcHlkJF9zZWVkX3N0YXRlLmtleVtfJHJhcHlkJF9zZWVkX3N0YXRlLmtleV9qXSkgJSAyNTZdO1xuICAgIH07XG4gICAgZnVuY3Rpb24gc2VlZCh4KSB7XG4gICAgICAgIHZhciDVkNWPdXBrMjtcbiAgICAgICAgeCA9IHggPT09IHZvaWQgMCA/IG5ldyBEYXRlKCkuZ2V0VGltZSgpIDogeDtcbiAgICAgICAgdmFyIHgsIGksIGo7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgeCA9IHgudG9TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgeCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVuaGFzaGFibGUgdHlwZTogJ1wiICsgdHlwZW9mIHggKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBfJHJhcHlkJF9zZWVkX3N0YXRlLmtleVtpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaiA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICAgICAgaiA9IChqICsgXyRyYXB5ZCRfc2VlZF9zdGF0ZS5rZXlbaV0gKyB4LmNoYXJDb2RlQXQoaSAlIHgubGVuZ3RoKSkgJSAyNTY7XG4gICAgICAgICAgICDVkNWPdXBrMiA9IFsgXyRyYXB5ZCRfc2VlZF9zdGF0ZS5rZXlbal0sIF8kcmFweWQkX3NlZWRfc3RhdGUua2V5W2ldIF07XG4gICAgICAgICAgICBfJHJhcHlkJF9zZWVkX3N0YXRlLmtleVtpXSA9INWQ1Y91cGsyWzBdO1xuICAgICAgICAgICAgXyRyYXB5ZCRfc2VlZF9zdGF0ZS5rZXlbal0gPSDVkNWPdXBrMlsxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWVkKCk7XG4gICAgZnVuY3Rpb24gcmFuZG9tKCkge1xuICAgICAgICB2YXIgbiwgbSwgaTtcbiAgICAgICAgbiA9IDA7XG4gICAgICAgIG0gPSAxO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBuICs9IF8kcmFweWQkX2dldF9yYW5kb21fYnl0ZSgpICogbTtcbiAgICAgICAgICAgIG0gKj0gMjU2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuIC8gMHgxMDAwMDAwMDAwMDAwMDAwMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZHJhbmdlKCkge1xuICAgICAgICByZXR1cm4gY2hvaWNlKHJhbmdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByYW5kaW50KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJhbmRvbSgpICogKGIgLSBhICsgMSkgKyBhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5pZm9ybShhLCBiKSB7XG4gICAgICAgIHJldHVybiByYW5kb20oKSAqIChiIC0gYSkgKyBhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaG9pY2Uoc2VxKSB7XG4gICAgICAgIGlmIChzZXEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcVtNYXRoLmZsb29yKHJhbmRvbSgpICogc2VxLmxlbmd0aCldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4RXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaHVmZmxlKHgsIHJhbmRvbV9mKSB7XG4gICAgICAgIHZhciDVkNWPdXBrMztcbiAgICAgICAgcmFuZG9tX2YgPSByYW5kb21fZiA9PT0gdm9pZCAwID8gcmFuZG9tIDogcmFuZG9tX2Y7XG4gICAgICAgIHZhciBpLCBqO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaiA9IE1hdGguZmxvb3IocmFuZG9tX2YoKSAqIChpICsgMSkpO1xuICAgICAgICAgICAg1ZDVj3VwazMgPSBbIHhbal0sIHhbaV0gXTtcbiAgICAgICAgICAgIHhbaV0gPSDVkNWPdXBrM1swXTtcbiAgICAgICAgICAgIHhbal0gPSDVkNWPdXBrM1sxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FtcGxlKHBvcHVsYXRpb24sIGspIHtcbiAgICAgICAgdmFyINWQ1Y9pdHIxLCDVkNWPaWR4MSwg1ZDVj3VwazQ7XG4gICAgICAgIHZhciB4LCBpLCBqO1xuICAgICAgICB4ID0gcG9wdWxhdGlvbi5zbGljZSgpO1xuICAgICAgICDVkNWPaXRyMSA9INWQ1Y9fSXRlcmFibGUocmFuZ2UocG9wdWxhdGlvbi5sZW5ndGggLSAxLCBwb3B1bGF0aW9uLmxlbmd0aCAtIGsgLSAxLCAtMSkpO1xuICAgICAgICBmb3IgKNWQ1Y9pZHgxID0gMDsg1ZDVj2lkeDEgPCDVkNWPaXRyMS5sZW5ndGg7INWQ1Y9pZHgxKyspIHtcbiAgICAgICAgICAgIGkgPSDVkNWPaXRyMVvVkNWPaWR4MV07XG4gICAgICAgICAgICBqID0gTWF0aC5mbG9vcihyYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICAgICAg1ZDVj3VwazQgPSBbIHhbal0sIHhbaV0gXTtcbiAgICAgICAgICAgIHhbaV0gPSDVkNWPdXBrNFswXTtcbiAgICAgICAgICAgIHhbal0gPSDVkNWPdXBrNFsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geC5zbGljZShwb3B1bGF0aW9uLmxlbmd0aCAtIGspO1xuICAgIH1cbiAgICDVkNWPX21vZHVsZXNbXCJyYW5kb21cIl1bXCJfJHJhcHlkJF9zZWVkX3N0YXRlXCJdID0gXyRyYXB5ZCRfc2VlZF9zdGF0ZTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInJhbmRvbVwiXVtcIl8kcmFweWQkX2dldF9yYW5kb21fYnl0ZVwiXSA9IF8kcmFweWQkX2dldF9yYW5kb21fYnl0ZTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInJhbmRvbVwiXVtcInNlZWRcIl0gPSBzZWVkO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wicmFuZG9tXCJdW1wicmFuZG9tXCJdID0gcmFuZG9tO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wicmFuZG9tXCJdW1wicmFuZHJhbmdlXCJdID0gcmFuZHJhbmdlO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wicmFuZG9tXCJdW1wicmFuZGludFwiXSA9IHJhbmRpbnQ7XG5cbiAgICDVkNWPX21vZHVsZXNbXCJyYW5kb21cIl1bXCJ1bmlmb3JtXCJdID0gdW5pZm9ybTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInJhbmRvbVwiXVtcImNob2ljZVwiXSA9IGNob2ljZTtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInJhbmRvbVwiXVtcInNodWZmbGVcIl0gPSBzaHVmZmxlO1xuXG4gICAg1ZDVj19tb2R1bGVzW1wicmFuZG9tXCJdW1wic2FtcGxlXCJdID0gc2FtcGxlO1xufSkoKTtcblxuKGZ1bmN0aW9uKCl7XG4gICAgdmFyIF9fbmFtZV9fID0gXCJzdGRsaWJcIjtcbiAgICB2YXIgc3RyO1xuICAgIHN0ciA9IEpTT04uc3RyaW5naWZ5O1xuICAgIFN0cmluZy5wcm90b3R5cGUuZmluZCA9IFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZjtcbiAgICBTdHJpbmcucHJvdG90eXBlLnN0cmlwID0gU3RyaW5nLnByb3RvdHlwZS50cmltO1xuICAgIFN0cmluZy5wcm90b3R5cGUubHN0cmlwID0gU3RyaW5nLnByb3RvdHlwZS50cmltTGVmdDtcbiAgICBTdHJpbmcucHJvdG90eXBlLnJzdHJpcCA9IFN0cmluZy5wcm90b3R5cGUudHJpbVJpZ2h0O1xuICAgIFN0cmluZy5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZS5qb2luKHRoaXMpO1xuICAgIH07XG4gICAgU3RyaW5nLnByb3RvdHlwZS56ZmlsbCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHM7XG4gICAgICAgIHMgPSB0aGlzO1xuICAgICAgICB3aGlsZSAocy5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgICAgICBzID0gXCIwXCIgKyBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbGlzdChpdGVyYWJsZSkge1xuICAgICAgICB2YXIg1ZDVj2l0cjIsINWQ1Y9pZHgyO1xuICAgICAgICBpdGVyYWJsZSA9IGl0ZXJhYmxlID09PSB2b2lkIDAgPyBbXSA6IGl0ZXJhYmxlO1xuICAgICAgICB2YXIgcmVzdWx0LCBpO1xuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAg1ZDVj2l0cjIgPSDVkNWPX0l0ZXJhYmxlKGl0ZXJhYmxlKTtcbiAgICAgICAgZm9yICjVkNWPaWR4MiA9IDA7INWQ1Y9pZHgyIDwg1ZDVj2l0cjIubGVuZ3RoOyDVkNWPaWR4MisrKSB7XG4gICAgICAgICAgICBpID0g1ZDVj2l0cjJb1ZDVj2lkeDJdO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBBcnJheS5wcm90b3R5cGUuYXBwZW5kID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG4gICAgQXJyYXkucHJvdG90eXBlLmZpbmQgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbiAgICBBcnJheS5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIg1ZDVj18xO1xuICAgICAgICB2YXIgdmFsO1xuICAgICAgICB2YWwgPSB0aGlzLmZpbmQoaW5kZXgpO1xuICAgICAgICBpZiAoKHZhbCA9PT0gKNWQ1Y9fMSA9IC0xKSB8fCB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmINWQ1Y9fZXEodmFsLCDVkNWPXzEpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3Ioc3RyKGluZGV4KSArIFwiIGlzIG5vdCBpbiBsaXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICBBcnJheS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuICAgIH07XG4gICAgQXJyYXkucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPT09IHZvaWQgMCA/IHRoaXMubGVuZ3RoIC0gMSA6IGluZGV4O1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgIH07XG4gICAgQXJyYXkucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKGFycmF5Mikge1xuICAgICAgICB0aGlzLnB1c2guYXBwbHkodGhpcywgYXJyYXkyKTtcbiAgICB9O1xuICAgIEFycmF5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgaW5kZXggPSB0aGlzLmZpbmQoaXRlbSk7XG4gICAgICAgIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICAgIEFycmF5LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKDApO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZGljdChpdGVyYWJsZSkge1xuICAgICAgICB2YXIg1ZDVj2l0cjMsINWQ1Y9pZHgzO1xuICAgICAgICB2YXIgcmVzdWx0LCBrZXk7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICDVkNWPaXRyMyA9INWQ1Y9fSXRlcmFibGUoaXRlcmFibGUpO1xuICAgICAgICBmb3IgKNWQ1Y9pZHgzID0gMDsg1ZDVj2lkeDMgPCDVkNWPaXRyMy5sZW5ndGg7INWQ1Y9pZHgzKyspIHtcbiAgICAgICAgICAgIGtleSA9INWQ1Y9pdHIzW9WQ1Y9pZHgzXTtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gaXRlcmFibGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAo1ZDVj190eXBlKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGRpY3Qua2V5cyA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgICAgICAgIHZhciBrZXlzO1xuICAgICAgICAgICAga2V5cyA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgIGZvciAodmFyIHggaW4gaGFzaCkge1xuICAgICAgICAgICAgaWYgKGhhc2guaGFzT3duUHJvcGVydHkoeCkpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGljdC5rZXlzID0gZnVuY3Rpb24oaGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhhc2gpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBkaWN0LnZhbHVlcyA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgICAgdmFyINWQ1Y9pdHI0LCDVkNWPaWR4NDtcbiAgICAgICAgdmFyIHZhbHMsIGtleTtcbiAgICAgICAgdmFscyA9IFtdO1xuICAgICAgICDVkNWPaXRyNCA9INWQ1Y9fSXRlcmFibGUoZGljdC5rZXlzKGhhc2gpKTtcbiAgICAgICAgZm9yICjVkNWPaWR4NCA9IDA7INWQ1Y9pZHg0IDwg1ZDVj2l0cjQubGVuZ3RoOyDVkNWPaWR4NCsrKSB7XG4gICAgICAgICAgICBrZXkgPSDVkNWPaXRyNFvVkNWPaWR4NF07XG4gICAgICAgICAgICB2YWxzLmFwcGVuZChoYXNoW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxzO1xuICAgIH07XG4gICAgZGljdC5pdGVtcyA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgICAgdmFyINWQ1Y9pdHI1LCDVkNWPaWR4NTtcbiAgICAgICAgdmFyIGl0ZW1zLCBrZXk7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgINWQ1Y9pdHI1ID0g1ZDVj19JdGVyYWJsZShkaWN0LmtleXMoaGFzaCkpO1xuICAgICAgICBmb3IgKNWQ1Y9pZHg1ID0gMDsg1ZDVj2lkeDUgPCDVkNWPaXRyNS5sZW5ndGg7INWQ1Y9pZHg1KyspIHtcbiAgICAgICAgICAgIGtleSA9INWQ1Y9pdHI1W9WQ1Y9pZHg1XTtcbiAgICAgICAgICAgIGl0ZW1zLmFwcGVuZChba2V5LCBoYXNoW2tleV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfTtcbiAgICBkaWN0LmNvcHkgPSBkaWN0O1xuICAgIGRpY3QuY2xlYXIgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgICAgIHZhciDVkNWPaXRyNiwg1ZDVj2lkeDY7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgINWQ1Y9pdHI2ID0g1ZDVj19JdGVyYWJsZShkaWN0LmtleXMoaGFzaCkpO1xuICAgICAgICBmb3IgKNWQ1Y9pZHg2ID0gMDsg1ZDVj2lkeDYgPCDVkNWPaXRyNi5sZW5ndGg7INWQ1Y9pZHg2KyspIHtcbiAgICAgICAgICAgIGtleSA9INWQ1Y9pdHI2W9WQ1Y9pZHg2XTtcbiAgICAgICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgINWQ1Y9fbW9kdWxlc1tcInN0ZGxpYlwiXVtcInN0clwiXSA9IHN0cjtcblxuICAgINWQ1Y9fbW9kdWxlc1tcInN0ZGxpYlwiXVtcImxpc3RcIl0gPSBsaXN0O1xuXG4gICAg1ZDVj19tb2R1bGVzW1wic3RkbGliXCJdW1wiZGljdFwiXSA9IGRpY3Q7XG59KSgpO1xuXG52YXIgX19uYW1lX18gPSBcIl9fbWFpbl9fXCI7XG52YXIgd2lkdGgsIGhlaWdodCwgY29sb3JzO1xudmFyIHJhbmRvbSA9INWQ1Y9fbW9kdWxlc1tcInJhbmRvbVwiXTtcblxudmFyIHN0ZGxpYiA9INWQ1Y9fbW9kdWxlc1tcInN0ZGxpYlwiXTtcblxuZnVuY3Rpb24gX3ByaW50KCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIHZhciBzZXAsIGVuZDtcbiAgICBzZXAgPSBcIiBcIjtcbiAgICBlbmQgPSBcIlxcblwiO1xuICAgIGZ1bmN0aW9uIHByaW50QXN5bmMoKSB7XG4gICAgICAgIHZhciBlbGVtZW50LCBhcmcsIGFkZGl0aW9uLCBwcmV2aW91cztcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiX190ZXJtaW5hbF9fXCIpO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgYWRkaXRpb24gPSBzZXAuam9pbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyINWQ1Y9pZHg3LCDVkNWPaXRyNyA9INWQ1Y9fSXRlcmFibGUoYXJncyksINWQ1Y9yZXMgPSBbXSwgYXJnO1xuICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDcgPSAwOyDVkNWPaWR4NyA8INWQ1Y9pdHI3Lmxlbmd0aDsg1ZDVj2lkeDcrKykge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSDVkNWPaXRyN1vVkNWPaWR4N107XG4gICAgICAgICAgICAgICAgICAgINWQ1Y9yZXMucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4g1ZDVj3JlcztcbiAgICAgICAgICAgIH0pKCkpICsgZW5kO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBlbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gcHJldmlvdXMgKyBhZGRpdGlvbi5yZXBsYWNlKFwiXFxuXCIsIFwiPGJyPlwiKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzZXAuam9pbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyINWQ1Y9pZHg4LCDVkNWPaXRyOCA9INWQ1Y9fSXRlcmFibGUoYXJncyksINWQ1Y9yZXMgPSBbXSwgYXJnO1xuICAgICAgICAgICAgICAgIGZvciAo1ZDVj2lkeDggPSAwOyDVkNWPaWR4OCA8INWQ1Y9pdHI4Lmxlbmd0aDsg1ZDVj2lkeDgrKykge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSDVkNWPaXRyOFvVkNWPaWR4OF07XG4gICAgICAgICAgICAgICAgICAgINWQ1Y9yZXMucHVzaChzdHIoYXJnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiDVkNWPcmVzO1xuICAgICAgICAgICAgfSkoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFRpbWVvdXQocHJpbnRBc3luYywgNSk7XG59XG5fcHJpbnQoXCI8aDE+RWR1Y2EuSnVlZ29zPC9oMT5cIik7XG5fcHJpbnQoXCI8aDI+QXByZW5kZSBqdWdhbmRvPC9oMT5cIik7XG7VkNWPdXBrNSA9IFsgODAwLCAyMDAgXTtcbndpZHRoID0g1ZDVj3VwazVbMF07XG5oZWlnaHQgPSDVkNWPdXBrNVsxXTtcbnZhciBCb2xhMiA9ICjVkNWPXzIgPSBmdW5jdGlvbiBCb2xhMigpIHtcbiAgICB0aGlzLnJlY29sb3IgPSDVkNWPX2JpbmQodGhpcy5yZWNvbG9yLCB0aGlzKTtcbiAgICB0aGlzLmRlc3Ryb3kgPSDVkNWPX2JpbmQodGhpcy5kZXN0cm95LCB0aGlzKTtcbiAgICB0aGlzLnBsYXkgPSDVkNWPX2JpbmQodGhpcy5wbGF5LCB0aGlzKTtcbiAgICBCb2xhMi5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fMi5wcm90b3R5cGUsIHtcbiAgICBfX2luaXRfXzoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX19pbml0X18oKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgINWQ1Y9fcmViaW5kQWxsKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgZGlyZWN0b3IuZ2FtZS5jaXJjbGUoMzAsIGNvbG9ycy52aWJlX2xpZ2h0KTtcbiAgICAgICAgICAgIHNlbGYuZGlyZWN0b3IgPSBlZHVjYWp1ZWdvO1xuICAgICAgICAgICAgc2VsZi5zcHJpdGUgPSBzZWxmO1xuICAgICAgICAgICAgc2VsZi5zcHJpdGUueCA9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgIHNlbGYuc3ByaXRlLnkgPSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgc2VsZi5zcHJpdGUudnkgPSByYW5kb20ucmFuZGludCgtNSwgNCkgfHwgNTtcbiAgICAgICAgICAgIHNlbGYuc3ByaXRlLnZ4ID0gcmFuZG9tLnJhbmRpbnQoLTMsIDIpIHx8IDM7XG4gICAgICAgICAgICBzZWxmLnJlY29sb3IoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVjb2xvcjoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb2xvcigpe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi5zcHJpdGUuZmlsbFN0eWxlID0gcmFuZG9tLmNob2ljZShbIGNvbG9ycy52aWJlX2xpZ2h0LCBjb2xvcnMudmliZSwgY29sb3JzLm11dGUsIGNvbG9ycy5tdXRlX2xpZ2h0IF0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95OiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCl7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLnRvX2RlbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLnNwcml0ZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLmRpcmVjdG9yLmdhbWUucmVtb3ZlKHNlbGYuc3ByaXRlKTtcbiAgICAgICAgICAgIHNlbGYuc3ByaXRlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcGxheToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGxheSgpe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHNlbGYuc3ByaXRlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zcHJpdGUueSA+IGhlaWdodCAtIHNlbGYuc3ByaXRlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNwcml0ZS52eSAqPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc3ByaXRlLnggPiB3aWR0aCAtIHNlbGYuc3ByaXRlLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zcHJpdGUueSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zcHJpdGUudnkgKj0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNwcml0ZS54IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5kaXJlY3Rvci5nYW1lLm1vdmUoc2VsZi5zcHJpdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSksINWQ1Y9fMik7XG52YXIgQm9sYSA9ICjVkNWPXzMgPSBmdW5jdGlvbiBCb2xhKCkge1xuICAgIHRoaXMucmVjb2xvciA9INWQ1Y9fYmluZCh0aGlzLnJlY29sb3IsIHRoaXMpO1xuICAgIHRoaXMuZGVzdHJveSA9INWQ1Y9fYmluZCh0aGlzLmRlc3Ryb3ksIHRoaXMpO1xuICAgIHRoaXMucGxheSA9INWQ1Y9fYmluZCh0aGlzLnBsYXksIHRoaXMpO1xuICAgIEJvbGEucHJvdG90eXBlLl9faW5pdF9fLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyjVkNWPXzMucHJvdG90eXBlLCB7XG4gICAgX19pbml0X186IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9faW5pdF9fKGRpcmVjdG9yKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgINWQ1Y9fcmViaW5kQWxsKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgc2VsZi5kaXJlY3RvciA9IGRpcmVjdG9yO1xuICAgICAgICAgICAgc2VsZi50b19kZWxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuc3ByaXRlID0gZGlyZWN0b3IuZ2FtZS5jaXJjbGUoMzAsIGNvbG9ycy52aWJlX2xpZ2h0KTtcbiAgICAgICAgICAgIHNlbGYuc3ByaXRlLnggPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBzZWxmLnNwcml0ZS55ID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIHNlbGYuc3ByaXRlLnZ5ID0gcmFuZG9tLnJhbmRpbnQoLTUsIDQpIHx8IDU7XG4gICAgICAgICAgICBzZWxmLnNwcml0ZS52eCA9IHJhbmRvbS5yYW5kaW50KC0zLCAyKSB8fCAzO1xuICAgICAgICAgICAgc2VsZi5yZWNvbG9yKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlY29sb3I6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29sb3IoKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuc3ByaXRlLmZpbGxTdHlsZSA9IHJhbmRvbS5jaG9pY2UoWyBjb2xvcnMudmliZV9saWdodCwgY29sb3JzLnZpYmUsIGNvbG9ycy5tdXRlLCBjb2xvcnMubXV0ZV9saWdodCBdKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi50b19kZWxldGUgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5zcHJpdGUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5kaXJlY3Rvci5nYW1lLnJlbW92ZShzZWxmLnNwcml0ZSk7XG4gICAgICAgICAgICBzZWxmLnNwcml0ZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHBsYXk6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZWxmLnNwcml0ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc3ByaXRlLnkgPiBoZWlnaHQgLSBzZWxmLnNwcml0ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zcHJpdGUudnkgKj0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNwcml0ZS54ID4gd2lkdGggLSBzZWxmLnNwcml0ZS53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zcHJpdGUueSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zcHJpdGUudnkgKj0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNwcml0ZS54IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmRpcmVjdG9yLmdhbWUubW92ZShzZWxmLnNwcml0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KSwg1ZDVj18zKTtcbnZhciBEaXJlY3RvciA9ICjVkNWPXzQgPSBmdW5jdGlvbiBEaXJlY3RvcigpIHtcbiAgICB0aGlzLnNldHVwID0g1ZDVj19iaW5kKHRoaXMuc2V0dXAsIHRoaXMpO1xuICAgIHRoaXMucmVjb2xvciA9INWQ1Y9fYmluZCh0aGlzLnJlY29sb3IsIHRoaXMpO1xuICAgIHRoaXMubWFrZV9ib2xhID0g1ZDVj19iaW5kKHRoaXMubWFrZV9ib2xhLCB0aGlzKTtcbiAgICB0aGlzLnBsYXkgPSDVkNWPX2JpbmQodGhpcy5wbGF5LCB0aGlzKTtcbiAgICB0aGlzLnBhdXNlID0g1ZDVj19iaW5kKHRoaXMucGF1c2UsIHRoaXMpO1xuICAgIHRoaXMucmVzdW1lID0g1ZDVj19iaW5kKHRoaXMucmVzdW1lLCB0aGlzKTtcbiAgICB0aGlzLnJlc2NhbGUgPSDVkNWPX2JpbmQodGhpcy5yZXNjYWxlLCB0aGlzKTtcbiAgICBEaXJlY3Rvci5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNC5wcm90b3R5cGUsIHtcbiAgICBfX2luaXRfXzoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX19pbml0X18oKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgINWQ1Y9fcmViaW5kQWxsKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgc2VsZi5nYW1lID0gaGV4aSh3aWR0aCwgaGVpZ2h0LCBzZWxmLnNldHVwKTtcbiAgICAgICAgICAgIHNlbGYuZ2FtZS5mcHMgPSAyNTtcbiAgICAgICAgICAgIHNlbGYuYWN0b3JzID0gW107XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNldHVwOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cCgpe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi5yZWNvbG9yKCk7XG4gICAgICAgICAgICBzZWxmLmdhbWUuc3RhdGUgPSBzZWxmLnBsYXk7XG4gICAgICAgICAgICBzZWxmLm1ha2VfYm9sYSgpO1xuICAgICAgICAgICAgc2VsZi5wcmludCA9IF9wcmludDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVjb2xvcjoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb2xvcigpe1xuICAgICAgICAgICAgdmFyINWQ1Y9pdHI5LCDVkNWPaWR4OTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhY3RvcjtcbiAgICAgICAgICAgINWQ1Y9pdHI5ID0g1ZDVj19JdGVyYWJsZShzZWxmLmFjdG9ycyk7XG4gICAgICAgICAgICBmb3IgKNWQ1Y9pZHg5ID0gMDsg1ZDVj2lkeDkgPCDVkNWPaXRyOS5sZW5ndGg7INWQ1Y9pZHg5KyspIHtcbiAgICAgICAgICAgICAgICBhY3RvciA9INWQ1Y9pdHI5W9WQ1Y9pZHg5XTtcbiAgICAgICAgICAgICAgICBhY3Rvci5yZWNvbG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmdhbWUuYmFja2dyb3VuZENvbG9yID0gY29sb3JzLm11dGVfZGFyaztcbiAgICAgICAgICAgIHNlbGYucmVzY2FsZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtYWtlX2JvbGE6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VfYm9sYSgpe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi5hY3RvcnMuYXBwZW5kKG5ldyBCb2xhKHNlbGYpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcGxheToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGxheSgpe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGluZGV4LCBhY3RvcjtcbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbihzZWxmLmFjdG9ycyk7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBhY3RvciA9IHNlbGYuYWN0b3JzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3IudG9fZGVsZXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBhY3Rvci5wbGF5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhY3Rvci50b19kZWxldGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hY3RvcnMucG9wKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHBhdXNlOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsIFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSwgXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi5nYW1lLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlc3VtZToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdW1lKCl7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLmdhbWUucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlc2NhbGU6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2NhbGUoKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuZ2FtZS5zY2FsZVRvV2luZG93KGNvbG9ycy5tdXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn0pLCDVkNWPXzQpO1xuZnVuY3Rpb24gc2V0dXBfc3R5bGVzKCkge1xuICAgIHZhciBzdHlsZXM7XG4gICAgc3R5bGVzID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoIC0gMV07XG4gICAgc3R5bGVzLmluc2VydFJ1bGUoXCJoMSwgaDIgeyBjb2xvcjogXCIgKyBjb2xvcnMudmliZV9saWdodCArIFwiIH1cIiwgMCk7XG4gICAgc3R5bGVzLmluc2VydFJ1bGUoXCJoMSwgaDIgeyB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cIiwgMCk7XG4gICAgc3R5bGVzLmluc2VydFJ1bGUoXCJoMSwgaDIgeyBmb250LWZhbWlseTogJ0luZGllIEZsb3dlcic7IH1cIiwgMCk7XG4gICAgc3R5bGVzLmluc2VydFJ1bGUoXCIjX190ZXJtaW5hbF9fIHsgY29sb3I6IFwiICsgY29sb3JzLnZpYmVfbGlnaHQgKyBcIiB9XCIsIDApO1xuICAgIHN0eWxlcy5pbnNlcnRSdWxlKFwiI19fdGVybWluYWxfXyB7IGZvbnQtZmFtaWx5OiAnQml0dGVyJzsgfVwiLCAwKTtcbiAgICBzdHlsZXMuaW5zZXJ0UnVsZShcIiNfX3Byb21wdF9fIHsgZm9udC1mYW1pbHk6ICdCaXR0ZXInOyBwb3NpdGlvbjphYnNvbHV0ZTsgYm90dG9tOiAwOyByaWdodDogMH1cIiwgMCk7XG4gICAgaWYgKHdpbmRvdy5lZHVjYWp1ZWdvKSB7XG4gICAgICAgIHdpbmRvdy5lZHVjYWp1ZWdvLnJlY29sb3IoKTtcbiAgICB9XG59XG52YXIgUGFsZXR0ZSA9ICjVkNWPXzUgPSBmdW5jdGlvbiBQYWxldHRlKCkge1xuICAgIHRoaXMucGFyc2UgPSDVkNWPX2JpbmQodGhpcy5wYXJzZSwgdGhpcyk7XG4gICAgUGFsZXR0ZS5wcm90b3R5cGUuX19pbml0X18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKNWQ1Y9fNS5wcm90b3R5cGUsIHtcbiAgICBfX2luaXRfXzoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBcbiAgICAgICAgd3JpdGFibGU6IHRydWUsIFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX19pbml0X18oYXNzZXQsIGNhbGxiYWNrKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgINWQ1Y9fcmViaW5kQWxsKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHY7XG4gICAgICAgICAgICBzZWxmLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB2ID0gbmV3IFZpYnJhbnQoYXNzZXQpO1xuICAgICAgICAgICAgdi5nZXRQYWxldHRlKHNlbGYucGFyc2UpO1xuICAgICAgICAgICAgc2VsZi52aWJlID0gXCIjMzM1NTMzXCI7XG4gICAgICAgICAgICBzZWxmLnZpYmVfbGlnaHQgPSBcIiM2NTY1NjVcIjtcbiAgICAgICAgICAgIHNlbGYudmliZV9kYXJrID0gXCIjMGYxZjBmXCI7XG4gICAgICAgICAgICBzZWxmLm11dGUgPSBcIiMxMTExMTFcIjtcbiAgICAgICAgICAgIHNlbGYubXV0ZV9saWdodCA9IFwiIzMzMzMzM1wiO1xuICAgICAgICAgICAgc2VsZi5tdXRlX2RhcmsgPSBcIiMyMjIyMjJcIjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcGFyc2U6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLCBcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGVyciwgcGFsZXR0ZSl7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLnBhbGV0dGUgPSBwYWxldHRlO1xuICAgICAgICAgICAgc2VsZi52aWJlID0gcGFsZXR0ZS5WaWJyYW50LmdldEhleCgpO1xuICAgICAgICAgICAgc2VsZi52aWJlX2xpZ2h0ID0gcGFsZXR0ZS5MaWdodFZpYnJhbnQuZ2V0SGV4KCk7XG4gICAgICAgICAgICBzZWxmLnZpYmVfZGFyayA9IHBhbGV0dGUuRGFya1ZpYnJhbnQuZ2V0SGV4KCk7XG4gICAgICAgICAgICBzZWxmLm11dGUgPSBwYWxldHRlLk11dGVkLmdldEhleCgpO1xuICAgICAgICAgICAgc2VsZi5tdXRlX2xpZ2h0ID0gcGFsZXR0ZS5MaWdodE11dGVkLmdldEhleCgpO1xuICAgICAgICAgICAgc2VsZi5tdXRlX2RhcmsgPSBwYWxldHRlLkRhcmtNdXRlZC5nZXRIZXgoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSksINWQ1Y9fNSk7XG5mdW5jdGlvbiBtYWluKCkge1xuICAgIHZhciBlZHVjYWp1ZWdvO1xuICAgIHNldHVwX3N0eWxlcygpO1xuICAgIGVkdWNhanVlZ28gPSBuZXcgRGlyZWN0b3IoKTtcbiAgICBlZHVjYWp1ZWdvLmdhbWUuc3RhcnQoKTtcbiAgICB3aW5kb3cuc2V0SW50ZXJ2YWwoZWR1Y2FqdWVnby5tYWtlX2JvbGEsIDI1MCk7XG4gICAgd2luZG93Lm9uYmx1ciA9IGVkdWNhanVlZ28ucGF1c2U7XG4gICAgd2luZG93Lm9uZm9jdXMgPSBlZHVjYWp1ZWdvLnJlc3VtZTtcbiAgICB3aW5kb3cub25yZXNpemUgPSBlZHVjYWp1ZWdvLnJlc2NhbGU7XG4gICAgd2luZG93LmVkdWNhanVlZ28gPSBlZHVjYWp1ZWdvO1xufVxuY29sb3JzID0gbmV3IFBhbGV0dGUoXCJhc3NldHMvUGFsZXRhIGRlIENvbG9yZXMgMy5qcGdcIiwgc2V0dXBfc3R5bGVzKTtcbm1haW4oKTt2YXIg1ZDVj182LCDVkNWPXzcsINWQ1Y9fODtcbiJdfQ==
